{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/spff/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":1,"renderable":1},{"_id":"themes/spff/source/css/loading-style.css","path":"css/loading-style.css","modified":1,"renderable":1},{"_id":"themes/spff/source/css/showshare.css","path":"css/showshare.css","modified":1,"renderable":1},{"_id":"themes/spff/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/spff/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/spff/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/spff/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/spff/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/spff/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/spff/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/spff/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/spff/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/spff/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/spff/source/img/coderwall.png","path":"img/coderwall.png","modified":1,"renderable":1},{"_id":"themes/spff/source/img/delicious.png","path":"img/delicious.png","modified":1,"renderable":1},{"_id":"themes/spff/source/img/douban.png","path":"img/douban.png","modified":1,"renderable":1},{"_id":"themes/spff/source/img/facebook.png","path":"img/facebook.png","modified":1,"renderable":1},{"_id":"themes/spff/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/spff/source/img/github.png","path":"img/github.png","modified":1,"renderable":1},{"_id":"themes/spff/source/img/google.png","path":"img/google.png","modified":1,"renderable":1},{"_id":"themes/spff/source/img/head.jpg","path":"img/head.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/img/img-err.png","path":"img/img-err.png","modified":1,"renderable":1},{"_id":"themes/spff/source/img/img-loading.png","path":"img/img-loading.png","modified":1,"renderable":1},{"_id":"themes/spff/source/img/linkedin.png","path":"img/linkedin.png","modified":1,"renderable":1},{"_id":"themes/spff/source/img/mail.png","path":"img/mail.png","modified":1,"renderable":1},{"_id":"themes/spff/source/img/pinboard.png","path":"img/pinboard.png","modified":1,"renderable":1},{"_id":"themes/spff/source/img/pinterest.png","path":"img/pinterest.png","modified":1,"renderable":1},{"_id":"themes/spff/source/img/qq.png","path":"img/qq.png","modified":1,"renderable":1},{"_id":"themes/spff/source/img/rss.png","path":"img/rss.png","modified":1,"renderable":1},{"_id":"themes/spff/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/spff/source/img/stackoverflow.png","path":"img/stackoverflow.png","modified":1,"renderable":1},{"_id":"themes/spff/source/img/twitter.png","path":"img/twitter.png","modified":1,"renderable":1},{"_id":"themes/spff/source/img/wechat.png","path":"img/wechat.png","modified":1,"renderable":1},{"_id":"themes/spff/source/img/weibo.png","path":"img/weibo.png","modified":1,"renderable":1},{"_id":"themes/spff/source/img/zhihu.png","path":"img/zhihu.png","modified":1,"renderable":1},{"_id":"themes/spff/source/js/TweenMax.js","path":"js/TweenMax.js","modified":1,"renderable":1},{"_id":"themes/spff/source/js/clipboard.min.js","path":"js/clipboard.min.js","modified":1,"renderable":1},{"_id":"themes/spff/source/js/instagram.js","path":"js/instagram.js","modified":1,"renderable":1},{"_id":"themes/spff/source/js/jquery.lazyload.js","path":"js/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/spff/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/spff/source/js/mobile.js","path":"js/mobile.js","modified":1,"renderable":1},{"_id":"themes/spff/source/js/pace.js","path":"js/pace.js","modified":1,"renderable":1},{"_id":"themes/spff/source/js/pc.js","path":"js/pc.js","modified":1,"renderable":1},{"_id":"themes/spff/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"themes/spff/source/img/head1.jpg","path":"img/head1.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/js/TweenMax.min.js","path":"js/TweenMax.min.js","modified":1,"renderable":1},{"_id":"themes/spff/source/js/embed.js","path":"js/embed.js","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg-1.jpg","path":"background/bg-1.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg-109.jpg","path":"background/bg-109.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg-11.jpg","path":"background/bg-11.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg-17.jpg","path":"background/bg-17.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg-20.jpg","path":"background/bg-20.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg-3.jpg","path":"background/bg-3.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg.jpg","path":"background/bg.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/css/pace/pace-theme-flash.css","path":"css/pace/pace-theme-flash.css","modified":1,"renderable":1},{"_id":"themes/spff/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/spff/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/spff/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/spff/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/spff/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/spff/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/spff/source/font-awesome/css/font-awesome.css","path":"font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/spff/source/font-awesome/css/font-awesome.min.css","path":"font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/spff/source/js/404/jquery.parallaxify-0.0.2.min.js","path":"js/404/jquery.parallaxify-0.0.2.min.js","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg-15.jpg","path":"background/bg-15.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg-23.jpg","path":"background/bg-23.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg-7.jpg","path":"background/bg-7.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/font-awesome/fonts/FontAwesome.otf","path":"font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/spff/source/font-awesome/fonts/fontawesome-webfont.woff2","path":"font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/spff/source/font-awesome/fonts/fontawesome-webfont.eot","path":"font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/spff/source/font-awesome/fonts/fontawesome-webfont.woff","path":"font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/spff/source/js/404/jquery-2.0.3.min.js","path":"js/404/jquery-2.0.3.min.js","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg-14.jpg","path":"background/bg-14.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg-9.jpg","path":"background/bg-9.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/font-awesome/fonts/fontawesome-webfont.ttf","path":"font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg-19.jpg","path":"background/bg-19.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg-24.jpg","path":"background/bg-24.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg-8.jpg","path":"background/bg-8.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg-21.jpg","path":"background/bg-21.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg-22.jpg","path":"background/bg-22.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg-4.jpg","path":"background/bg-4.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg-6.jpg","path":"background/bg-6.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg-10.jpg","path":"background/bg-10.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg-12.jpg","path":"background/bg-12.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg-18.jpg","path":"background/bg-18.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/img/bg.jpg","path":"img/bg.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg-111.jpg","path":"background/bg-111.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg-16.jpg","path":"background/bg-16.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg-13.jpg","path":"background/bg-13.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/font-awesome/fonts/fontawesome-webfont.svg","path":"font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg-2.jpg","path":"background/bg-2.jpg","modified":1,"renderable":1},{"_id":"themes/spff/source/background/bg-5.jpg","path":"background/bg-5.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/spff/README.md","hash":"d549f7441186cf124996ea878934c8934f70412a","modified":1488347983000},{"_id":"themes/spff/_config.yml","hash":"fda26755d24b2b5e7cdc5cb4aed478a685ced276","modified":1488347983000},{"_id":"themes/spff/package.json","hash":"00357ef6f24eb049074da81809e98f973f528cca","modified":1488347983000},{"_id":"source/Home/index.md","hash":"202c470bfd52c09aaae3960258480135711fc132","modified":1488347983000},{"_id":"source/_posts/Glances.md","hash":"c7f6ec4d1832f0d552dd87cf53b0456d117f48ed","modified":1488347983000},{"_id":"source/_posts/git.md","hash":"2f8c1a7520823638d49e6972bcfd3753eb4196d5","modified":1488339969000},{"_id":"source/_posts/hexo.md","hash":"7905a70fd43ef7b142c4dd98f54dc2276f79e4dd","modified":1488347983000},{"_id":"source/_posts/htop使用说明.md","hash":"8b00bf91b1c3609d442fd39b029b9ffc7404491d","modified":1488347983000},{"_id":"source/_posts/keepalive+nginx实现高可用.md","hash":"03ad824db17e104a5f46082146d33b5012bfaabf","modified":1488347983000},{"_id":"source/_posts/linux traceroute 命令详解.md","hash":"4b552f2b9faeee26b682c6e92f936788d0dc314c","modified":1488347983000},{"_id":"source/_posts/linux_命令rsync+crontab实现自动同步.md","hash":"11cea6b193817c9380d46d9477b86307f37e3319","modified":1488348378000},{"_id":"source/_posts/linux—SSH1.md","hash":"8240b83168ade3b2a34e822123e3a0a984c66156","modified":1488347983000},{"_id":"source/_posts/linux—SSH（二）Rsync备份.md","hash":"d25a2b92bb48e8c7807f23428e5b9fbd0bc75066","modified":1488347983000},{"_id":"source/_posts/mtr命令详解.md","hash":"330896a64e688fb61023927717516ed29a163f2c","modified":1488347983000},{"_id":"source/_posts/mysql主从配置文件内容.md","hash":"23ffad66ae5f84598dd9486c88e2daaccf8b83b3","modified":1488347983000},{"_id":"source/_posts/tcpdump抓包命令详解.md","hash":"dd1faeea4e9e2f4396c5c586b8815388d44ef677","modified":1488347983000},{"_id":"source/_posts/tsung说明文档.md","hash":"95214d7371c154b7cac1d1f5bb53af7445a6925f","modified":1488347983000},{"_id":"source/_posts/yum仓库搭建之RPM包制作.md","hash":"f473cb60a9e5f74fd9ecd29630c0e88546d5a55b","modified":1488348270000},{"_id":"source/_posts/zabbix2.6安装.md","hash":"677b8b6832a9686c6d4f6d5d66f6831ab301f67a","modified":1488347983000},{"_id":"source/_posts/搭建WordPress.md","hash":"b52c2bd47e77488b7f33c456cded3c3e38c4c20c","modified":1488347983000},{"_id":"source/about/index-1.md","hash":"29c1c87269a5114b401d8afbe9cc82e1525aca18","modified":1488347983000},{"_id":"source/about/index.md","hash":"2d41e732c0aff996e56e4568af35b90a4b0ab1d6","modified":1488347983000},{"_id":"source/categories/index.md","hash":"e9b71e9785dce38d564e84be4ab85d99703aa247","modified":1488347983000},{"_id":"themes/spff/languages/de.yml","hash":"ecb13af8af81ccc033ae7494cb2f94f84f6466ad","modified":1488347983000},{"_id":"themes/spff/languages/default.yml","hash":"9e59cd11b290be84909612beb12d0f93ce737f53","modified":1488347983000},{"_id":"themes/spff/languages/en.yml","hash":"8fa0a7482188ca56fd3cf19c4a87320f85a76846","modified":1488347983000},{"_id":"themes/spff/languages/fr-FR.yml","hash":"12cfa96dc412ecb6f8bf4de2690575929464906e","modified":1488347983000},{"_id":"themes/spff/languages/pt-BR","hash":"922b6d836cc690742b2d55a725e3886c5d0cbb75","modified":1488347983000},{"_id":"themes/spff/languages/ru.yml","hash":"9997425292031ee8a58a93346ac6d3f38f18e566","modified":1488347983000},{"_id":"themes/spff/languages/zh-Hans.yml","hash":"0d7e8da60fd5e5db217e1733ac273ae00fd752ea","modified":1488347983000},{"_id":"themes/spff/languages/zh-hk.yml","hash":"606dfb34d3fec1d7895a654ff7a5a1de0c6a5c55","modified":1488347983000},{"_id":"themes/spff/languages/zh-tw.yml","hash":"9e4034870b57d2bb3063c91f8d206a6c4d7b3789","modified":1488347983000},{"_id":"themes/spff/languages/zh.yml","hash":"0d7e8da60fd5e5db217e1733ac273ae00fd752ea","modified":1488347983000},{"_id":"themes/spff/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1488347983000},{"_id":"themes/spff/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1488347983000},{"_id":"themes/spff/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1488347983000},{"_id":"themes/spff/layout/layout.ejs","hash":"4a5566f704f3246f5ef77badddf18d2e16750328","modified":1488347983000},{"_id":"themes/spff/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1488347983000},{"_id":"themes/spff/layout/plugins.swig","hash":"f809b5e62e968a80921c56e5d7658325b48b7263","modified":1488347983000},{"_id":"themes/spff/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1488347983000},{"_id":"themes/spff/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1488347983000},{"_id":"themes/spff/source/apple-touch-icon.png","hash":"c36a373c7830d61d1ce092bd5a88d0e9b54212fd","modified":1488347983000},{"_id":"themes/spff/layout/_partial/after-footer.ejs","hash":"54e262b6025026b3125868826c64527c3b8a4ca5","modified":1488347983000},{"_id":"themes/spff/layout/_partial/archive-post.ejs","hash":"8af583c5f60c69ffdc97bee4e8fdac1ba34ebecd","modified":1488347983000},{"_id":"themes/spff/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1488347983000},{"_id":"themes/spff/layout/_partial/article.ejs","hash":"13f788f96eec6cad9c29a6f373b88c164b279856","modified":1488347983000},{"_id":"themes/spff/layout/_partial/background.ejs","hash":"e566c3804a25e4c76f025db511dbaa0d008757e2","modified":1488347983000},{"_id":"themes/spff/layout/_partial/bodybackground.ejs","hash":"931700a928b84577cc33dfff68a009188885f6c0","modified":1488347983000},{"_id":"themes/spff/layout/_partial/case.swig","hash":"a2a7ec0e4c203e49fd32335c60c3b9851ed6e4a5","modified":1488347983000},{"_id":"themes/spff/layout/_partial/footer.ejs","hash":"0e54ea8678e6d6f0bf98a4b76f5c4ee4d424893f","modified":1488347983000},{"_id":"themes/spff/layout/_partial/head.ejs","hash":"8670e539351a3d248c299905e700d05e0a9b0f9a","modified":1488347983000},{"_id":"themes/spff/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1488347983000},{"_id":"themes/spff/layout/_partial/hide-labels.ejs","hash":"e981795db4954ba5cc9d6844a6a2799bffdc0af3","modified":1488347983000},{"_id":"themes/spff/layout/_partial/left-col.ejs","hash":"aa5acf4b363a925bb958ea08d161aaf7b75a8d70","modified":1488347983000},{"_id":"themes/spff/layout/_partial/mathjax.ejs","hash":"cdfd21f079933f3a275bc4088e1ca5e6068e75b4","modified":1488347983000},{"_id":"themes/spff/layout/_partial/mobile-nav.ejs","hash":"1ddd03edfb88867eff99bc0060466ea7cca3825c","modified":1488347983000},{"_id":"themes/spff/layout/_partial/page.ejs","hash":"55ffdcc87b5fa50afdc370f439c0e812e307cbff","modified":1488347983000},{"_id":"themes/spff/layout/_partial/plugin.swig","hash":"17b6c6945e4b1b41dbb10d851f85ca10100c28ea","modified":1488347983000},{"_id":"themes/spff/layout/_partial/post-nav-button.ejs","hash":"89b0b0bc70dcebfae064e2e7355177cd8f9e526b","modified":1488347983000},{"_id":"themes/spff/layout/_partial/scrolling-button.ejs","hash":"b3a28974f37375796687e6100b48c3da6f662640","modified":1488347983000},{"_id":"themes/spff/layout/_partial/theme.swig","hash":"5a279ad8f6c6b7c104cce495faa563d8b7a7c74a","modified":1488347983000},{"_id":"themes/spff/layout/_partial/toc.ejs","hash":"84bbda825793de643d5a40190fab2160af1e75e3","modified":1488347983000},{"_id":"themes/spff/layout/_partial/work.swig","hash":"6bdb6ec45f6179875e5a33bfdc7568a3831638fd","modified":1488347983000},{"_id":"themes/spff/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1488347983000},{"_id":"themes/spff/source/css/_variables.styl","hash":"47b0536f118d75fc9705c437faf89fd5a93b3615","modified":1488347983000},{"_id":"themes/spff/source/css/loading-style.css","hash":"1f67362d809e85edc9f122db7bc3711af1ed1d8b","modified":1488347983000},{"_id":"themes/spff/source/css/showshare.css","hash":"3efc4afd0d136fb5dec993e9cd9ce85b9d1cf589","modified":1488347983000},{"_id":"themes/spff/source/css/style.styl","hash":"998204af28e814cbb5a70f7534f1a67c23d5103d","modified":1488347983000},{"_id":"themes/spff/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1488347983000},{"_id":"themes/spff/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1488347983000},{"_id":"themes/spff/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1488347983000},{"_id":"themes/spff/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1488347983000},{"_id":"themes/spff/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1488347983000},{"_id":"themes/spff/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1488347983000},{"_id":"themes/spff/source/fancybox/jquery.fancybox.css","hash":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20","modified":1488347983000},{"_id":"themes/spff/source/fancybox/jquery.fancybox.js","hash":"a82597493d75ea989ca586e09173cff332efe41e","modified":1488347983000},{"_id":"themes/spff/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1488347983000},{"_id":"themes/spff/source/img/coderwall.png","hash":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1488347983000},{"_id":"themes/spff/source/img/delicious.png","hash":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1488347983000},{"_id":"themes/spff/source/img/douban.png","hash":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1488347983000},{"_id":"themes/spff/source/img/facebook.png","hash":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1488347983000},{"_id":"themes/spff/source/img/favicon.png","hash":"5b4e9c94ff3396db5b074b69c1aa5bb909aba825","modified":1488347983000},{"_id":"themes/spff/source/img/github.png","hash":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1488347983000},{"_id":"themes/spff/source/img/google.png","hash":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1488347983000},{"_id":"themes/spff/source/img/head.jpg","hash":"f96ad10fc77afd93821e72ac7fc3783e115cac42","modified":1488347983000},{"_id":"themes/spff/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1488347983000},{"_id":"themes/spff/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1488347983000},{"_id":"themes/spff/source/img/linkedin.png","hash":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1488347983000},{"_id":"themes/spff/source/img/mail.png","hash":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1488347983000},{"_id":"themes/spff/source/img/pinboard.png","hash":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1488347983000},{"_id":"themes/spff/source/img/pinterest.png","hash":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1488347983000},{"_id":"themes/spff/source/img/qq.png","hash":"fd741764c5528fe371f053beac99839a97900eef","modified":1488347983000},{"_id":"themes/spff/source/img/rss.png","hash":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1488347983000},{"_id":"themes/spff/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1488347983000},{"_id":"themes/spff/source/img/stackoverflow.png","hash":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1488347983000},{"_id":"themes/spff/source/img/twitter.png","hash":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1488347983000},{"_id":"themes/spff/source/img/wechat.png","hash":"7ca41b6e32ca4dac419225261ab4fee5a88f73a9","modified":1488347983000},{"_id":"themes/spff/source/img/weibo.png","hash":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1488347983000},{"_id":"themes/spff/source/img/zhihu.png","hash":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1488347983000},{"_id":"themes/spff/source/js/TweenMax.js","hash":"0ba64564a4fde4085fa3971dd53b7d64a41751e1","modified":1488347983000},{"_id":"themes/spff/source/js/clipboard.min.js","hash":"c13b4bb8fee46447284590d2afc0efca0ea3cb7b","modified":1488347983000},{"_id":"themes/spff/source/js/instagram.js","hash":"f19adbcc0dac33536bc6660598059048ec901882","modified":1488347983000},{"_id":"themes/spff/source/js/jquery.lazyload.js","hash":"c11a2e7b330d16d06feabd0a8477099adf9d6799","modified":1488347983000},{"_id":"themes/spff/source/js/main.js","hash":"153b4796d6c22f3bfaa28a4f8a361d4685286c6f","modified":1488347983000},{"_id":"themes/spff/source/js/mobile.js","hash":"d3847e5bcaf39108931724ecb02770c62b10889f","modified":1488347983000},{"_id":"themes/spff/source/js/pace.js","hash":"b49c10cd65d9488f7338e3c778e55ac6628650f3","modified":1488347983000},{"_id":"themes/spff/source/js/pc.js","hash":"ab375af6e3bcd054b1e87e1a8dcd3d7d25c2db40","modified":1488347983000},{"_id":"themes/spff/source/js/plugins.js","hash":"c1cf96b2d852b5803228a34d99014b005623bc06","modified":1488347983000},{"_id":"themes/spff/source/img/head1.jpg","hash":"80c0999acfc1173183d3dd243b4b90d077ab97cb","modified":1488347983000},{"_id":"themes/spff/source/js/TweenMax.min.js","hash":"eaa4e4a08400da3f22dedda706ba56cdce5b0b7a","modified":1488347983000},{"_id":"themes/spff/source/js/embed.js","hash":"8d2d4a812ab639bc02fdd8749d3a39f6b9406c54","modified":1488347983000},{"_id":"themes/spff/layout/_partial/analytics/baidu-analytics.ejs","hash":"b21500b87d79a0068e3ca0408b4e125e3e749d01","modified":1488347983000},{"_id":"themes/spff/layout/_partial/analytics/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1488347983000},{"_id":"themes/spff/layout/_partial/comments/disqus.ejs","hash":"7792a79ab85ef28551cc2a793735973b1d5521a7","modified":1488347983000},{"_id":"themes/spff/layout/_partial/comments/duoshuo.ejs","hash":"8d90eb435739eae6f0282c67899ba768b1d9cc7c","modified":1488347983000},{"_id":"themes/spff/layout/_partial/comments/youyan.ejs","hash":"a6853b59ee60e775de1ed90b242084f83774d195","modified":1488347983000},{"_id":"themes/spff/layout/_partial/post/TipTitle.ejs","hash":"65b0956edca84e0bc0eb616ec236309822d5f803","modified":1488347983000},{"_id":"themes/spff/layout/_partial/post/category.ejs","hash":"265bb12f7cfa5e0bcbb74fdd409ba13a6d9d2e22","modified":1488347983000},{"_id":"themes/spff/layout/_partial/post/date.ejs","hash":"1cfcf2e06ab9b1c6dcd44f41825dfe98d400c7ea","modified":1488347983000},{"_id":"themes/spff/layout/_partial/post/loading.ejs","hash":"52a576a8afee08d33c6f69a61c496e1820132e91","modified":1488347983000},{"_id":"themes/spff/layout/_partial/post/nav.ejs","hash":"d22cfc20d9a94a33b7e790c0fc4cb11136cb3059","modified":1488347983000},{"_id":"themes/spff/layout/_partial/post/swiftype.ejs","hash":"76374e601d911e1279e1944d2a6b7eb3391c7c7c","modified":1488347983000},{"_id":"themes/spff/layout/_partial/post/tag.ejs","hash":"9dad471e27de9e066666f3082137eccaede2e67b","modified":1488347983000},{"_id":"themes/spff/layout/_partial/share/baidu-share.ejs","hash":"21fbd6dbdcc631c61194ea04fc19b298133b0e2f","modified":1488347983000},{"_id":"themes/spff/layout/_partial/share/share.ejs","hash":"62467610ba6df9b63350d163e806be774dcf5a00","modified":1488347983000},{"_id":"themes/spff/layout/_partial/share/showshare.ejs","hash":"410b809eb6c50bacfd9e1e573f1e0251841bc79d","modified":1488347983000},{"_id":"themes/spff/source/background/bg-1.jpg","hash":"f0617756387d74f99afe0087c7b93a32f3c7096b","modified":1488347983000},{"_id":"themes/spff/source/background/bg-109.jpg","hash":"6171c1e921c8cc9bdcd7276cf7f0bee5295f4672","modified":1488347983000},{"_id":"themes/spff/source/background/bg-11.jpg","hash":"d69a0447e91f62977b144737f08620d77037c76a","modified":1488347983000},{"_id":"themes/spff/source/background/bg-17.jpg","hash":"6ab5e470059e8ccb0c8bc6786abfb5db7e9a1826","modified":1488347983000},{"_id":"themes/spff/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1488347983000},{"_id":"themes/spff/source/background/bg-20.jpg","hash":"9d428ac435198b2a0107102a2e9ae71e53afe364","modified":1488347983000},{"_id":"themes/spff/source/background/bg-3.jpg","hash":"f1347eddd07bdae93ab6bebad8627eddc5baeb44","modified":1488347983000},{"_id":"themes/spff/source/background/bg.jpg","hash":"f0617756387d74f99afe0087c7b93a32f3c7096b","modified":1488347983000},{"_id":"themes/spff/source/css/_partial/archive.styl","hash":"a8bc2e2458bcc51fa68122274a41f5e4e52a8ebd","modified":1488347983000},{"_id":"themes/spff/source/css/_partial/article.styl","hash":"8a7383c57181800add514705455d09f40975b758","modified":1488347983000},{"_id":"themes/spff/source/css/_partial/baidushare.styl","hash":"fe36e3d8933b1b0b674aaf16e50dbf6090099912","modified":1488347983000},{"_id":"themes/spff/source/css/_partial/footer.styl","hash":"cbf916a5338e69e05d0815c53aeb818d636b6d99","modified":1488347983000},{"_id":"themes/spff/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1488347983000},{"_id":"themes/spff/source/css/_partial/highlight.styl","hash":"f317abc2669a5b71c0f6661fdade86c630453fd0","modified":1488347983000},{"_id":"themes/spff/source/css/_partial/instagram.styl","hash":"db9cc156c7df27f7f54b0e7ff34b5949f55f99eb","modified":1488347983000},{"_id":"themes/spff/source/css/_partial/main.styl","hash":"667567c3ea25cd4acbaab98867a92fefd098fcc1","modified":1488347983000},{"_id":"themes/spff/source/css/_partial/mains.styl","hash":"530f74b0c32eb9554032004217b29d1df42161af","modified":1488347983000},{"_id":"themes/spff/source/css/_partial/mobile-slider.styl","hash":"3bf9f2359f68c700e21618ad6262db81038c3d96","modified":1488347983000},{"_id":"themes/spff/source/css/_partial/mobile.styl","hash":"53b1a06e08df81427505cbc76cc8eb02bea54356","modified":1488347983000},{"_id":"themes/spff/source/css/_partial/page.styl","hash":"46b9c91428c1e1f42cc8a1010f600f70fb8edc82","modified":1488347983000},{"_id":"themes/spff/source/css/_partial/plugins.styl","hash":"629ae10dfc053dbfc074966f0bf7f0115acf65e2","modified":1488347983000},{"_id":"themes/spff/source/css/_partial/scroll.styl","hash":"1932774d30b8706919342f9cf36ea2d99987ce14","modified":1488347983000},{"_id":"themes/spff/source/css/_partial/share.styl","hash":"2dde7c9ea40c71fce3dbd8d5e2bcc8d9682141b8","modified":1488347983000},{"_id":"themes/spff/source/css/_partial/tagcloud.styl","hash":"91e6553775ca931a1b3db1ab11c4cf227df68c21","modified":1488347983000},{"_id":"themes/spff/source/css/_partial/wheelmenu.styl","hash":"74630c56944e27bef53ef0c0e391611a2eec2ed0","modified":1488347983000},{"_id":"themes/spff/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1488347983000},{"_id":"themes/spff/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1488347983000},{"_id":"themes/spff/source/css/pace/pace-theme-flash.css","hash":"508bce8b59a1fbc1f1443a7c4ab3b026e5517dab","modified":1488347983000},{"_id":"themes/spff/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1488347983000},{"_id":"themes/spff/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1488347983000},{"_id":"themes/spff/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1488347983000},{"_id":"themes/spff/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1488347983000},{"_id":"themes/spff/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1488347983000},{"_id":"themes/spff/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1488347983000},{"_id":"themes/spff/source/font-awesome/css/font-awesome.css","hash":"b488600451227b445414796e9b8550e7c1bd6d29","modified":1488347983000},{"_id":"themes/spff/source/font-awesome/css/font-awesome.min.css","hash":"12d6861075de8e293265ff6ff03b1f3adcb44c76","modified":1488347983000},{"_id":"themes/spff/source/js/404/jquery.parallaxify-0.0.2.min.js","hash":"b97e2dfcb210b76f7bdd6e1800b26128bf4fad99","modified":1488347983000},{"_id":"themes/spff/source/background/bg-15.jpg","hash":"ce5760578eb814fe951c56200e81c6f47b6468d4","modified":1488347983000},{"_id":"themes/spff/source/background/bg-23.jpg","hash":"050937d649be2c02ef8a66a0ffe7d320b236d1b0","modified":1488347983000},{"_id":"themes/spff/source/background/bg-7.jpg","hash":"acbe0946a47ba16b79f062dbee14c4c9ff9a48da","modified":1488347983000},{"_id":"themes/spff/source/font-awesome/fonts/FontAwesome.otf","hash":"42c179eef588854b5ec151bcf6a3f58aa8b79b11","modified":1488347983000},{"_id":"themes/spff/source/font-awesome/fonts/fontawesome-webfont.woff2","hash":"638c652d623280a58144f93e7b552c66d1667a11","modified":1488347983000},{"_id":"themes/spff/source/font-awesome/fonts/fontawesome-webfont.eot","hash":"986eed8dca049714e43eeebcb3932741a4bec76d","modified":1488347983000},{"_id":"themes/spff/source/font-awesome/fonts/fontawesome-webfont.woff","hash":"4a313eb93b959cc4154c684b915b0a31ddb68d84","modified":1488347983000},{"_id":"themes/spff/source/js/404/jquery-2.0.3.min.js","hash":"fbf9c77d0c4e3c34a485980c1e5316b6212160c8","modified":1488347983000},{"_id":"themes/spff/source/background/bg-14.jpg","hash":"2fd6ede2bc9de2d26d910ea4e45d28b2350881eb","modified":1488347983000},{"_id":"themes/spff/source/background/bg-9.jpg","hash":"df731da0fe0de9a05d99d017e747252c990f972d","modified":1488347983000},{"_id":"themes/spff/source/css/_partial/customise/blockquote.styl","hash":"83179f1d0e12b025cd433a6071b2826c2b4168cc","modified":1488347983000},{"_id":"themes/spff/source/css/_partial/customise/code-block.styl","hash":"ebf7ca8598d93235479460ea7d1be97d44224b05","modified":1488347983000},{"_id":"themes/spff/source/css/_partial/customise/inline-code.styl","hash":"1f15986381f7b7b0953ba30733e473b12ea46800","modified":1488347983000},{"_id":"themes/spff/source/css/_partial/post/youyan.styl","hash":"ac2869e2e0fb3a1ee0df4b0c0a233a2b1923ea20","modified":1488347983000},{"_id":"themes/spff/source/font-awesome/fonts/fontawesome-webfont.ttf","hash":"6484f1af6b485d5096b71b344e67f4164c33dd1f","modified":1488347983000},{"_id":"themes/spff/source/background/bg-19.jpg","hash":"d77504412d28432643fc61ed9fd9f7c57096bdd9","modified":1488347983000},{"_id":"themes/spff/source/background/bg-24.jpg","hash":"796fa5262d7714e8ce9496a2d03864429cfc5b45","modified":1488347983000},{"_id":"themes/spff/source/background/bg-8.jpg","hash":"dbecc189e28d00fa23e397eb512e039c2ff03c87","modified":1488347983000},{"_id":"themes/spff/source/background/bg-21.jpg","hash":"7c4c6cd5d75115093fa29bba7372fa198f04b0f1","modified":1488347983000},{"_id":"themes/spff/source/background/bg-22.jpg","hash":"7a055391fa4188d9c22fdc1d34a10b26e2f0826d","modified":1488347983000},{"_id":"themes/spff/source/background/bg-4.jpg","hash":"da47f889e02241c8b095f852fb7efd89c114599d","modified":1488347983000},{"_id":"themes/spff/source/background/bg-6.jpg","hash":"1a4f4c8875b2c56e7992000979a7fca7856eec35","modified":1488347983000},{"_id":"themes/spff/source/background/bg-10.jpg","hash":"dfb23c1c3cf8a3dcb8dc0ea10cf06501c151a2a2","modified":1488347983000},{"_id":"themes/spff/source/background/bg-12.jpg","hash":"2e0815591309863d8130881681cde32ec4bfebf1","modified":1488347983000},{"_id":"themes/spff/source/background/bg-18.jpg","hash":"4d61dc41a781a9c1d37c9e5e413ac0d8a9538f6a","modified":1488347983000},{"_id":"themes/spff/source/img/bg.jpg","hash":"1bcba3c6348e2190a42bff762800bf846cf9239c","modified":1488347983000},{"_id":"themes/spff/source/background/bg-111.jpg","hash":"e1631b47fede8da6c03582ceed648668547c4f09","modified":1488347983000},{"_id":"themes/spff/source/background/bg-16.jpg","hash":"d1a34d0c4b69262169b543922e4aeb4dae997ad8","modified":1488347983000},{"_id":"themes/spff/source/background/bg-13.jpg","hash":"d7237c6014e28c90f53287f48f718d0759af104b","modified":1488347983000},{"_id":"themes/spff/source/font-awesome/fonts/fontawesome-webfont.svg","hash":"b06b5c8f67fd632cdc62a33b62ae4f74194131b3","modified":1488347983000},{"_id":"themes/spff/source/background/bg-2.jpg","hash":"40a6db13e9c461f80e2c4efee7fb63bbd594e751","modified":1488347983000},{"_id":"themes/spff/source/background/bg-5.jpg","hash":"2d5da2a209732cce0abf2ca234c0bef0516b65ff","modified":1488347983000},{"_id":"public/Home/index.html","hash":"25533af2b7bb58de078c5be29cae6795254ecde8","modified":1488349074255},{"_id":"public/about/index-1.html","hash":"63d51f60b05d54802d10f49b3e306eb576892bb4","modified":1488349074275},{"_id":"public/about/index.html","hash":"fbaec599a3a48f28973e80f9b112065f2661fd30","modified":1488349074295},{"_id":"public/categories/index.html","hash":"39499913b3317f971ce2ad09e5bd21b50a5908af","modified":1488349074320},{"_id":"public/2017/02/28/Glances/index.html","hash":"c3baa718985fe743c6bcfe955efdde80a9f0d317","modified":1488349074356},{"_id":"public/2017/01/08/tsung说明文档/index.html","hash":"ac86c116bc4aef2277748921e2162fc97e31bfb1","modified":1488349074394},{"_id":"public/2016/11/05/yum仓库搭建之RPM包制作/index.html","hash":"b8f6a3a5c0374bffe75dcdedc2d07dad708a418c","modified":1488349074408},{"_id":"public/2016/11/03/linux traceroute 命令详解/index.html","hash":"7a9c24b5d52bce629815c4e81e0861c8347ab2fa","modified":1488349074425},{"_id":"public/2016/11/03/mtr命令详解/index.html","hash":"26fb3b7e787783fca949925f99c1046755614773","modified":1488349074439},{"_id":"public/2016/11/03/tcpdump抓包命令详解/index.html","hash":"eefece62bf2e8aebf25835d20128ad653e6dc899","modified":1488349074457},{"_id":"public/2016/10/05/linux_命令rsync+crontab实现自动同步/index.html","hash":"f68674082d39b1cba265c8ee5e517a422ff5c8f0","modified":1488349074476},{"_id":"public/2016/09/06/htop使用说明/index.html","hash":"e6f4029b36f407ae20dc1c0b7d474bfb8bc7bd26","modified":1488349074494},{"_id":"public/2016/09/05/mysql主从配置文件内容/index.html","hash":"614cdd6ee877eecfafedc4010d2d32860295439e","modified":1488349074505},{"_id":"public/2016/09/02/keepalive+nginx实现高可用/index.html","hash":"91952df73429a3a992176bd4d4878486edbf7729","modified":1488349074532},{"_id":"public/2016/09/02/hexo/index.html","hash":"84b6ced453562afe1bfb3460fc812bb88165bd2b","modified":1488349074552},{"_id":"public/2016/09/02/搭建WordPress/index.html","hash":"abff0b12c40c883d0251fb8f39601dd4c36f05b0","modified":1488349074576},{"_id":"public/2016/09/02/linux—SSH1/index.html","hash":"81b94646415145411286099773a7be66b787cf55","modified":1488349074618},{"_id":"public/2016/09/02/git/index.html","hash":"29d7da19390ae1ab3dae9bb1a00a63768c6deead","modified":1488349074630},{"_id":"public/2016/09/02/zabbix2.6安装/index.html","hash":"2a5599f90d41a506917e1e9f6536e6f1f43513b6","modified":1488349074643},{"_id":"public/2016/09/02/linux—SSH（二）Rsync备份/index.html","hash":"658058870338a5349aa006c5ddb9be6717bfc541","modified":1488349074660},{"_id":"public/archives/index.html","hash":"407d0a6fd109727006e6a1a5cbe55765e3f4500b","modified":1488349074694},{"_id":"public/archives/page/2/index.html","hash":"11bcfb80862285dc35420bf0ce15ef8fd0302f9f","modified":1488349074716},{"_id":"public/archives/2016/index.html","hash":"d6cdb0313fcbe4efca5eafd3427e9bb21bb85597","modified":1488349074767},{"_id":"public/archives/2016/page/2/index.html","hash":"2ec79d208b5b3f3c621c5eeed29a794760471d79","modified":1488349074794},{"_id":"public/archives/2016/09/index.html","hash":"0d49eb495783557110aeb2fcdca98d9548ba767d","modified":1488349074838},{"_id":"public/archives/2016/10/index.html","hash":"ef5c4cf01f6521d9305c66fe0b8cad863de66ced","modified":1488349074847},{"_id":"public/archives/2016/11/index.html","hash":"d8060f0a0cde6e4a7af91cf14c3df106a140f2a0","modified":1488349074865},{"_id":"public/archives/2017/index.html","hash":"45295db2d5bd158bf8c6742ea4e93135bac363d0","modified":1488349074878},{"_id":"public/archives/2017/01/index.html","hash":"e2f0bd16f86bb89ceec32ffe58ddf4992c26ebd6","modified":1488349074886},{"_id":"public/archives/2017/02/index.html","hash":"79e8feaf010ca9ceb7e7cb17a0ca4a71a73326af","modified":1488349074896},{"_id":"public/index.html","hash":"cf4a2db37005df22f3296455a006c9faa51e2627","modified":1488349074951},{"_id":"public/page/2/index.html","hash":"d8c8c0b5de8cdd9ad435bc51552b911c036d973d","modified":1488349075002},{"_id":"public/apple-touch-icon.png","hash":"c36a373c7830d61d1ce092bd5a88d0e9b54212fd","modified":1488349075019},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1488349075019},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1488349075019},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1488349075020},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1488349075020},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1488349075020},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1488349075021},{"_id":"public/img/coderwall.png","hash":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1488349075021},{"_id":"public/img/delicious.png","hash":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1488349075021},{"_id":"public/img/douban.png","hash":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1488349075021},{"_id":"public/img/facebook.png","hash":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1488349075021},{"_id":"public/img/favicon.png","hash":"5b4e9c94ff3396db5b074b69c1aa5bb909aba825","modified":1488349075022},{"_id":"public/img/github.png","hash":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1488349075022},{"_id":"public/img/google.png","hash":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1488349075022},{"_id":"public/img/head.jpg","hash":"f96ad10fc77afd93821e72ac7fc3783e115cac42","modified":1488349075022},{"_id":"public/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1488349075022},{"_id":"public/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1488349075022},{"_id":"public/img/linkedin.png","hash":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1488349075022},{"_id":"public/img/mail.png","hash":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1488349075022},{"_id":"public/img/pinboard.png","hash":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1488349075022},{"_id":"public/img/pinterest.png","hash":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1488349075022},{"_id":"public/img/qq.png","hash":"fd741764c5528fe371f053beac99839a97900eef","modified":1488349075023},{"_id":"public/img/rss.png","hash":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1488349075023},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1488349075024},{"_id":"public/img/stackoverflow.png","hash":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1488349075024},{"_id":"public/img/twitter.png","hash":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1488349075024},{"_id":"public/img/wechat.png","hash":"7ca41b6e32ca4dac419225261ab4fee5a88f73a9","modified":1488349075024},{"_id":"public/img/weibo.png","hash":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1488349075024},{"_id":"public/img/zhihu.png","hash":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1488349075025},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1488349075026},{"_id":"public/css/loading-style.css","hash":"1f67362d809e85edc9f122db7bc3711af1ed1d8b","modified":1488349075032},{"_id":"public/css/showshare.css","hash":"3efc4afd0d136fb5dec993e9cd9ce85b9d1cf589","modified":1488349075032},{"_id":"public/css/style.css","hash":"a974d07a251a2da6ca5a943cb76840df99e2a81a","modified":1488349075914},{"_id":"public/fancybox/jquery.fancybox.css","hash":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20","modified":1488349075915},{"_id":"public/fancybox/jquery.fancybox.js","hash":"a82597493d75ea989ca586e09173cff332efe41e","modified":1488349075916},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1488349075916},{"_id":"public/js/TweenMax.js","hash":"0ba64564a4fde4085fa3971dd53b7d64a41751e1","modified":1488349075917},{"_id":"public/js/clipboard.min.js","hash":"c13b4bb8fee46447284590d2afc0efca0ea3cb7b","modified":1488349075918},{"_id":"public/js/instagram.js","hash":"f19adbcc0dac33536bc6660598059048ec901882","modified":1488349075918},{"_id":"public/js/jquery.lazyload.js","hash":"c11a2e7b330d16d06feabd0a8477099adf9d6799","modified":1488349075918},{"_id":"public/js/main.js","hash":"153b4796d6c22f3bfaa28a4f8a361d4685286c6f","modified":1488349075918},{"_id":"public/js/mobile.js","hash":"d3847e5bcaf39108931724ecb02770c62b10889f","modified":1488349075918},{"_id":"public/js/pace.js","hash":"b49c10cd65d9488f7338e3c778e55ac6628650f3","modified":1488349075919},{"_id":"public/js/pc.js","hash":"ab375af6e3bcd054b1e87e1a8dcd3d7d25c2db40","modified":1488349075919},{"_id":"public/js/plugins.js","hash":"c1cf96b2d852b5803228a34d99014b005623bc06","modified":1488349075919},{"_id":"public/img/head1.jpg","hash":"80c0999acfc1173183d3dd243b4b90d077ab97cb","modified":1488349075919},{"_id":"public/js/TweenMax.min.js","hash":"eaa4e4a08400da3f22dedda706ba56cdce5b0b7a","modified":1488349075920},{"_id":"public/js/embed.js","hash":"8d2d4a812ab639bc02fdd8749d3a39f6b9406c54","modified":1488349075922},{"_id":"public/css/pace/pace-theme-flash.css","hash":"508bce8b59a1fbc1f1443a7c4ab3b026e5517dab","modified":1488349075923},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1488349075923},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1488349075924},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1488349075924},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1488349075924},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1488349075924},{"_id":"public/font-awesome/css/font-awesome.css","hash":"b488600451227b445414796e9b8550e7c1bd6d29","modified":1488349075926},{"_id":"public/font-awesome/css/font-awesome.min.css","hash":"12d6861075de8e293265ff6ff03b1f3adcb44c76","modified":1488349075926},{"_id":"public/js/404/jquery.parallaxify-0.0.2.min.js","hash":"b97e2dfcb210b76f7bdd6e1800b26128bf4fad99","modified":1488349075926},{"_id":"public/font-awesome/fonts/FontAwesome.otf","hash":"42c179eef588854b5ec151bcf6a3f58aa8b79b11","modified":1488349075927},{"_id":"public/font-awesome/fonts/fontawesome-webfont.woff2","hash":"638c652d623280a58144f93e7b552c66d1667a11","modified":1488349075927},{"_id":"public/font-awesome/fonts/fontawesome-webfont.eot","hash":"986eed8dca049714e43eeebcb3932741a4bec76d","modified":1488349075927},{"_id":"public/font-awesome/fonts/fontawesome-webfont.woff","hash":"4a313eb93b959cc4154c684b915b0a31ddb68d84","modified":1488349075927},{"_id":"public/js/404/jquery-2.0.3.min.js","hash":"fbf9c77d0c4e3c34a485980c1e5316b6212160c8","modified":1488349075928},{"_id":"public/background/bg-1.jpg","hash":"f0617756387d74f99afe0087c7b93a32f3c7096b","modified":1488349075934},{"_id":"public/background/bg-109.jpg","hash":"6171c1e921c8cc9bdcd7276cf7f0bee5295f4672","modified":1488349075936},{"_id":"public/background/bg-11.jpg","hash":"d69a0447e91f62977b144737f08620d77037c76a","modified":1488349075937},{"_id":"public/background/bg-17.jpg","hash":"6ab5e470059e8ccb0c8bc6786abfb5db7e9a1826","modified":1488349075937},{"_id":"public/background/bg-20.jpg","hash":"9d428ac435198b2a0107102a2e9ae71e53afe364","modified":1488349075937},{"_id":"public/background/bg-3.jpg","hash":"f1347eddd07bdae93ab6bebad8627eddc5baeb44","modified":1488349075937},{"_id":"public/background/bg.jpg","hash":"f0617756387d74f99afe0087c7b93a32f3c7096b","modified":1488349075937},{"_id":"public/font-awesome/fonts/fontawesome-webfont.ttf","hash":"6484f1af6b485d5096b71b344e67f4164c33dd1f","modified":1488349075939},{"_id":"public/background/bg-15.jpg","hash":"ce5760578eb814fe951c56200e81c6f47b6468d4","modified":1488349075942},{"_id":"public/background/bg-7.jpg","hash":"acbe0946a47ba16b79f062dbee14c4c9ff9a48da","modified":1488349075942},{"_id":"public/background/bg-23.jpg","hash":"050937d649be2c02ef8a66a0ffe7d320b236d1b0","modified":1488349075943},{"_id":"public/background/bg-14.jpg","hash":"2fd6ede2bc9de2d26d910ea4e45d28b2350881eb","modified":1488349075954},{"_id":"public/background/bg-9.jpg","hash":"df731da0fe0de9a05d99d017e747252c990f972d","modified":1488349075954},{"_id":"public/background/bg-19.jpg","hash":"d77504412d28432643fc61ed9fd9f7c57096bdd9","modified":1488349075959},{"_id":"public/background/bg-24.jpg","hash":"796fa5262d7714e8ce9496a2d03864429cfc5b45","modified":1488349075959},{"_id":"public/background/bg-8.jpg","hash":"dbecc189e28d00fa23e397eb512e039c2ff03c87","modified":1488349075959},{"_id":"public/background/bg-21.jpg","hash":"7c4c6cd5d75115093fa29bba7372fa198f04b0f1","modified":1488349075960},{"_id":"public/background/bg-22.jpg","hash":"7a055391fa4188d9c22fdc1d34a10b26e2f0826d","modified":1488349075960},{"_id":"public/background/bg-4.jpg","hash":"da47f889e02241c8b095f852fb7efd89c114599d","modified":1488349075960},{"_id":"public/background/bg-6.jpg","hash":"1a4f4c8875b2c56e7992000979a7fca7856eec35","modified":1488349075961},{"_id":"public/font-awesome/fonts/fontawesome-webfont.svg","hash":"b06b5c8f67fd632cdc62a33b62ae4f74194131b3","modified":1488349075962},{"_id":"public/background/bg-12.jpg","hash":"2e0815591309863d8130881681cde32ec4bfebf1","modified":1488349075965},{"_id":"public/background/bg-10.jpg","hash":"dfb23c1c3cf8a3dcb8dc0ea10cf06501c151a2a2","modified":1488349075965},{"_id":"public/background/bg-18.jpg","hash":"4d61dc41a781a9c1d37c9e5e413ac0d8a9538f6a","modified":1488349075965},{"_id":"public/img/bg.jpg","hash":"1bcba3c6348e2190a42bff762800bf846cf9239c","modified":1488349075966},{"_id":"public/background/bg-111.jpg","hash":"e1631b47fede8da6c03582ceed648668547c4f09","modified":1488349076005},{"_id":"public/background/bg-13.jpg","hash":"d7237c6014e28c90f53287f48f718d0759af104b","modified":1488349076005},{"_id":"public/background/bg-16.jpg","hash":"d1a34d0c4b69262169b543922e4aeb4dae997ad8","modified":1488349076006},{"_id":"public/background/bg-2.jpg","hash":"40a6db13e9c461f80e2c4efee7fb63bbd594e751","modified":1488349076008},{"_id":"public/background/bg-5.jpg","hash":"2d5da2a209732cce0abf2ca234c0bef0516b65ff","modified":1488349076010}],"Category":[],"Data":[],"Page":[{"title":"Home","date":"2016-09-02T00:58:44.000Z","_content":"","source":"Home/index.md","raw":"---\ntitle: Home\ndate: 2016-09-01 20:58:44\n---\n","updated":"2017-03-01T05:59:43.000Z","path":"Home/index.html","comments":1,"layout":"page","_id":"cizqklz760000lbpvm99hx6je","content":"","excerpt":"","more":""},{"title":"about","date":"2016-09-02T01:16:45.000Z","_content":"","source":"about/index-1.md","raw":"---\ntitle: about\ndate: 2016-09-01 21:16:45\n---\n","updated":"2017-03-01T05:59:43.000Z","path":"about/index-1.html","comments":1,"layout":"page","_id":"cizqklz85000hlbpvwt2xqrgx","content":"","excerpt":"","more":""},{"title":"about","date":"2016-09-02T01:01:30.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-09-01 21:01:30\n---\n","updated":"2017-03-01T05:59:43.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cizqklz86000ilbpvrubc0lyq","content":"","excerpt":"","more":""},{"title":"categories","date":"2016-07-29T22:38:02.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-07-29 18:38:02\n---\n","updated":"2017-03-01T05:59:43.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cizqklz86000jlbpvnx8pa7eo","content":"","excerpt":"","more":""}],"Post":[{"title":"Glances","date":"2017-02-28T05:00:00.000Z","_content":"top 命令是 Linux 下的一个实时任务管理器， 同时也是用于在 GNU/Linux 发行版中寻找系统性能方面的瓶颈，并帮助我们作出正确操作的常用系统监视工具。 她有着一个极为简洁的界面，并自带少量的可以帮助我们快速了解系统性能的实用选项。\n<!--more-->\n但是，有些时候想要通过她寻找一个占用系统资源比较大的应用或进程可能会比较困难。 因为 top 命令本身并不会帮助我们高亮那些吃太多 CPU，内存，或者其他资源的程序。\n\n为了达到这个目标，这里我们将介绍一款超牛逼的系统监视程序 —— Glances。 她可以自动高亮利用最高系统资源的程序，并为 Linux/Unix 服务器提供尽可能多的信息。\n\n什么是 Glances？\nGlances 是一个由 Python 编写，使用 psutil 库来从系统抓取信息的基于 curses 开发的跨平台命令行系统监视工具。 通过 Glances，我们可以监视 CPU，平均负载，内存，网络流量，磁盘 I/O，其他处理器 和 文件系统 空间的利用情况。\n\nGlances 是一个用来监视 GNU/Linux 和 FreeBSD 操作系统的 GPL 授权的自由软件。\n\nGlances 同时也提供了很多实用的选项。 其中我们能够在配置文件见到的一项主要的功能就是设置关键值及相应的标签 （careful[小心], warning[警告] 和 critical[严重]）， 然后她会自动帮我们用不同颜色标出系统达到某个瓶颈的信息。\n\nGlances 主要功能\nCPU 信息 （用户的相关应用, 系统核心程序和空闲程序）\n总内存信息，包括了物理内存，交换空间和空闲内存等等\n之前的 1 分钟、5 分钟和 15 分钟平均的 CPU 负载\n网络链接的下行和上行速度\n处理器总数，以及其活动状态\n硬盘 I/O 相关（读写）速度详情\n当前挂载设备的磁盘使用情况\n高 CPU 和内存使用的进程名，和相关应用的位置\n在底部显示当前日期和时间\n将消耗最高系统资源的进程用红色标出\n下面是一个 Glances 的使用截图：\n![](https://dn-linuxcn.qbox.me/data/attachment/album/201403/31/214404gen07qvynyj3vjzn.jpeg)\n在 Linux/Unix 系统中安装 Glances\n虽然这个工具的发布比较晚，但你仍然可以在 Red Hat 系的系统中通过 EPEL 软件源安装。在终端用下面的命令安装：\n\n对于 RHEL/CentOS/Fedora 发行版  \n    # yum install -y glances  \n对于 Debian/Ubuntu/Linux Mint 发行版  \n    $ sudo apt-add-repository ppa:arnaud-hartmann/glances-stable    \n    $ sudo apt-get update  \n    $ sudo apt-get install glances  \n如何使用 Glances\n首先，你需要在终端中输入以下命令  \n    \n    # glances  \n![](https://dn-linuxcn.qbox.me/data/attachment/album/201403/31/214413hgrs2ozqwarrwypo.jpeg)\n\n按下 ‘q‘ （‘ESC‘ 和 ‘Ctrl-C‘ 也可以） 退出 Glances 终端。 这里是从 CentOS 6.5 截取的另一张截图：\n![](https://dn-linuxcn.qbox.me/data/attachment/album/201403/31/214419xaiwmtwwaawo2oya.jpeg)\nGlances 的默认刷新频率是 1 （秒），但是你可以通过在终端指定参数来手动定义其刷新频率  \n    # glances -t 2   \nGlances 中颜色的含义\nGlances 会用一下几种颜色来代表状态：\n\n绿色：OK（一切正常）\n蓝色：CAREFUL（需要注意）\n紫色：WARNING（警告）\n红色：CRITICAL（严重）\n阀值可以在配置文件中设置，一般阀值被默认设置为（careful=50、warning=70、critical=90）。\n\n我们可以按照自己的需求在配置文件（默认在 /etc/glances/glances.conf）中自定义。\n\nGlances 的选项\n除了很多命令行选项之外，Glances 还提供了更多的可在其运行时开关输出信息选项的快捷键，下面是一些例子：\n\na – 对进程自动排序  \nc – 按 CPU 百分比对进程排序   \nm – 按内存百分比对进程排序  \np – 按进程名字母顺序对进程排序  \ni – 按读写频率（I/O）对进程排序  \nd – 显示/隐藏磁盘 I/O 统计信息  \nf – 显示/隐藏文件系统统计信息  \nn – 显示/隐藏网络接口统计信息  \ns – 显示/隐藏传感器统计信息  \ny – 显示/隐藏硬盘温度统计信息  \nl – 显示/隐藏日志（log）  \nb – 切换网络 I/O 单位（Bytes/bits）  \nw – 删除警告日志   \nx – 删除警告和严重日志  \n1 – 切换全局 CPU 使用情况和每个 CPU 的使用情况  \nh – 显示/隐藏这个帮助画面  \nt – 以组合形式浏览网络 I/O  \nu – 以累计形式浏览网络 I/O  \nq – 退出（‘ESC‘ 和 ‘Ctrl&C‘ 也可以）  \n远程使用 Glances  \n你甚至也可以通过 Glances 来监视远程系统。 要在远程系统使用 ‘glances’，需要在服务器运行 ‘glances -s’（-s 启动服务器/客户端模式）命令。  \n    # glances -s\n \nDefine the password for the Glances server\nPassword: \nPassword (confirm): \nGlances server is running on 0.0.0.0:61209  \n注意：当你执行了‘glances’命令后，她会让你为 Glances 服务器设置密码。\n\n当你设置完毕，你将看到 “Glances server is running on 0.0.0.0:61209” （Glances 服务器正在 0.0.0.0 的 61209 端口运行）的消息。\n\n当 Glances 服务器启动后，到本地执行下面的命令来指定服务器IP地址或主机名以链接。\n\n注：这里的 ‘172.16.27.56’ 是我 Glances 服务器的 IP 地址。  \n    # glances -c -P 172.16.27.56    \n  下面是一些在使用服务器/客户端模式时必须知道的事情：  \n* 在服务器模式，你可以通过 `-B 地址` 来设置绑定地址，也可以通过 `-p 端口` 来绑定监听的 TCP 端口  \n* 在客户端模式，你可以通过同样的 `-p 端口` 来指定服务器端口  \n* 默认的绑定地址是 0.0.0.0，但这么做会监听所有网络接口的指定端口  \n* 在服务器/客户端模式下，限制的阀值将由服务器的设置决定  \n* 你也可以在命令行下用过 `-P 密码` 的方式来为服务器端设置一个密码  \n总结  \nGlances 对于大多用户而言是个在系统资源上提供过多信息的工具。但是如果你是一个想要仅从命令行就能快速获取系统整体状况的系统管理员，那这个工具绝对是你的必备利器。  \n请不要将 glances（本文中的工具）和 glance（一个 OpenStack 的工具）这两个包搞混了  \nUbuntu 官方 Extra 源中的 glances 因为 python 库移动的问题导致无法正常使用 但可以通过建立软链接的方式临时修复：sudo ln -s /usr/lib/python2.7/dist-packages/glances /usr/share/pyshared/glances","source":"_posts/Glances.md","raw":"---\ntitle: Glances\ndate: 2017-02-28\ntags:\n---\ntop 命令是 Linux 下的一个实时任务管理器， 同时也是用于在 GNU/Linux 发行版中寻找系统性能方面的瓶颈，并帮助我们作出正确操作的常用系统监视工具。 她有着一个极为简洁的界面，并自带少量的可以帮助我们快速了解系统性能的实用选项。\n<!--more-->\n但是，有些时候想要通过她寻找一个占用系统资源比较大的应用或进程可能会比较困难。 因为 top 命令本身并不会帮助我们高亮那些吃太多 CPU，内存，或者其他资源的程序。\n\n为了达到这个目标，这里我们将介绍一款超牛逼的系统监视程序 —— Glances。 她可以自动高亮利用最高系统资源的程序，并为 Linux/Unix 服务器提供尽可能多的信息。\n\n什么是 Glances？\nGlances 是一个由 Python 编写，使用 psutil 库来从系统抓取信息的基于 curses 开发的跨平台命令行系统监视工具。 通过 Glances，我们可以监视 CPU，平均负载，内存，网络流量，磁盘 I/O，其他处理器 和 文件系统 空间的利用情况。\n\nGlances 是一个用来监视 GNU/Linux 和 FreeBSD 操作系统的 GPL 授权的自由软件。\n\nGlances 同时也提供了很多实用的选项。 其中我们能够在配置文件见到的一项主要的功能就是设置关键值及相应的标签 （careful[小心], warning[警告] 和 critical[严重]）， 然后她会自动帮我们用不同颜色标出系统达到某个瓶颈的信息。\n\nGlances 主要功能\nCPU 信息 （用户的相关应用, 系统核心程序和空闲程序）\n总内存信息，包括了物理内存，交换空间和空闲内存等等\n之前的 1 分钟、5 分钟和 15 分钟平均的 CPU 负载\n网络链接的下行和上行速度\n处理器总数，以及其活动状态\n硬盘 I/O 相关（读写）速度详情\n当前挂载设备的磁盘使用情况\n高 CPU 和内存使用的进程名，和相关应用的位置\n在底部显示当前日期和时间\n将消耗最高系统资源的进程用红色标出\n下面是一个 Glances 的使用截图：\n![](https://dn-linuxcn.qbox.me/data/attachment/album/201403/31/214404gen07qvynyj3vjzn.jpeg)\n在 Linux/Unix 系统中安装 Glances\n虽然这个工具的发布比较晚，但你仍然可以在 Red Hat 系的系统中通过 EPEL 软件源安装。在终端用下面的命令安装：\n\n对于 RHEL/CentOS/Fedora 发行版  \n    # yum install -y glances  \n对于 Debian/Ubuntu/Linux Mint 发行版  \n    $ sudo apt-add-repository ppa:arnaud-hartmann/glances-stable    \n    $ sudo apt-get update  \n    $ sudo apt-get install glances  \n如何使用 Glances\n首先，你需要在终端中输入以下命令  \n    \n    # glances  \n![](https://dn-linuxcn.qbox.me/data/attachment/album/201403/31/214413hgrs2ozqwarrwypo.jpeg)\n\n按下 ‘q‘ （‘ESC‘ 和 ‘Ctrl-C‘ 也可以） 退出 Glances 终端。 这里是从 CentOS 6.5 截取的另一张截图：\n![](https://dn-linuxcn.qbox.me/data/attachment/album/201403/31/214419xaiwmtwwaawo2oya.jpeg)\nGlances 的默认刷新频率是 1 （秒），但是你可以通过在终端指定参数来手动定义其刷新频率  \n    # glances -t 2   \nGlances 中颜色的含义\nGlances 会用一下几种颜色来代表状态：\n\n绿色：OK（一切正常）\n蓝色：CAREFUL（需要注意）\n紫色：WARNING（警告）\n红色：CRITICAL（严重）\n阀值可以在配置文件中设置，一般阀值被默认设置为（careful=50、warning=70、critical=90）。\n\n我们可以按照自己的需求在配置文件（默认在 /etc/glances/glances.conf）中自定义。\n\nGlances 的选项\n除了很多命令行选项之外，Glances 还提供了更多的可在其运行时开关输出信息选项的快捷键，下面是一些例子：\n\na – 对进程自动排序  \nc – 按 CPU 百分比对进程排序   \nm – 按内存百分比对进程排序  \np – 按进程名字母顺序对进程排序  \ni – 按读写频率（I/O）对进程排序  \nd – 显示/隐藏磁盘 I/O 统计信息  \nf – 显示/隐藏文件系统统计信息  \nn – 显示/隐藏网络接口统计信息  \ns – 显示/隐藏传感器统计信息  \ny – 显示/隐藏硬盘温度统计信息  \nl – 显示/隐藏日志（log）  \nb – 切换网络 I/O 单位（Bytes/bits）  \nw – 删除警告日志   \nx – 删除警告和严重日志  \n1 – 切换全局 CPU 使用情况和每个 CPU 的使用情况  \nh – 显示/隐藏这个帮助画面  \nt – 以组合形式浏览网络 I/O  \nu – 以累计形式浏览网络 I/O  \nq – 退出（‘ESC‘ 和 ‘Ctrl&C‘ 也可以）  \n远程使用 Glances  \n你甚至也可以通过 Glances 来监视远程系统。 要在远程系统使用 ‘glances’，需要在服务器运行 ‘glances -s’（-s 启动服务器/客户端模式）命令。  \n    # glances -s\n \nDefine the password for the Glances server\nPassword: \nPassword (confirm): \nGlances server is running on 0.0.0.0:61209  \n注意：当你执行了‘glances’命令后，她会让你为 Glances 服务器设置密码。\n\n当你设置完毕，你将看到 “Glances server is running on 0.0.0.0:61209” （Glances 服务器正在 0.0.0.0 的 61209 端口运行）的消息。\n\n当 Glances 服务器启动后，到本地执行下面的命令来指定服务器IP地址或主机名以链接。\n\n注：这里的 ‘172.16.27.56’ 是我 Glances 服务器的 IP 地址。  \n    # glances -c -P 172.16.27.56    \n  下面是一些在使用服务器/客户端模式时必须知道的事情：  \n* 在服务器模式，你可以通过 `-B 地址` 来设置绑定地址，也可以通过 `-p 端口` 来绑定监听的 TCP 端口  \n* 在客户端模式，你可以通过同样的 `-p 端口` 来指定服务器端口  \n* 默认的绑定地址是 0.0.0.0，但这么做会监听所有网络接口的指定端口  \n* 在服务器/客户端模式下，限制的阀值将由服务器的设置决定  \n* 你也可以在命令行下用过 `-P 密码` 的方式来为服务器端设置一个密码  \n总结  \nGlances 对于大多用户而言是个在系统资源上提供过多信息的工具。但是如果你是一个想要仅从命令行就能快速获取系统整体状况的系统管理员，那这个工具绝对是你的必备利器。  \n请不要将 glances（本文中的工具）和 glance（一个 OpenStack 的工具）这两个包搞混了  \nUbuntu 官方 Extra 源中的 glances 因为 python 库移动的问题导致无法正常使用 但可以通过建立软链接的方式临时修复：sudo ln -s /usr/lib/python2.7/dist-packages/glances /usr/share/pyshared/glances","slug":"Glances","published":1,"updated":"2017-03-01T05:59:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizqklz7a0001lbpvxv8p4xgk","content":"<p>top 命令是 Linux 下的一个实时任务管理器， 同时也是用于在 GNU/Linux 发行版中寻找系统性能方面的瓶颈，并帮助我们作出正确操作的常用系统监视工具。 她有着一个极为简洁的界面，并自带少量的可以帮助我们快速了解系统性能的实用选项。<br><a id=\"more\"></a><br>但是，有些时候想要通过她寻找一个占用系统资源比较大的应用或进程可能会比较困难。 因为 top 命令本身并不会帮助我们高亮那些吃太多 CPU，内存，或者其他资源的程序。</p>\n<p>为了达到这个目标，这里我们将介绍一款超牛逼的系统监视程序 —— Glances。 她可以自动高亮利用最高系统资源的程序，并为 Linux/Unix 服务器提供尽可能多的信息。</p>\n<p>什么是 Glances？<br>Glances 是一个由 Python 编写，使用 psutil 库来从系统抓取信息的基于 curses 开发的跨平台命令行系统监视工具。 通过 Glances，我们可以监视 CPU，平均负载，内存，网络流量，磁盘 I/O，其他处理器 和 文件系统 空间的利用情况。</p>\n<p>Glances 是一个用来监视 GNU/Linux 和 FreeBSD 操作系统的 GPL 授权的自由软件。</p>\n<p>Glances 同时也提供了很多实用的选项。 其中我们能够在配置文件见到的一项主要的功能就是设置关键值及相应的标签 （careful[小心], warning[警告] 和 critical[严重]）， 然后她会自动帮我们用不同颜色标出系统达到某个瓶颈的信息。</p>\n<p>Glances 主要功能<br>CPU 信息 （用户的相关应用, 系统核心程序和空闲程序）<br>总内存信息，包括了物理内存，交换空间和空闲内存等等<br>之前的 1 分钟、5 分钟和 15 分钟平均的 CPU 负载<br>网络链接的下行和上行速度<br>处理器总数，以及其活动状态<br>硬盘 I/O 相关（读写）速度详情<br>当前挂载设备的磁盘使用情况<br>高 CPU 和内存使用的进程名，和相关应用的位置<br>在底部显示当前日期和时间<br>将消耗最高系统资源的进程用红色标出<br>下面是一个 Glances 的使用截图：<br><img src=\"https://dn-linuxcn.qbox.me/data/attachment/album/201403/31/214404gen07qvynyj3vjzn.jpeg\" alt=\"\"><br>在 Linux/Unix 系统中安装 Glances<br>虽然这个工具的发布比较晚，但你仍然可以在 Red Hat 系的系统中通过 EPEL 软件源安装。在终端用下面的命令安装：</p>\n<p>对于 RHEL/CentOS/Fedora 发行版  </p>\n<pre><code># yum install -y glances  \n</code></pre><p>对于 Debian/Ubuntu/Linux Mint 发行版<br>    $ sudo apt-add-repository ppa:arnaud-hartmann/glances-stable<br>    $ sudo apt-get update<br>    $ sudo apt-get install glances<br>如何使用 Glances<br>首先，你需要在终端中输入以下命令  </p>\n<pre><code># glances  \n</code></pre><p><img src=\"https://dn-linuxcn.qbox.me/data/attachment/album/201403/31/214413hgrs2ozqwarrwypo.jpeg\" alt=\"\"></p>\n<p>按下 ‘q‘ （‘ESC‘ 和 ‘Ctrl-C‘ 也可以） 退出 Glances 终端。 这里是从 CentOS 6.5 截取的另一张截图：<br><img src=\"https://dn-linuxcn.qbox.me/data/attachment/album/201403/31/214419xaiwmtwwaawo2oya.jpeg\" alt=\"\"><br>Glances 的默认刷新频率是 1 （秒），但是你可以通过在终端指定参数来手动定义其刷新频率  </p>\n<pre><code># glances -t 2   \n</code></pre><p>Glances 中颜色的含义<br>Glances 会用一下几种颜色来代表状态：</p>\n<p>绿色：OK（一切正常）<br>蓝色：CAREFUL（需要注意）<br>紫色：WARNING（警告）<br>红色：CRITICAL（严重）<br>阀值可以在配置文件中设置，一般阀值被默认设置为（careful=50、warning=70、critical=90）。</p>\n<p>我们可以按照自己的需求在配置文件（默认在 /etc/glances/glances.conf）中自定义。</p>\n<p>Glances 的选项<br>除了很多命令行选项之外，Glances 还提供了更多的可在其运行时开关输出信息选项的快捷键，下面是一些例子：</p>\n<p>a – 对进程自动排序<br>c – 按 CPU 百分比对进程排序<br>m – 按内存百分比对进程排序<br>p – 按进程名字母顺序对进程排序<br>i – 按读写频率（I/O）对进程排序<br>d – 显示/隐藏磁盘 I/O 统计信息<br>f – 显示/隐藏文件系统统计信息<br>n – 显示/隐藏网络接口统计信息<br>s – 显示/隐藏传感器统计信息<br>y – 显示/隐藏硬盘温度统计信息<br>l – 显示/隐藏日志（log）<br>b – 切换网络 I/O 单位（Bytes/bits）<br>w – 删除警告日志<br>x – 删除警告和严重日志<br>1 – 切换全局 CPU 使用情况和每个 CPU 的使用情况<br>h – 显示/隐藏这个帮助画面<br>t – 以组合形式浏览网络 I/O<br>u – 以累计形式浏览网络 I/O<br>q – 退出（‘ESC‘ 和 ‘Ctrl&amp;C‘ 也可以）<br>远程使用 Glances<br>你甚至也可以通过 Glances 来监视远程系统。 要在远程系统使用 ‘glances’，需要在服务器运行 ‘glances -s’（-s 启动服务器/客户端模式）命令。  </p>\n<pre><code># glances -s\n</code></pre><p>Define the password for the Glances server<br>Password:<br>Password (confirm):<br>Glances server is running on 0.0.0.0:61209<br>注意：当你执行了‘glances’命令后，她会让你为 Glances 服务器设置密码。</p>\n<p>当你设置完毕，你将看到 “Glances server is running on 0.0.0.0:61209” （Glances 服务器正在 0.0.0.0 的 61209 端口运行）的消息。</p>\n<p>当 Glances 服务器启动后，到本地执行下面的命令来指定服务器IP地址或主机名以链接。</p>\n<p>注：这里的 ‘172.16.27.56’ 是我 Glances 服务器的 IP 地址。  </p>\n<pre><code># glances -c -P 172.16.27.56    \n</code></pre><p>  下面是一些在使用服务器/客户端模式时必须知道的事情：  </p>\n<ul>\n<li>在服务器模式，你可以通过 <code>-B 地址</code> 来设置绑定地址，也可以通过 <code>-p 端口</code> 来绑定监听的 TCP 端口  </li>\n<li>在客户端模式，你可以通过同样的 <code>-p 端口</code> 来指定服务器端口  </li>\n<li>默认的绑定地址是 0.0.0.0，但这么做会监听所有网络接口的指定端口  </li>\n<li>在服务器/客户端模式下，限制的阀值将由服务器的设置决定  </li>\n<li>你也可以在命令行下用过 <code>-P 密码</code> 的方式来为服务器端设置一个密码<br>总结<br>Glances 对于大多用户而言是个在系统资源上提供过多信息的工具。但是如果你是一个想要仅从命令行就能快速获取系统整体状况的系统管理员，那这个工具绝对是你的必备利器。<br>请不要将 glances（本文中的工具）和 glance（一个 OpenStack 的工具）这两个包搞混了<br>Ubuntu 官方 Extra 源中的 glances 因为 python 库移动的问题导致无法正常使用 但可以通过建立软链接的方式临时修复：sudo ln -s /usr/lib/python2.7/dist-packages/glances /usr/share/pyshared/glances</li>\n</ul>\n","excerpt":"<p>top 命令是 Linux 下的一个实时任务管理器， 同时也是用于在 GNU/Linux 发行版中寻找系统性能方面的瓶颈，并帮助我们作出正确操作的常用系统监视工具。 她有着一个极为简洁的界面，并自带少量的可以帮助我们快速了解系统性能的实用选项。<br>","more":"<br>但是，有些时候想要通过她寻找一个占用系统资源比较大的应用或进程可能会比较困难。 因为 top 命令本身并不会帮助我们高亮那些吃太多 CPU，内存，或者其他资源的程序。</p>\n<p>为了达到这个目标，这里我们将介绍一款超牛逼的系统监视程序 —— Glances。 她可以自动高亮利用最高系统资源的程序，并为 Linux/Unix 服务器提供尽可能多的信息。</p>\n<p>什么是 Glances？<br>Glances 是一个由 Python 编写，使用 psutil 库来从系统抓取信息的基于 curses 开发的跨平台命令行系统监视工具。 通过 Glances，我们可以监视 CPU，平均负载，内存，网络流量，磁盘 I/O，其他处理器 和 文件系统 空间的利用情况。</p>\n<p>Glances 是一个用来监视 GNU/Linux 和 FreeBSD 操作系统的 GPL 授权的自由软件。</p>\n<p>Glances 同时也提供了很多实用的选项。 其中我们能够在配置文件见到的一项主要的功能就是设置关键值及相应的标签 （careful[小心], warning[警告] 和 critical[严重]）， 然后她会自动帮我们用不同颜色标出系统达到某个瓶颈的信息。</p>\n<p>Glances 主要功能<br>CPU 信息 （用户的相关应用, 系统核心程序和空闲程序）<br>总内存信息，包括了物理内存，交换空间和空闲内存等等<br>之前的 1 分钟、5 分钟和 15 分钟平均的 CPU 负载<br>网络链接的下行和上行速度<br>处理器总数，以及其活动状态<br>硬盘 I/O 相关（读写）速度详情<br>当前挂载设备的磁盘使用情况<br>高 CPU 和内存使用的进程名，和相关应用的位置<br>在底部显示当前日期和时间<br>将消耗最高系统资源的进程用红色标出<br>下面是一个 Glances 的使用截图：<br><img src=\"https://dn-linuxcn.qbox.me/data/attachment/album/201403/31/214404gen07qvynyj3vjzn.jpeg\" alt=\"\"><br>在 Linux/Unix 系统中安装 Glances<br>虽然这个工具的发布比较晚，但你仍然可以在 Red Hat 系的系统中通过 EPEL 软件源安装。在终端用下面的命令安装：</p>\n<p>对于 RHEL/CentOS/Fedora 发行版  </p>\n<pre><code># yum install -y glances  \n</code></pre><p>对于 Debian/Ubuntu/Linux Mint 发行版<br>    $ sudo apt-add-repository ppa:arnaud-hartmann/glances-stable<br>    $ sudo apt-get update<br>    $ sudo apt-get install glances<br>如何使用 Glances<br>首先，你需要在终端中输入以下命令  </p>\n<pre><code># glances  \n</code></pre><p><img src=\"https://dn-linuxcn.qbox.me/data/attachment/album/201403/31/214413hgrs2ozqwarrwypo.jpeg\" alt=\"\"></p>\n<p>按下 ‘q‘ （‘ESC‘ 和 ‘Ctrl-C‘ 也可以） 退出 Glances 终端。 这里是从 CentOS 6.5 截取的另一张截图：<br><img src=\"https://dn-linuxcn.qbox.me/data/attachment/album/201403/31/214419xaiwmtwwaawo2oya.jpeg\" alt=\"\"><br>Glances 的默认刷新频率是 1 （秒），但是你可以通过在终端指定参数来手动定义其刷新频率  </p>\n<pre><code># glances -t 2   \n</code></pre><p>Glances 中颜色的含义<br>Glances 会用一下几种颜色来代表状态：</p>\n<p>绿色：OK（一切正常）<br>蓝色：CAREFUL（需要注意）<br>紫色：WARNING（警告）<br>红色：CRITICAL（严重）<br>阀值可以在配置文件中设置，一般阀值被默认设置为（careful=50、warning=70、critical=90）。</p>\n<p>我们可以按照自己的需求在配置文件（默认在 /etc/glances/glances.conf）中自定义。</p>\n<p>Glances 的选项<br>除了很多命令行选项之外，Glances 还提供了更多的可在其运行时开关输出信息选项的快捷键，下面是一些例子：</p>\n<p>a – 对进程自动排序<br>c – 按 CPU 百分比对进程排序<br>m – 按内存百分比对进程排序<br>p – 按进程名字母顺序对进程排序<br>i – 按读写频率（I/O）对进程排序<br>d – 显示/隐藏磁盘 I/O 统计信息<br>f – 显示/隐藏文件系统统计信息<br>n – 显示/隐藏网络接口统计信息<br>s – 显示/隐藏传感器统计信息<br>y – 显示/隐藏硬盘温度统计信息<br>l – 显示/隐藏日志（log）<br>b – 切换网络 I/O 单位（Bytes/bits）<br>w – 删除警告日志<br>x – 删除警告和严重日志<br>1 – 切换全局 CPU 使用情况和每个 CPU 的使用情况<br>h – 显示/隐藏这个帮助画面<br>t – 以组合形式浏览网络 I/O<br>u – 以累计形式浏览网络 I/O<br>q – 退出（‘ESC‘ 和 ‘Ctrl&amp;C‘ 也可以）<br>远程使用 Glances<br>你甚至也可以通过 Glances 来监视远程系统。 要在远程系统使用 ‘glances’，需要在服务器运行 ‘glances -s’（-s 启动服务器/客户端模式）命令。  </p>\n<pre><code># glances -s\n</code></pre><p>Define the password for the Glances server<br>Password:<br>Password (confirm):<br>Glances server is running on 0.0.0.0:61209<br>注意：当你执行了‘glances’命令后，她会让你为 Glances 服务器设置密码。</p>\n<p>当你设置完毕，你将看到 “Glances server is running on 0.0.0.0:61209” （Glances 服务器正在 0.0.0.0 的 61209 端口运行）的消息。</p>\n<p>当 Glances 服务器启动后，到本地执行下面的命令来指定服务器IP地址或主机名以链接。</p>\n<p>注：这里的 ‘172.16.27.56’ 是我 Glances 服务器的 IP 地址。  </p>\n<pre><code># glances -c -P 172.16.27.56    \n</code></pre><p>  下面是一些在使用服务器/客户端模式时必须知道的事情：  </p>\n<ul>\n<li>在服务器模式，你可以通过 <code>-B 地址</code> 来设置绑定地址，也可以通过 <code>-p 端口</code> 来绑定监听的 TCP 端口  </li>\n<li>在客户端模式，你可以通过同样的 <code>-p 端口</code> 来指定服务器端口  </li>\n<li>默认的绑定地址是 0.0.0.0，但这么做会监听所有网络接口的指定端口  </li>\n<li>在服务器/客户端模式下，限制的阀值将由服务器的设置决定  </li>\n<li>你也可以在命令行下用过 <code>-P 密码</code> 的方式来为服务器端设置一个密码<br>总结<br>Glances 对于大多用户而言是个在系统资源上提供过多信息的工具。但是如果你是一个想要仅从命令行就能快速获取系统整体状况的系统管理员，那这个工具绝对是你的必备利器。<br>请不要将 glances（本文中的工具）和 glance（一个 OpenStack 的工具）这两个包搞混了<br>Ubuntu 官方 Extra 源中的 glances 因为 python 库移动的问题导致无法正常使用 但可以通过建立软链接的方式临时修复：sudo ln -s /usr/lib/python2.7/dist-packages/glances /usr/share/pyshared/glances</li>\n</ul>"},{"title":"git使用说明","date":"2016-09-02T04:00:00.000Z","_content":"在linux下搭建git环境\n###1、创建Github账号，https://github.com\n<!--more-->\n###2、Linux创建SSH密钥：\n\n    ssh-keygen  ##一直默认就可以了  \n###3、将公钥加入到Github账户信息Account Settings->SSH Key\n###4、测试验证是否成功。\n    ssh -T git@github.com \n    Hi someone! You've successfully authenticated, but GitHub does not provide shell access.  \n    \n#同步github到本地\n###1、复制项目到本地：\n \n    git clone git://github.com:xxxx/test.git ##以gitreadonly方式克隆到本地，只可以读    \n    git clone git@github.com:xxx/test.git  ##以SSH方式克隆到本地，可以读写  \n    git clone https://github.com/xxx/test.git ##以https方式克隆到本地，可以读写  \n    git fetch git@github.com:xxx/xxx.git  ##获取到本地但不合并  \n    git pull git@github.com:xxx/xxx.git ##获取并合并内容到本地  \n\n#本地提交项目到github\n###1、本地配置\n    git config --global user.name 'onovps'\n    git config --global user.email 'onovps@onovps.com' #全局联系方式，可选  \n\n###2、新建Git项目并提交到Github。\n    mkdir testdir & cd testdir  \n    touch README.md  \n    git init #初始化一个本地库  \n    git add README.md #添加文件到本地仓库  \n    git rm README.md #本地倒库内删除  \n    git commit -m \"first commit\" #提交到本地库并备注，此时变更仍在本地。  \n    git commit -a  ##自动更新变化的文件，a可以理解为auto  \n    git remote add xxx git@github.com:xxx/xxx.git  #增加一个远程服务器的别名。  \n    git remote rm xxx   ##删除远程版本库的别名  \n    git push -u remotename master #将本地文件提交到Github的remoname版本库中。此时才更新了本地变更到github服务上。  \n    \n#分支版本操作\n###1、创建和合并分支\n    git branch #显示当前分支是master  \n    git branch new-feature  #创建分支  \n    git checkout new-feature  #切换到新分支  \n    vi page_cache.inc.php  \n    git add page_cache.inc.php  \n    git commit -a -m \"added initial version of page cache\"  \n    git push origin new-feature  ##把分支提交到远程服务器，只是把分支结构和内容提交到远程，并没有发生和主干的合并行为。  \n###2、如果new-feature分支成熟了，觉得有必要合并进master\n    git checkout master  #切换到新主干  \n    git merge new-feature  ##把分支合并到主干  \n    git branch #显示当前分支是master  \n    git push  #此时主干中也合并了new-feature的代码  \n","source":"_posts/git.md","raw":"---\ntitle: git使用说明\ndate: 2016-09-02\ntags:\n---\n在linux下搭建git环境\n###1、创建Github账号，https://github.com\n<!--more-->\n###2、Linux创建SSH密钥：\n\n    ssh-keygen  ##一直默认就可以了  \n###3、将公钥加入到Github账户信息Account Settings->SSH Key\n###4、测试验证是否成功。\n    ssh -T git@github.com \n    Hi someone! You've successfully authenticated, but GitHub does not provide shell access.  \n    \n#同步github到本地\n###1、复制项目到本地：\n \n    git clone git://github.com:xxxx/test.git ##以gitreadonly方式克隆到本地，只可以读    \n    git clone git@github.com:xxx/test.git  ##以SSH方式克隆到本地，可以读写  \n    git clone https://github.com/xxx/test.git ##以https方式克隆到本地，可以读写  \n    git fetch git@github.com:xxx/xxx.git  ##获取到本地但不合并  \n    git pull git@github.com:xxx/xxx.git ##获取并合并内容到本地  \n\n#本地提交项目到github\n###1、本地配置\n    git config --global user.name 'onovps'\n    git config --global user.email 'onovps@onovps.com' #全局联系方式，可选  \n\n###2、新建Git项目并提交到Github。\n    mkdir testdir & cd testdir  \n    touch README.md  \n    git init #初始化一个本地库  \n    git add README.md #添加文件到本地仓库  \n    git rm README.md #本地倒库内删除  \n    git commit -m \"first commit\" #提交到本地库并备注，此时变更仍在本地。  \n    git commit -a  ##自动更新变化的文件，a可以理解为auto  \n    git remote add xxx git@github.com:xxx/xxx.git  #增加一个远程服务器的别名。  \n    git remote rm xxx   ##删除远程版本库的别名  \n    git push -u remotename master #将本地文件提交到Github的remoname版本库中。此时才更新了本地变更到github服务上。  \n    \n#分支版本操作\n###1、创建和合并分支\n    git branch #显示当前分支是master  \n    git branch new-feature  #创建分支  \n    git checkout new-feature  #切换到新分支  \n    vi page_cache.inc.php  \n    git add page_cache.inc.php  \n    git commit -a -m \"added initial version of page cache\"  \n    git push origin new-feature  ##把分支提交到远程服务器，只是把分支结构和内容提交到远程，并没有发生和主干的合并行为。  \n###2、如果new-feature分支成熟了，觉得有必要合并进master\n    git checkout master  #切换到新主干  \n    git merge new-feature  ##把分支合并到主干  \n    git branch #显示当前分支是master  \n    git push  #此时主干中也合并了new-feature的代码  \n","slug":"git","published":1,"updated":"2017-03-01T03:46:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizqklz7f0002lbpvnsed06os","content":"<p>在linux下搭建git环境</p>\n<p>###1、创建Github账号，<a href=\"https://github.com\" target=\"_blank\" rel=\"external\">https://github.com</a><br><a id=\"more\"></a></p>\n<p>###2、Linux创建SSH密钥：</p>\n<pre><code>ssh-keygen  ##一直默认就可以了  \n</code></pre><p>###3、将公钥加入到Github账户信息Account Settings-&gt;SSH Key</p>\n<p>###4、测试验证是否成功。<br>    ssh -T git@github.com<br>    Hi someone! You’ve successfully authenticated, but GitHub does not provide shell access.  </p>\n<p>#同步github到本地</p>\n<p>###1、复制项目到本地：</p>\n<pre><code>git clone git://github.com:xxxx/test.git ##以gitreadonly方式克隆到本地，只可以读    \ngit clone git@github.com:xxx/test.git  ##以SSH方式克隆到本地，可以读写  \ngit clone https://github.com/xxx/test.git ##以https方式克隆到本地，可以读写  \ngit fetch git@github.com:xxx/xxx.git  ##获取到本地但不合并  \ngit pull git@github.com:xxx/xxx.git ##获取并合并内容到本地  \n</code></pre><p>#本地提交项目到github</p>\n<p>###1、本地配置<br>    git config –global user.name ‘onovps’<br>    git config –global user.email ‘onovps@onovps.com’ #全局联系方式，可选  </p>\n<p>###2、新建Git项目并提交到Github。<br>    mkdir testdir &amp; cd testdir<br>    touch README.md<br>    git init #初始化一个本地库<br>    git add README.md #添加文件到本地仓库<br>    git rm README.md #本地倒库内删除<br>    git commit -m “first commit” #提交到本地库并备注，此时变更仍在本地。<br>    git commit -a  ##自动更新变化的文件，a可以理解为auto<br>    git remote add xxx git@github.com:xxx/xxx.git  #增加一个远程服务器的别名。<br>    git remote rm xxx   ##删除远程版本库的别名<br>    git push -u remotename master #将本地文件提交到Github的remoname版本库中。此时才更新了本地变更到github服务上。  </p>\n<p>#分支版本操作</p>\n<p>###1、创建和合并分支<br>    git branch #显示当前分支是master<br>    git branch new-feature  #创建分支<br>    git checkout new-feature  #切换到新分支<br>    vi page_cache.inc.php<br>    git add page_cache.inc.php<br>    git commit -a -m “added initial version of page cache”<br>    git push origin new-feature  ##把分支提交到远程服务器，只是把分支结构和内容提交到远程，并没有发生和主干的合并行为。  </p>\n<p>###2、如果new-feature分支成熟了，觉得有必要合并进master<br>    git checkout master  #切换到新主干<br>    git merge new-feature  ##把分支合并到主干<br>    git branch #显示当前分支是master<br>    git push  #此时主干中也合并了new-feature的代码  </p>\n","excerpt":"<p>在linux下搭建git环境</p>\n<p>###1、创建Github账号，<a href=\"https://github.com\">https://github.com</a><br>","more":"</p>\n<p>###2、Linux创建SSH密钥：</p>\n<pre><code>ssh-keygen  ##一直默认就可以了  \n</code></pre><p>###3、将公钥加入到Github账户信息Account Settings-&gt;SSH Key</p>\n<p>###4、测试验证是否成功。<br>    ssh -T git@github.com<br>    Hi someone! You’ve successfully authenticated, but GitHub does not provide shell access.  </p>\n<p>#同步github到本地</p>\n<p>###1、复制项目到本地：</p>\n<pre><code>git clone git://github.com:xxxx/test.git ##以gitreadonly方式克隆到本地，只可以读    \ngit clone git@github.com:xxx/test.git  ##以SSH方式克隆到本地，可以读写  \ngit clone https://github.com/xxx/test.git ##以https方式克隆到本地，可以读写  \ngit fetch git@github.com:xxx/xxx.git  ##获取到本地但不合并  \ngit pull git@github.com:xxx/xxx.git ##获取并合并内容到本地  \n</code></pre><p>#本地提交项目到github</p>\n<p>###1、本地配置<br>    git config –global user.name ‘onovps’<br>    git config –global user.email ‘onovps@onovps.com’ #全局联系方式，可选  </p>\n<p>###2、新建Git项目并提交到Github。<br>    mkdir testdir &amp; cd testdir<br>    touch README.md<br>    git init #初始化一个本地库<br>    git add README.md #添加文件到本地仓库<br>    git rm README.md #本地倒库内删除<br>    git commit -m “first commit” #提交到本地库并备注，此时变更仍在本地。<br>    git commit -a  ##自动更新变化的文件，a可以理解为auto<br>    git remote add xxx git@github.com:xxx/xxx.git  #增加一个远程服务器的别名。<br>    git remote rm xxx   ##删除远程版本库的别名<br>    git push -u remotename master #将本地文件提交到Github的remoname版本库中。此时才更新了本地变更到github服务上。  </p>\n<p>#分支版本操作</p>\n<p>###1、创建和合并分支<br>    git branch #显示当前分支是master<br>    git branch new-feature  #创建分支<br>    git checkout new-feature  #切换到新分支<br>    vi page_cache.inc.php<br>    git add page_cache.inc.php<br>    git commit -a -m “added initial version of page cache”<br>    git push origin new-feature  ##把分支提交到远程服务器，只是把分支结构和内容提交到远程，并没有发生和主干的合并行为。  </p>\n<p>###2、如果new-feature分支成熟了，觉得有必要合并进master<br>    git checkout master  #切换到新主干<br>    git merge new-feature  ##把分支合并到主干<br>    git branch #显示当前分支是master<br>    git push  #此时主干中也合并了new-feature的代码  </p>"},{"title":"搭建Hexo","date":"2016-09-02T04:00:00.000Z","_content":"1、安装编译npm基础包\n    rpm -Uvh http://download-i2.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm\n<!--more-->\n\n    yum install nodejs npm --enablerepo=epel\n部署 Hexo --- 安装\n    npm install -g hexo\n部署 Hexo --- 初始化\n    mkdir /home/wwwroot && hexo init /home/wwwroot","source":"_posts/hexo.md","raw":"---\ntitle: 搭建Hexo\ndate: 2016-09-02\ntags:\n---\n1、安装编译npm基础包\n    rpm -Uvh http://download-i2.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm\n<!--more-->\n\n    yum install nodejs npm --enablerepo=epel\n部署 Hexo --- 安装\n    npm install -g hexo\n部署 Hexo --- 初始化\n    mkdir /home/wwwroot && hexo init /home/wwwroot","slug":"hexo","published":1,"updated":"2017-03-01T05:59:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizqklz7h0003lbpvb7lt4lzc","content":"<p>1、安装编译npm基础包<br>    rpm -Uvh <a href=\"http://download-i2.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm\" target=\"_blank\" rel=\"external\">http://download-i2.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm</a><br><a id=\"more\"></a></p>\n<pre><code>yum install nodejs npm --enablerepo=epel\n</code></pre><p>部署 Hexo — 安装<br>    npm install -g hexo<br>部署 Hexo — 初始化<br>    mkdir /home/wwwroot &amp;&amp; hexo init /home/wwwroot</p>\n","excerpt":"<p>1、安装编译npm基础包<br>    rpm -Uvh <a href=\"http://download-i2.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm\">http://download-i2.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm</a><br>","more":"</p>\n<pre><code>yum install nodejs npm --enablerepo=epel\n</code></pre><p>部署 Hexo — 安装<br>    npm install -g hexo<br>部署 Hexo — 初始化<br>    mkdir /home/wwwroot &amp;&amp; hexo init /home/wwwroot</p>"},{"title":"htop使用说明","date":"2016-09-06T04:00:00.000Z","_content":"一、htop 简介\n\nThis is htop, an interactive process viewer for Linux. It is a text-mode application (for console or X terminals) and requires ncurses.\n\nComparison between htop and top\n<!--more-->\nIn 'htop' you can scroll the list vertically and horizontally to see all processes and complete command lines.\nIn 'top' you are subject to a delay for each unassigned key you press (especially annoying when multi-key escape sequences are triggered by accident).\n'htop' starts faster ('top' seems to collect data for a while before displaying anything).\nIn 'htop' you don't need to type the process number to kill a process, in 'top' you do.\nIn 'htop' you don't need to type the process number or the priority value to renice a process, in 'top' you do.\n'htop' supports mouse operation, 'top' doesn't\n'top' is older, hence, more used and tested.\nhtop 是Linux系统中的一个互动的进程查看器，一个文本模式的应用程序(在控制台或者X终端中)，需要ncurses。\n\n与Linux传统的top相比，htop更加人性化。它可让用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。\n\n与top相比，htop有以下优点：\n\n可以横向或纵向滚动浏览进程列表，以便看到所有的进程和完整的命令行。\n在启动上，比top 更快。\n杀进程时不需要输入进程号。\nhtop 支持鼠标操作。\ntop 已经很老了。\nhtop 官网：http://htop.sourceforge.net/\n\n二、htop 安装\n\na. 源码包安装\n\n    # tar zxvf htop-1.0.2.tar.gz\n    \n    # cd htop-1.0.2\n    \n    # ./configure\n    \n![](http://images.cnitblog.com/blog/370046/201301/12224043-10fbaaa4ef2d49ba844de4ff1df2cea2.jpg)\n\n    # make && make install\n\n![](http://images.cnitblog.com/blog/370046/201301/12224044-8e70dd81c3594f14bf334dbf7ae12cda.jpg)\n\n若出现错误：\n\n\n    configure: error: You may want to use --disable-unicode or install libncursesw.\n\n则需安装 ncurses-devel\n\n\n    # yum install ncurses-devel\n\nb. RHEL/CentOS 安装\n\n可以通过 yum install htop 来安装它，但前提是要添加epel 的yum源，具体请参考 CentOS yum 源的配置与使用。\n\n    # rpm -ivh http://download.fedoraproject.org/pub/epel/5/i386/epel-release-5-4.noarch.rpm \n    # rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL//导入key \n    # yum install htop\n    \n三、htop 参数\n\n键入htop 命令，打开htop。\n\n\n    # htop\n\n\n ![](http://images.cnitblog.com/blog/370046/201301/12224047-b6fd5270cea14cee87544ff3ca193b34.jpg)\n\n上面左上角显示CPU、内存、交换区的使用情况，右边显示任务、负载、开机时间，下面就是进程实时状况。\n\n下面是 F1~F10 的功能和对应的字母快捷键。\n\n----------\n\nShortcut Key　　　　　　  　　 Function Ke　　　　　　  　　 Description　　　　　　 　　　　　　  　　  中文说明  \n\nh,?　　　　　　  　　　　　　　  　　   F1\t　　　　　　  　　 Invoke htop Help　　　　　　  　　 \t　　　　　　查看htop使用说明  \nS\t　　　　　　  　　 　　　　　　  　　F2　　　　　　  　　 \tHtop Setup Menu\thtop　　　　　　  　　 　　　 设定  \n/\t　　　　　　  　　 　　　　　　   　　  F3\t　　　　　　  　　 Search for a Process\t　　　　　　  　　　　　　 搜索进程  \n\\\t　　　　　　  　　 　　　　　　  　　 F4\t　　　　　　  　　 Incremental process filtering\t　　　　　　  　　 增量进程过滤器  \nt\t　　　　　　  　　 　　　　　　  　　 F5　　　　　　  　　 \tTree View\t　　　　　　  　　 　　　　　　  　　　 显示树形结构  \n<, >\t　　　　　　  　　 　　　　　　  　F6\t　　　　　　  　　 Sort by a column\t　　　　　　  　　　　　　　　   选择排序方式  \n[\t　　　　　　  　　 　　　　　　  　　 F7\t　　　　　　  　　 Nice - (change priority)\t　　　可减少nice值，这样就可以提高对应进程的优先级  \n]\t　　　　　　  　　 　　　　　　  　　 F8\t　　　　　　  　　 Nice + (change priority)\t　　　可增加nice值，这样就可以降低对应进程的优先级  \nk\t　　　　　　  　　 　　　　　　  　　 F9\t　　　　　　  　　 Kill a Process\t　　　　　　  　　 　　　　　　  　可对进程传递信号  \nq\t　　　　　　  　　 　　　　　　  　　 F10\t　　　　　　  　　 Quit htop\t　　　　　　  　　 　　　　　　  　　 结束htop  \n\n----------\n\n命令行选项（COMMAND-LINE OPTIONS）\n\n-C --no-color　　　　 　　 使用一个单色的配色方案\n\n-d --delay=DELAY　　　　 设置延迟更新时间，单位秒\n\n-h --help　　　　　　  　　 显示htop 命令帮助信息\n\n-u --user=USERNAME　　  只显示一个给定的用户的过程\n\n-p --pid=PID,PID…　　　    只显示给定的PIDs\n\n-s --sort-key COLUMN　    依此列来排序\n\n-v –version　　　　　　　   显示版本信息\n\n交互式命令（INTERACTIVE COMMANDS）\n\n----------\n\n\n上下键或PgUP, PgDn 选定想要的进程，左右键或Home, End 移动字段，当然也可以直接用鼠标选定进程；\n\nSpace    标记/取消标记一个进程。命令可以作用于多个进程，例如 \"kill\"，将应用于所有已标记的进程\n\nU    取消标记所有进程\n\ns    选择某一进程，按s:用strace追踪进程的系统调用\n\nl    显示进程打开的文件: 如果安装了lsof，按此键可以显示进程所打开的文件\n\nI    倒转排序顺序，如果排序是正序的，则反转成倒序的，反之亦然\n\n+, -    When in tree view mode, expand or collapse subtree. When a subtree is collapsed a \"+\" sign shows to the left of the process name.\n\na (在有多处理器的机器上)    设置 CPU affinity: 标记一个进程允许使用哪些CPU\n\nu    显示特定用户进程\n\nM    按Memory 使用排序\n\nP    按CPU 使用排序\n\nT    按Time+ 使用排序\n\nF    跟踪进程: 如果排序顺序引起选定的进程在列表上到处移动，让选定条跟随该进程。这对监视一个进程非常有用：通过这种方式，你可以让一个进程在屏幕上一直可见。使用方向键会停止该功能。\n\nK    显示/隐藏内核线程\n\nH    显示/隐藏用户线程\n\nCtrl-L    刷新\n\nNumbers    PID 查找: 输入PID，光标将移动到相应的进程上\n\n----------\n\n\n四、htop 使用\n\n4.1. 显示自带帮助\n\n鼠标点击Help或者按F1 显示自带帮助\n![](http://images.cnitblog.com/blog/370046/201301/12224049-575f66ab3d964c5cb419959aee9032b1.jpg)\n\n\n4.2. htop 设定\n\n鼠标点击Setup或者按下F2 之后进入htop 设定的页面，Meters 页面设定了顶端的一些信息显示，顶端的显示又分为左右两侧，到底能显示些什么可以在最右侧那栏新增，要新增到上方左侧（F5）或是右侧（F6）都可以，这就是个人设定的范围了。这里多加了一个时钟。\n\n![](http://images.cnitblog.com/blog/370046/201301/12224051-9b4d728776d1499190c9d21ab3615f5a.jpg)\n\n上方左右两栏的显示方式分为Text Bar Graph Led 四种，下图我就把 cpu memory swap 改成文本模式显示，然后右栏的改成Bar 显示，clock 用LED方式显示。数据显示都差不多，只是这样看有点不习惯了。\n\n![](http://images.cnitblog.com/blog/370046/201301/12224052-befc1e283e4c4576a59f89e6f72a4337.jpg)\n\n关于Display options 的设定，可要根据管理者自己的需要来设定。\n\n![](http://images.cnitblog.com/blog/370046/201301/12224054-b8d7722ac20b421299bd0c72b3394198.jpg)\n\n颜色选择，除了基本的颜色显示之外，htop 还提供了换面板的功能，其实也只是改变一些色彩显示的设定，虽然说不能自定义到细部的颜色显示，但是至少提供了几种风格可以选择。\n\n![](http://images.cnitblog.com/blog/370046/201301/12224055-b6a13eb2abaa45fab167e61a8db12356.jpg)\n\n最后一项的设定是调整 Columns 的显示，就是在一般htop 指令进来希望可以看到的什么样的数据及信息，字段的调整可以在这边做个人化的设定，一般使用系统默认值就好了。\n\n![](http://images.cnitblog.com/blog/370046/201301/12224058-1ef4f726ccd64dfbaab68142dc9a95be.jpg)\n\n4.3. 搜索进程\n\n鼠标点击Search 或者按下F3 或者输入\"/\"， 输入进程名进行搜索，例如搜索ssh\n\n![](http://images.cnitblog.com/blog/370046/201301/12224100-dab0040192b24614b44d1e28d1b4badb.jpg)\n\n4.4. 过滤器\n\n按下F4，进入过滤器，相当于关键字搜索，不区分大小写，例如过滤dev\n\n![](http://images.cnitblog.com/blog/370046/201301/12224102-6339cac4da0b482097e1a5b218b523c4.jpg)\n\n4.5. 显示树形结构\n\n输入\"t\"或按下F5，显示树形结构，意思跟pstree 差不多，能看到所有程序树状执行的结构，这对于系统管理来说相当方便，理清程序是如何产生的，当然树状结构的浏览也可以依照其他数据来排序。\n\n![](http://images.cnitblog.com/blog/370046/201301/12224104-f5d4a8c905cd4a83b262ad2e5944f3fe.jpg)\n\n4.6. 选择排序方式\n\n按下F6 就可以选择依照什么来排序，最常排序的内容就是cpu 和memory 吧！\n\n![](http://images.cnitblog.com/blog/370046/201301/12224107-6a091d2523cd4829b243f635b1c32a0a.jpg)\n\n4.7 操作进程\n\nF7、F8分别对应nice-和nice+，F9对应kill给进程发信号，选好信号回车就OK了\n\n![](http://images.cnitblog.com/blog/370046/201301/12224112-9dc1706a8dbd4972b78a78af34f75ec7.jpg)\n\n4.8. 显示某个用户的进程，在左侧选择用户\n\n输入\"u\"，在左侧选择用户\n\n![](http://images.cnitblog.com/blog/370046/201301/12224115-289b4cf95c344dada4aa048c25f821ce.jpg)\n\n五、Alias top\n\n也许你用惯了top，我们也可以用top来打开htop。\n\n编辑/root/.bashrc文件，添加如下代码\n\n    if [ -f /usr/local/bin/htop ]; then\n    alias top=’/usr/local/bin/htop’\n    fi\n    # source /root/.bashrc","source":"_posts/htop使用说明.md","raw":"---\ntitle: htop使用说明\ndate: 2016-09-06\ntags:\n---\n一、htop 简介\n\nThis is htop, an interactive process viewer for Linux. It is a text-mode application (for console or X terminals) and requires ncurses.\n\nComparison between htop and top\n<!--more-->\nIn 'htop' you can scroll the list vertically and horizontally to see all processes and complete command lines.\nIn 'top' you are subject to a delay for each unassigned key you press (especially annoying when multi-key escape sequences are triggered by accident).\n'htop' starts faster ('top' seems to collect data for a while before displaying anything).\nIn 'htop' you don't need to type the process number to kill a process, in 'top' you do.\nIn 'htop' you don't need to type the process number or the priority value to renice a process, in 'top' you do.\n'htop' supports mouse operation, 'top' doesn't\n'top' is older, hence, more used and tested.\nhtop 是Linux系统中的一个互动的进程查看器，一个文本模式的应用程序(在控制台或者X终端中)，需要ncurses。\n\n与Linux传统的top相比，htop更加人性化。它可让用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。\n\n与top相比，htop有以下优点：\n\n可以横向或纵向滚动浏览进程列表，以便看到所有的进程和完整的命令行。\n在启动上，比top 更快。\n杀进程时不需要输入进程号。\nhtop 支持鼠标操作。\ntop 已经很老了。\nhtop 官网：http://htop.sourceforge.net/\n\n二、htop 安装\n\na. 源码包安装\n\n    # tar zxvf htop-1.0.2.tar.gz\n    \n    # cd htop-1.0.2\n    \n    # ./configure\n    \n![](http://images.cnitblog.com/blog/370046/201301/12224043-10fbaaa4ef2d49ba844de4ff1df2cea2.jpg)\n\n    # make && make install\n\n![](http://images.cnitblog.com/blog/370046/201301/12224044-8e70dd81c3594f14bf334dbf7ae12cda.jpg)\n\n若出现错误：\n\n\n    configure: error: You may want to use --disable-unicode or install libncursesw.\n\n则需安装 ncurses-devel\n\n\n    # yum install ncurses-devel\n\nb. RHEL/CentOS 安装\n\n可以通过 yum install htop 来安装它，但前提是要添加epel 的yum源，具体请参考 CentOS yum 源的配置与使用。\n\n    # rpm -ivh http://download.fedoraproject.org/pub/epel/5/i386/epel-release-5-4.noarch.rpm \n    # rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL//导入key \n    # yum install htop\n    \n三、htop 参数\n\n键入htop 命令，打开htop。\n\n\n    # htop\n\n\n ![](http://images.cnitblog.com/blog/370046/201301/12224047-b6fd5270cea14cee87544ff3ca193b34.jpg)\n\n上面左上角显示CPU、内存、交换区的使用情况，右边显示任务、负载、开机时间，下面就是进程实时状况。\n\n下面是 F1~F10 的功能和对应的字母快捷键。\n\n----------\n\nShortcut Key　　　　　　  　　 Function Ke　　　　　　  　　 Description　　　　　　 　　　　　　  　　  中文说明  \n\nh,?　　　　　　  　　　　　　　  　　   F1\t　　　　　　  　　 Invoke htop Help　　　　　　  　　 \t　　　　　　查看htop使用说明  \nS\t　　　　　　  　　 　　　　　　  　　F2　　　　　　  　　 \tHtop Setup Menu\thtop　　　　　　  　　 　　　 设定  \n/\t　　　　　　  　　 　　　　　　   　　  F3\t　　　　　　  　　 Search for a Process\t　　　　　　  　　　　　　 搜索进程  \n\\\t　　　　　　  　　 　　　　　　  　　 F4\t　　　　　　  　　 Incremental process filtering\t　　　　　　  　　 增量进程过滤器  \nt\t　　　　　　  　　 　　　　　　  　　 F5　　　　　　  　　 \tTree View\t　　　　　　  　　 　　　　　　  　　　 显示树形结构  \n<, >\t　　　　　　  　　 　　　　　　  　F6\t　　　　　　  　　 Sort by a column\t　　　　　　  　　　　　　　　   选择排序方式  \n[\t　　　　　　  　　 　　　　　　  　　 F7\t　　　　　　  　　 Nice - (change priority)\t　　　可减少nice值，这样就可以提高对应进程的优先级  \n]\t　　　　　　  　　 　　　　　　  　　 F8\t　　　　　　  　　 Nice + (change priority)\t　　　可增加nice值，这样就可以降低对应进程的优先级  \nk\t　　　　　　  　　 　　　　　　  　　 F9\t　　　　　　  　　 Kill a Process\t　　　　　　  　　 　　　　　　  　可对进程传递信号  \nq\t　　　　　　  　　 　　　　　　  　　 F10\t　　　　　　  　　 Quit htop\t　　　　　　  　　 　　　　　　  　　 结束htop  \n\n----------\n\n命令行选项（COMMAND-LINE OPTIONS）\n\n-C --no-color　　　　 　　 使用一个单色的配色方案\n\n-d --delay=DELAY　　　　 设置延迟更新时间，单位秒\n\n-h --help　　　　　　  　　 显示htop 命令帮助信息\n\n-u --user=USERNAME　　  只显示一个给定的用户的过程\n\n-p --pid=PID,PID…　　　    只显示给定的PIDs\n\n-s --sort-key COLUMN　    依此列来排序\n\n-v –version　　　　　　　   显示版本信息\n\n交互式命令（INTERACTIVE COMMANDS）\n\n----------\n\n\n上下键或PgUP, PgDn 选定想要的进程，左右键或Home, End 移动字段，当然也可以直接用鼠标选定进程；\n\nSpace    标记/取消标记一个进程。命令可以作用于多个进程，例如 \"kill\"，将应用于所有已标记的进程\n\nU    取消标记所有进程\n\ns    选择某一进程，按s:用strace追踪进程的系统调用\n\nl    显示进程打开的文件: 如果安装了lsof，按此键可以显示进程所打开的文件\n\nI    倒转排序顺序，如果排序是正序的，则反转成倒序的，反之亦然\n\n+, -    When in tree view mode, expand or collapse subtree. When a subtree is collapsed a \"+\" sign shows to the left of the process name.\n\na (在有多处理器的机器上)    设置 CPU affinity: 标记一个进程允许使用哪些CPU\n\nu    显示特定用户进程\n\nM    按Memory 使用排序\n\nP    按CPU 使用排序\n\nT    按Time+ 使用排序\n\nF    跟踪进程: 如果排序顺序引起选定的进程在列表上到处移动，让选定条跟随该进程。这对监视一个进程非常有用：通过这种方式，你可以让一个进程在屏幕上一直可见。使用方向键会停止该功能。\n\nK    显示/隐藏内核线程\n\nH    显示/隐藏用户线程\n\nCtrl-L    刷新\n\nNumbers    PID 查找: 输入PID，光标将移动到相应的进程上\n\n----------\n\n\n四、htop 使用\n\n4.1. 显示自带帮助\n\n鼠标点击Help或者按F1 显示自带帮助\n![](http://images.cnitblog.com/blog/370046/201301/12224049-575f66ab3d964c5cb419959aee9032b1.jpg)\n\n\n4.2. htop 设定\n\n鼠标点击Setup或者按下F2 之后进入htop 设定的页面，Meters 页面设定了顶端的一些信息显示，顶端的显示又分为左右两侧，到底能显示些什么可以在最右侧那栏新增，要新增到上方左侧（F5）或是右侧（F6）都可以，这就是个人设定的范围了。这里多加了一个时钟。\n\n![](http://images.cnitblog.com/blog/370046/201301/12224051-9b4d728776d1499190c9d21ab3615f5a.jpg)\n\n上方左右两栏的显示方式分为Text Bar Graph Led 四种，下图我就把 cpu memory swap 改成文本模式显示，然后右栏的改成Bar 显示，clock 用LED方式显示。数据显示都差不多，只是这样看有点不习惯了。\n\n![](http://images.cnitblog.com/blog/370046/201301/12224052-befc1e283e4c4576a59f89e6f72a4337.jpg)\n\n关于Display options 的设定，可要根据管理者自己的需要来设定。\n\n![](http://images.cnitblog.com/blog/370046/201301/12224054-b8d7722ac20b421299bd0c72b3394198.jpg)\n\n颜色选择，除了基本的颜色显示之外，htop 还提供了换面板的功能，其实也只是改变一些色彩显示的设定，虽然说不能自定义到细部的颜色显示，但是至少提供了几种风格可以选择。\n\n![](http://images.cnitblog.com/blog/370046/201301/12224055-b6a13eb2abaa45fab167e61a8db12356.jpg)\n\n最后一项的设定是调整 Columns 的显示，就是在一般htop 指令进来希望可以看到的什么样的数据及信息，字段的调整可以在这边做个人化的设定，一般使用系统默认值就好了。\n\n![](http://images.cnitblog.com/blog/370046/201301/12224058-1ef4f726ccd64dfbaab68142dc9a95be.jpg)\n\n4.3. 搜索进程\n\n鼠标点击Search 或者按下F3 或者输入\"/\"， 输入进程名进行搜索，例如搜索ssh\n\n![](http://images.cnitblog.com/blog/370046/201301/12224100-dab0040192b24614b44d1e28d1b4badb.jpg)\n\n4.4. 过滤器\n\n按下F4，进入过滤器，相当于关键字搜索，不区分大小写，例如过滤dev\n\n![](http://images.cnitblog.com/blog/370046/201301/12224102-6339cac4da0b482097e1a5b218b523c4.jpg)\n\n4.5. 显示树形结构\n\n输入\"t\"或按下F5，显示树形结构，意思跟pstree 差不多，能看到所有程序树状执行的结构，这对于系统管理来说相当方便，理清程序是如何产生的，当然树状结构的浏览也可以依照其他数据来排序。\n\n![](http://images.cnitblog.com/blog/370046/201301/12224104-f5d4a8c905cd4a83b262ad2e5944f3fe.jpg)\n\n4.6. 选择排序方式\n\n按下F6 就可以选择依照什么来排序，最常排序的内容就是cpu 和memory 吧！\n\n![](http://images.cnitblog.com/blog/370046/201301/12224107-6a091d2523cd4829b243f635b1c32a0a.jpg)\n\n4.7 操作进程\n\nF7、F8分别对应nice-和nice+，F9对应kill给进程发信号，选好信号回车就OK了\n\n![](http://images.cnitblog.com/blog/370046/201301/12224112-9dc1706a8dbd4972b78a78af34f75ec7.jpg)\n\n4.8. 显示某个用户的进程，在左侧选择用户\n\n输入\"u\"，在左侧选择用户\n\n![](http://images.cnitblog.com/blog/370046/201301/12224115-289b4cf95c344dada4aa048c25f821ce.jpg)\n\n五、Alias top\n\n也许你用惯了top，我们也可以用top来打开htop。\n\n编辑/root/.bashrc文件，添加如下代码\n\n    if [ -f /usr/local/bin/htop ]; then\n    alias top=’/usr/local/bin/htop’\n    fi\n    # source /root/.bashrc","slug":"htop使用说明","published":1,"updated":"2017-03-01T05:59:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizqklz7i0004lbpva2b2romw","content":"<p>一、htop 简介</p>\n<p>This is htop, an interactive process viewer for Linux. It is a text-mode application (for console or X terminals) and requires ncurses.</p>\n<p>Comparison between htop and top<br><a id=\"more\"></a><br>In ‘htop’ you can scroll the list vertically and horizontally to see all processes and complete command lines.<br>In ‘top’ you are subject to a delay for each unassigned key you press (especially annoying when multi-key escape sequences are triggered by accident).<br>‘htop’ starts faster (‘top’ seems to collect data for a while before displaying anything).<br>In ‘htop’ you don’t need to type the process number to kill a process, in ‘top’ you do.<br>In ‘htop’ you don’t need to type the process number or the priority value to renice a process, in ‘top’ you do.<br>‘htop’ supports mouse operation, ‘top’ doesn’t<br>‘top’ is older, hence, more used and tested.<br>htop 是Linux系统中的一个互动的进程查看器，一个文本模式的应用程序(在控制台或者X终端中)，需要ncurses。</p>\n<p>与Linux传统的top相比，htop更加人性化。它可让用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。</p>\n<p>与top相比，htop有以下优点：</p>\n<p>可以横向或纵向滚动浏览进程列表，以便看到所有的进程和完整的命令行。<br>在启动上，比top 更快。<br>杀进程时不需要输入进程号。<br>htop 支持鼠标操作。<br>top 已经很老了。<br>htop 官网：<a href=\"http://htop.sourceforge.net/\" target=\"_blank\" rel=\"external\">http://htop.sourceforge.net/</a></p>\n<p>二、htop 安装</p>\n<p>a. 源码包安装</p>\n<pre><code># tar zxvf htop-1.0.2.tar.gz\n\n# cd htop-1.0.2\n\n# ./configure\n</code></pre><p><img src=\"http://images.cnitblog.com/blog/370046/201301/12224043-10fbaaa4ef2d49ba844de4ff1df2cea2.jpg\" alt=\"\"></p>\n<pre><code># make &amp;&amp; make install\n</code></pre><p><img src=\"http://images.cnitblog.com/blog/370046/201301/12224044-8e70dd81c3594f14bf334dbf7ae12cda.jpg\" alt=\"\"></p>\n<p>若出现错误：</p>\n<pre><code>configure: error: You may want to use --disable-unicode or install libncursesw.\n</code></pre><p>则需安装 ncurses-devel</p>\n<pre><code># yum install ncurses-devel\n</code></pre><p>b. RHEL/CentOS 安装</p>\n<p>可以通过 yum install htop 来安装它，但前提是要添加epel 的yum源，具体请参考 CentOS yum 源的配置与使用。</p>\n<pre><code># rpm -ivh http://download.fedoraproject.org/pub/epel/5/i386/epel-release-5-4.noarch.rpm \n# rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL//导入key \n# yum install htop\n</code></pre><p>三、htop 参数</p>\n<p>键入htop 命令，打开htop。</p>\n<pre><code># htop\n</code></pre><p> <img src=\"http://images.cnitblog.com/blog/370046/201301/12224047-b6fd5270cea14cee87544ff3ca193b34.jpg\" alt=\"\"></p>\n<p>上面左上角显示CPU、内存、交换区的使用情况，右边显示任务、负载、开机时间，下面就是进程实时状况。</p>\n<p>下面是 F1~F10 的功能和对应的字母快捷键。</p>\n<hr>\n<p>Shortcut Key　　　　　　  　　 Function Ke　　　　　　  　　 Description　　　　　　 　　　　　　  　　  中文说明  </p>\n<p>h,?　　　　　　  　　　　　　　  　　   F1    　　　　　　  　　 Invoke htop Help　　　　　　  　　     　　　　　　查看htop使用说明<br>S    　　　　　　  　　 　　　　　　  　　F2　　　　　　  　　     Htop Setup Menu    htop　　　　　　  　　 　　　 设定<br>/    　　　　　　  　　 　　　　　　   　　  F3    　　　　　　  　　 Search for a Process    　　　　　　  　　　　　　 搜索进程<br>\\    　　　　　　  　　 　　　　　　  　　 F4    　　　　　　  　　 Incremental process filtering    　　　　　　  　　 增量进程过滤器<br>t    　　　　　　  　　 　　　　　　  　　 F5　　　　　　  　　     Tree View    　　　　　　  　　 　　　　　　  　　　 显示树形结构<br>&lt;, &gt;    　　　　　　  　　 　　　　　　  　F6    　　　　　　  　　 Sort by a column    　　　　　　  　　　　　　　　   选择排序方式<br>[    　　　　　　  　　 　　　　　　  　　 F7    　　　　　　  　　 Nice - (change priority)    　　　可减少nice值，这样就可以提高对应进程的优先级<br>]    　　　　　　  　　 　　　　　　  　　 F8    　　　　　　  　　 Nice + (change priority)    　　　可增加nice值，这样就可以降低对应进程的优先级<br>k    　　　　　　  　　 　　　　　　  　　 F9    　　　　　　  　　 Kill a Process    　　　　　　  　　 　　　　　　  　可对进程传递信号<br>q    　　　　　　  　　 　　　　　　  　　 F10    　　　　　　  　　 Quit htop    　　　　　　  　　 　　　　　　  　　 结束htop  </p>\n<hr>\n<p>命令行选项（COMMAND-LINE OPTIONS）</p>\n<p>-C –no-color　　　　 　　 使用一个单色的配色方案</p>\n<p>-d –delay=DELAY　　　　 设置延迟更新时间，单位秒</p>\n<p>-h –help　　　　　　  　　 显示htop 命令帮助信息</p>\n<p>-u –user=USERNAME　　  只显示一个给定的用户的过程</p>\n<p>-p –pid=PID,PID…　　　    只显示给定的PIDs</p>\n<p>-s –sort-key COLUMN　    依此列来排序</p>\n<p>-v –version　　　　　　　   显示版本信息</p>\n<p>交互式命令（INTERACTIVE COMMANDS）</p>\n<hr>\n<p>上下键或PgUP, PgDn 选定想要的进程，左右键或Home, End 移动字段，当然也可以直接用鼠标选定进程；</p>\n<p>Space    标记/取消标记一个进程。命令可以作用于多个进程，例如 “kill”，将应用于所有已标记的进程</p>\n<p>U    取消标记所有进程</p>\n<p>s    选择某一进程，按s:用strace追踪进程的系统调用</p>\n<p>l    显示进程打开的文件: 如果安装了lsof，按此键可以显示进程所打开的文件</p>\n<p>I    倒转排序顺序，如果排序是正序的，则反转成倒序的，反之亦然</p>\n<p>+, -    When in tree view mode, expand or collapse subtree. When a subtree is collapsed a “+” sign shows to the left of the process name.</p>\n<p>a (在有多处理器的机器上)    设置 CPU affinity: 标记一个进程允许使用哪些CPU</p>\n<p>u    显示特定用户进程</p>\n<p>M    按Memory 使用排序</p>\n<p>P    按CPU 使用排序</p>\n<p>T    按Time+ 使用排序</p>\n<p>F    跟踪进程: 如果排序顺序引起选定的进程在列表上到处移动，让选定条跟随该进程。这对监视一个进程非常有用：通过这种方式，你可以让一个进程在屏幕上一直可见。使用方向键会停止该功能。</p>\n<p>K    显示/隐藏内核线程</p>\n<p>H    显示/隐藏用户线程</p>\n<p>Ctrl-L    刷新</p>\n<p>Numbers    PID 查找: 输入PID，光标将移动到相应的进程上</p>\n<hr>\n<p>四、htop 使用</p>\n<p>4.1. 显示自带帮助</p>\n<p>鼠标点击Help或者按F1 显示自带帮助<br><img src=\"http://images.cnitblog.com/blog/370046/201301/12224049-575f66ab3d964c5cb419959aee9032b1.jpg\" alt=\"\"></p>\n<p>4.2. htop 设定</p>\n<p>鼠标点击Setup或者按下F2 之后进入htop 设定的页面，Meters 页面设定了顶端的一些信息显示，顶端的显示又分为左右两侧，到底能显示些什么可以在最右侧那栏新增，要新增到上方左侧（F5）或是右侧（F6）都可以，这就是个人设定的范围了。这里多加了一个时钟。</p>\n<p><img src=\"http://images.cnitblog.com/blog/370046/201301/12224051-9b4d728776d1499190c9d21ab3615f5a.jpg\" alt=\"\"></p>\n<p>上方左右两栏的显示方式分为Text Bar Graph Led 四种，下图我就把 cpu memory swap 改成文本模式显示，然后右栏的改成Bar 显示，clock 用LED方式显示。数据显示都差不多，只是这样看有点不习惯了。</p>\n<p><img src=\"http://images.cnitblog.com/blog/370046/201301/12224052-befc1e283e4c4576a59f89e6f72a4337.jpg\" alt=\"\"></p>\n<p>关于Display options 的设定，可要根据管理者自己的需要来设定。</p>\n<p><img src=\"http://images.cnitblog.com/blog/370046/201301/12224054-b8d7722ac20b421299bd0c72b3394198.jpg\" alt=\"\"></p>\n<p>颜色选择，除了基本的颜色显示之外，htop 还提供了换面板的功能，其实也只是改变一些色彩显示的设定，虽然说不能自定义到细部的颜色显示，但是至少提供了几种风格可以选择。</p>\n<p><img src=\"http://images.cnitblog.com/blog/370046/201301/12224055-b6a13eb2abaa45fab167e61a8db12356.jpg\" alt=\"\"></p>\n<p>最后一项的设定是调整 Columns 的显示，就是在一般htop 指令进来希望可以看到的什么样的数据及信息，字段的调整可以在这边做个人化的设定，一般使用系统默认值就好了。</p>\n<p><img src=\"http://images.cnitblog.com/blog/370046/201301/12224058-1ef4f726ccd64dfbaab68142dc9a95be.jpg\" alt=\"\"></p>\n<p>4.3. 搜索进程</p>\n<p>鼠标点击Search 或者按下F3 或者输入”/“， 输入进程名进行搜索，例如搜索ssh</p>\n<p><img src=\"http://images.cnitblog.com/blog/370046/201301/12224100-dab0040192b24614b44d1e28d1b4badb.jpg\" alt=\"\"></p>\n<p>4.4. 过滤器</p>\n<p>按下F4，进入过滤器，相当于关键字搜索，不区分大小写，例如过滤dev</p>\n<p><img src=\"http://images.cnitblog.com/blog/370046/201301/12224102-6339cac4da0b482097e1a5b218b523c4.jpg\" alt=\"\"></p>\n<p>4.5. 显示树形结构</p>\n<p>输入”t”或按下F5，显示树形结构，意思跟pstree 差不多，能看到所有程序树状执行的结构，这对于系统管理来说相当方便，理清程序是如何产生的，当然树状结构的浏览也可以依照其他数据来排序。</p>\n<p><img src=\"http://images.cnitblog.com/blog/370046/201301/12224104-f5d4a8c905cd4a83b262ad2e5944f3fe.jpg\" alt=\"\"></p>\n<p>4.6. 选择排序方式</p>\n<p>按下F6 就可以选择依照什么来排序，最常排序的内容就是cpu 和memory 吧！</p>\n<p><img src=\"http://images.cnitblog.com/blog/370046/201301/12224107-6a091d2523cd4829b243f635b1c32a0a.jpg\" alt=\"\"></p>\n<p>4.7 操作进程</p>\n<p>F7、F8分别对应nice-和nice+，F9对应kill给进程发信号，选好信号回车就OK了</p>\n<p><img src=\"http://images.cnitblog.com/blog/370046/201301/12224112-9dc1706a8dbd4972b78a78af34f75ec7.jpg\" alt=\"\"></p>\n<p>4.8. 显示某个用户的进程，在左侧选择用户</p>\n<p>输入”u”，在左侧选择用户</p>\n<p><img src=\"http://images.cnitblog.com/blog/370046/201301/12224115-289b4cf95c344dada4aa048c25f821ce.jpg\" alt=\"\"></p>\n<p>五、Alias top</p>\n<p>也许你用惯了top，我们也可以用top来打开htop。</p>\n<p>编辑/root/.bashrc文件，添加如下代码</p>\n<pre><code>if [ -f /usr/local/bin/htop ]; then\nalias top=’/usr/local/bin/htop’\nfi\n# source /root/.bashrc\n</code></pre>","excerpt":"<p>一、htop 简介</p>\n<p>This is htop, an interactive process viewer for Linux. It is a text-mode application (for console or X terminals) and requires ncurses.</p>\n<p>Comparison between htop and top<br>","more":"<br>In ‘htop’ you can scroll the list vertically and horizontally to see all processes and complete command lines.<br>In ‘top’ you are subject to a delay for each unassigned key you press (especially annoying when multi-key escape sequences are triggered by accident).<br>‘htop’ starts faster (‘top’ seems to collect data for a while before displaying anything).<br>In ‘htop’ you don’t need to type the process number to kill a process, in ‘top’ you do.<br>In ‘htop’ you don’t need to type the process number or the priority value to renice a process, in ‘top’ you do.<br>‘htop’ supports mouse operation, ‘top’ doesn’t<br>‘top’ is older, hence, more used and tested.<br>htop 是Linux系统中的一个互动的进程查看器，一个文本模式的应用程序(在控制台或者X终端中)，需要ncurses。</p>\n<p>与Linux传统的top相比，htop更加人性化。它可让用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。</p>\n<p>与top相比，htop有以下优点：</p>\n<p>可以横向或纵向滚动浏览进程列表，以便看到所有的进程和完整的命令行。<br>在启动上，比top 更快。<br>杀进程时不需要输入进程号。<br>htop 支持鼠标操作。<br>top 已经很老了。<br>htop 官网：<a href=\"http://htop.sourceforge.net/\">http://htop.sourceforge.net/</a></p>\n<p>二、htop 安装</p>\n<p>a. 源码包安装</p>\n<pre><code># tar zxvf htop-1.0.2.tar.gz\n\n# cd htop-1.0.2\n\n# ./configure\n</code></pre><p><img src=\"http://images.cnitblog.com/blog/370046/201301/12224043-10fbaaa4ef2d49ba844de4ff1df2cea2.jpg\" alt=\"\"></p>\n<pre><code># make &amp;&amp; make install\n</code></pre><p><img src=\"http://images.cnitblog.com/blog/370046/201301/12224044-8e70dd81c3594f14bf334dbf7ae12cda.jpg\" alt=\"\"></p>\n<p>若出现错误：</p>\n<pre><code>configure: error: You may want to use --disable-unicode or install libncursesw.\n</code></pre><p>则需安装 ncurses-devel</p>\n<pre><code># yum install ncurses-devel\n</code></pre><p>b. RHEL/CentOS 安装</p>\n<p>可以通过 yum install htop 来安装它，但前提是要添加epel 的yum源，具体请参考 CentOS yum 源的配置与使用。</p>\n<pre><code># rpm -ivh http://download.fedoraproject.org/pub/epel/5/i386/epel-release-5-4.noarch.rpm \n# rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL//导入key \n# yum install htop\n</code></pre><p>三、htop 参数</p>\n<p>键入htop 命令，打开htop。</p>\n<pre><code># htop\n</code></pre><p> <img src=\"http://images.cnitblog.com/blog/370046/201301/12224047-b6fd5270cea14cee87544ff3ca193b34.jpg\" alt=\"\"></p>\n<p>上面左上角显示CPU、内存、交换区的使用情况，右边显示任务、负载、开机时间，下面就是进程实时状况。</p>\n<p>下面是 F1~F10 的功能和对应的字母快捷键。</p>\n<hr>\n<p>Shortcut Key　　　　　　  　　 Function Ke　　　　　　  　　 Description　　　　　　 　　　　　　  　　  中文说明  </p>\n<p>h,?　　　　　　  　　　　　　　  　　   F1    　　　　　　  　　 Invoke htop Help　　　　　　  　　     　　　　　　查看htop使用说明<br>S    　　　　　　  　　 　　　　　　  　　F2　　　　　　  　　     Htop Setup Menu    htop　　　　　　  　　 　　　 设定<br>/    　　　　　　  　　 　　　　　　   　　  F3    　　　　　　  　　 Search for a Process    　　　　　　  　　　　　　 搜索进程<br>\\    　　　　　　  　　 　　　　　　  　　 F4    　　　　　　  　　 Incremental process filtering    　　　　　　  　　 增量进程过滤器<br>t    　　　　　　  　　 　　　　　　  　　 F5　　　　　　  　　     Tree View    　　　　　　  　　 　　　　　　  　　　 显示树形结构<br>&lt;, &gt;    　　　　　　  　　 　　　　　　  　F6    　　　　　　  　　 Sort by a column    　　　　　　  　　　　　　　　   选择排序方式<br>[    　　　　　　  　　 　　　　　　  　　 F7    　　　　　　  　　 Nice - (change priority)    　　　可减少nice值，这样就可以提高对应进程的优先级<br>]    　　　　　　  　　 　　　　　　  　　 F8    　　　　　　  　　 Nice + (change priority)    　　　可增加nice值，这样就可以降低对应进程的优先级<br>k    　　　　　　  　　 　　　　　　  　　 F9    　　　　　　  　　 Kill a Process    　　　　　　  　　 　　　　　　  　可对进程传递信号<br>q    　　　　　　  　　 　　　　　　  　　 F10    　　　　　　  　　 Quit htop    　　　　　　  　　 　　　　　　  　　 结束htop  </p>\n<hr>\n<p>命令行选项（COMMAND-LINE OPTIONS）</p>\n<p>-C –no-color　　　　 　　 使用一个单色的配色方案</p>\n<p>-d –delay=DELAY　　　　 设置延迟更新时间，单位秒</p>\n<p>-h –help　　　　　　  　　 显示htop 命令帮助信息</p>\n<p>-u –user=USERNAME　　  只显示一个给定的用户的过程</p>\n<p>-p –pid=PID,PID…　　　    只显示给定的PIDs</p>\n<p>-s –sort-key COLUMN　    依此列来排序</p>\n<p>-v –version　　　　　　　   显示版本信息</p>\n<p>交互式命令（INTERACTIVE COMMANDS）</p>\n<hr>\n<p>上下键或PgUP, PgDn 选定想要的进程，左右键或Home, End 移动字段，当然也可以直接用鼠标选定进程；</p>\n<p>Space    标记/取消标记一个进程。命令可以作用于多个进程，例如 “kill”，将应用于所有已标记的进程</p>\n<p>U    取消标记所有进程</p>\n<p>s    选择某一进程，按s:用strace追踪进程的系统调用</p>\n<p>l    显示进程打开的文件: 如果安装了lsof，按此键可以显示进程所打开的文件</p>\n<p>I    倒转排序顺序，如果排序是正序的，则反转成倒序的，反之亦然</p>\n<p>+, -    When in tree view mode, expand or collapse subtree. When a subtree is collapsed a “+” sign shows to the left of the process name.</p>\n<p>a (在有多处理器的机器上)    设置 CPU affinity: 标记一个进程允许使用哪些CPU</p>\n<p>u    显示特定用户进程</p>\n<p>M    按Memory 使用排序</p>\n<p>P    按CPU 使用排序</p>\n<p>T    按Time+ 使用排序</p>\n<p>F    跟踪进程: 如果排序顺序引起选定的进程在列表上到处移动，让选定条跟随该进程。这对监视一个进程非常有用：通过这种方式，你可以让一个进程在屏幕上一直可见。使用方向键会停止该功能。</p>\n<p>K    显示/隐藏内核线程</p>\n<p>H    显示/隐藏用户线程</p>\n<p>Ctrl-L    刷新</p>\n<p>Numbers    PID 查找: 输入PID，光标将移动到相应的进程上</p>\n<hr>\n<p>四、htop 使用</p>\n<p>4.1. 显示自带帮助</p>\n<p>鼠标点击Help或者按F1 显示自带帮助<br><img src=\"http://images.cnitblog.com/blog/370046/201301/12224049-575f66ab3d964c5cb419959aee9032b1.jpg\" alt=\"\"></p>\n<p>4.2. htop 设定</p>\n<p>鼠标点击Setup或者按下F2 之后进入htop 设定的页面，Meters 页面设定了顶端的一些信息显示，顶端的显示又分为左右两侧，到底能显示些什么可以在最右侧那栏新增，要新增到上方左侧（F5）或是右侧（F6）都可以，这就是个人设定的范围了。这里多加了一个时钟。</p>\n<p><img src=\"http://images.cnitblog.com/blog/370046/201301/12224051-9b4d728776d1499190c9d21ab3615f5a.jpg\" alt=\"\"></p>\n<p>上方左右两栏的显示方式分为Text Bar Graph Led 四种，下图我就把 cpu memory swap 改成文本模式显示，然后右栏的改成Bar 显示，clock 用LED方式显示。数据显示都差不多，只是这样看有点不习惯了。</p>\n<p><img src=\"http://images.cnitblog.com/blog/370046/201301/12224052-befc1e283e4c4576a59f89e6f72a4337.jpg\" alt=\"\"></p>\n<p>关于Display options 的设定，可要根据管理者自己的需要来设定。</p>\n<p><img src=\"http://images.cnitblog.com/blog/370046/201301/12224054-b8d7722ac20b421299bd0c72b3394198.jpg\" alt=\"\"></p>\n<p>颜色选择，除了基本的颜色显示之外，htop 还提供了换面板的功能，其实也只是改变一些色彩显示的设定，虽然说不能自定义到细部的颜色显示，但是至少提供了几种风格可以选择。</p>\n<p><img src=\"http://images.cnitblog.com/blog/370046/201301/12224055-b6a13eb2abaa45fab167e61a8db12356.jpg\" alt=\"\"></p>\n<p>最后一项的设定是调整 Columns 的显示，就是在一般htop 指令进来希望可以看到的什么样的数据及信息，字段的调整可以在这边做个人化的设定，一般使用系统默认值就好了。</p>\n<p><img src=\"http://images.cnitblog.com/blog/370046/201301/12224058-1ef4f726ccd64dfbaab68142dc9a95be.jpg\" alt=\"\"></p>\n<p>4.3. 搜索进程</p>\n<p>鼠标点击Search 或者按下F3 或者输入”/“， 输入进程名进行搜索，例如搜索ssh</p>\n<p><img src=\"http://images.cnitblog.com/blog/370046/201301/12224100-dab0040192b24614b44d1e28d1b4badb.jpg\" alt=\"\"></p>\n<p>4.4. 过滤器</p>\n<p>按下F4，进入过滤器，相当于关键字搜索，不区分大小写，例如过滤dev</p>\n<p><img src=\"http://images.cnitblog.com/blog/370046/201301/12224102-6339cac4da0b482097e1a5b218b523c4.jpg\" alt=\"\"></p>\n<p>4.5. 显示树形结构</p>\n<p>输入”t”或按下F5，显示树形结构，意思跟pstree 差不多，能看到所有程序树状执行的结构，这对于系统管理来说相当方便，理清程序是如何产生的，当然树状结构的浏览也可以依照其他数据来排序。</p>\n<p><img src=\"http://images.cnitblog.com/blog/370046/201301/12224104-f5d4a8c905cd4a83b262ad2e5944f3fe.jpg\" alt=\"\"></p>\n<p>4.6. 选择排序方式</p>\n<p>按下F6 就可以选择依照什么来排序，最常排序的内容就是cpu 和memory 吧！</p>\n<p><img src=\"http://images.cnitblog.com/blog/370046/201301/12224107-6a091d2523cd4829b243f635b1c32a0a.jpg\" alt=\"\"></p>\n<p>4.7 操作进程</p>\n<p>F7、F8分别对应nice-和nice+，F9对应kill给进程发信号，选好信号回车就OK了</p>\n<p><img src=\"http://images.cnitblog.com/blog/370046/201301/12224112-9dc1706a8dbd4972b78a78af34f75ec7.jpg\" alt=\"\"></p>\n<p>4.8. 显示某个用户的进程，在左侧选择用户</p>\n<p>输入”u”，在左侧选择用户</p>\n<p><img src=\"http://images.cnitblog.com/blog/370046/201301/12224115-289b4cf95c344dada4aa048c25f821ce.jpg\" alt=\"\"></p>\n<p>五、Alias top</p>\n<p>也许你用惯了top，我们也可以用top来打开htop。</p>\n<p>编辑/root/.bashrc文件，添加如下代码</p>\n<pre><code>if [ -f /usr/local/bin/htop ]; then\nalias top=’/usr/local/bin/htop’\nfi\n# source /root/.bashrc\n</code></pre>"},{"title":"keepalive+nginx实现高可用","date":"2016-09-02T04:00:00.000Z","_content":"1安装相应基础服务\n\n    yum install openssl-devel\n    yum install popt-devel\n2下载并安装keepalive安装包\n    wget http://www.keepalived.org/software/keepalived-1.2.12.tar.gz\n    tar xzf keepalived-1.2.12.tar.gz;\n    cd keepalived-1.2.12\n    ./configure –prefix=/usr/local/keepalived-1.2.12;\n    make && make install\n<!--more-->\n3制作keepalive服务\n    cp /usr/local/keepalived-1.2.12/etc/rc.d/init.d/keepalived /etc/init.d/\n    cp /usr/local/keepalived-1.2.12/etc/sysconfig/keepalived /etc/sysconfig/\n    chmod +x /etc/init.d/keepalived;\n    chkconfig –add keepalived;\n    mkdir -p /etc/keepalived\n    ln -s /usr/local/keepalived-1.2.12/sbin/keepalived /usr/sbin/\n    cp /usr/local/keepalived-1.2.12/etc/keepalived/keepalived.conf /etc/keepalived/\n    ln -s /usr/local/keepalived-1.2.12/sbin/keepalived /sbin/\n    service keepalived restart\n4更改keepalive的配置文件\n    vim /etc/keepalived/keepalived.conf\n    keepalive主\n    ! Configuration File for keepalived\n    \n    global_defs {\n    \n       router_id nginx_master\n    \n    }\n    \n    #监控服务.NGINX mysql等\n    \n    vrrp_script chk_nginx {\n    \n    script “/usr/local/nginx/check_nginx.sh”\n    \n    interval 2\n    \n    weight 2\n    \n    }\n    \n    vrrp_instance VI_1 {\n    \n    state MASTER\n    \n    interface eth0\n    \n    virtual_router_id 51   #通道\n    \n    priority 101#优先级，数值越高优先级越高\n    \n    advert_int 1\n    \n    authentication {\n    \n    auth_type PASS\n    \n    auth_pass 1111\n    \n    }\n    \n    virtual_ipaddress {\n    \n    192.168.1.254   #虚拟IP\n    \n    }\n    \n    track_script {\n    \n    chk_nginx  #检测脚本 上面配置的\n    \n    }\n\n \n\nkeepalive从\n\n    ! Configuration File for keepalived\n     \n    global_defs {\n       router_id nginx_backup\n    }\n    #监控服务.NGINX mysql等\n    vrrp_script chk_nginx {\n    script “/usr/local/nginx/check_nginx.sh”\n    interval 2\n    weight 2\n    }\n     \n    vrrp_instance VI_1 {\n    state BACKUP\n    interface eth0\n    virtual_router_id 51#通道\n    priority 99#优先级，数值越高优先级越高\n    advert_int 1\n    authentication {\n    auth_type PASS\n    auth_pass 1111\n    }\n    virtual_ipaddress {\n    192.168.1.254   #虚拟IP\n    }\n    track_script {\n    chk_nginx  #检测脚本 上面配置的\n    }\n    }\n5脚本/usr/local/nginx/check_nginx.sh”内容：\n    #!/bin/bash\n    \n    if [ “$(ps -ef | grep “nginx: master process“| grep -v grep )” == “” ]\n    \n    then\n    \n    /usr/local/nginx/sbin/nginx\n    \n    sleep 5\n    \n    if [ “$(ps -ef | grep “nginx: master process“| grep -v grep )” == “” ]\n    \n    then\n    \n    killall keepalived\n    \n    fi\n    \n    fi\n\n6编写keepalive和nginx共存脚本\n\n    vim /data/apps/jiance.sh\n    \n    #!/bin/bash\n    while :\n    do\n    nginxpid=`ps -C nginx –no-header |wc -l`\n    if [ $nginxpid -eq 0 ];then\n       /etc/init.d/nginx restart\n      sleep 5\n    nginxpid=`ps -C nginx –no-header |wc -l`\n      if [ $nginxpid -eq 0 ];then\n      /etc/init.d/keepalived stop\n      fi\n    fi\n    sleep 5\n    done\n    }\n7把该脚本制作成系统服务并且开机启动\n    chmod 755 /data/apps/jiance.sh\n    vim /etc/init.d/jiance\n    #!/bin/bash\n    # chkconfig: 2345 10 90\n    # description: jiance ….\n    start() {\n    echo “Starting my process “\n    cd /data/apps/\n    ./jiance.sh\n    }\n    stop() {\n    killall jiance.sh\n    echo “Stoped”\n    }\n    chmod a+wrx /etc/init.d/jiance\n    /etc/init.d/jiance start\n    chmod +x jiance   #增加执行权限\n    chkconfig –add jiance #把jiance添加到系统服务列表\n    chkconfig jiance on #设定jiance的开关（on/off）\n    chkconfig –list jiance   #就可以看到已经注册了jiance的服务\n完成如上步骤keepalive+nginx高可用即搭建完成。","source":"_posts/keepalive+nginx实现高可用.md","raw":"---\ntitle: keepalive+nginx实现高可用\ndate: 2016-09-02\ntags:\n---\n1安装相应基础服务\n\n    yum install openssl-devel\n    yum install popt-devel\n2下载并安装keepalive安装包\n    wget http://www.keepalived.org/software/keepalived-1.2.12.tar.gz\n    tar xzf keepalived-1.2.12.tar.gz;\n    cd keepalived-1.2.12\n    ./configure –prefix=/usr/local/keepalived-1.2.12;\n    make && make install\n<!--more-->\n3制作keepalive服务\n    cp /usr/local/keepalived-1.2.12/etc/rc.d/init.d/keepalived /etc/init.d/\n    cp /usr/local/keepalived-1.2.12/etc/sysconfig/keepalived /etc/sysconfig/\n    chmod +x /etc/init.d/keepalived;\n    chkconfig –add keepalived;\n    mkdir -p /etc/keepalived\n    ln -s /usr/local/keepalived-1.2.12/sbin/keepalived /usr/sbin/\n    cp /usr/local/keepalived-1.2.12/etc/keepalived/keepalived.conf /etc/keepalived/\n    ln -s /usr/local/keepalived-1.2.12/sbin/keepalived /sbin/\n    service keepalived restart\n4更改keepalive的配置文件\n    vim /etc/keepalived/keepalived.conf\n    keepalive主\n    ! Configuration File for keepalived\n    \n    global_defs {\n    \n       router_id nginx_master\n    \n    }\n    \n    #监控服务.NGINX mysql等\n    \n    vrrp_script chk_nginx {\n    \n    script “/usr/local/nginx/check_nginx.sh”\n    \n    interval 2\n    \n    weight 2\n    \n    }\n    \n    vrrp_instance VI_1 {\n    \n    state MASTER\n    \n    interface eth0\n    \n    virtual_router_id 51   #通道\n    \n    priority 101#优先级，数值越高优先级越高\n    \n    advert_int 1\n    \n    authentication {\n    \n    auth_type PASS\n    \n    auth_pass 1111\n    \n    }\n    \n    virtual_ipaddress {\n    \n    192.168.1.254   #虚拟IP\n    \n    }\n    \n    track_script {\n    \n    chk_nginx  #检测脚本 上面配置的\n    \n    }\n\n \n\nkeepalive从\n\n    ! Configuration File for keepalived\n     \n    global_defs {\n       router_id nginx_backup\n    }\n    #监控服务.NGINX mysql等\n    vrrp_script chk_nginx {\n    script “/usr/local/nginx/check_nginx.sh”\n    interval 2\n    weight 2\n    }\n     \n    vrrp_instance VI_1 {\n    state BACKUP\n    interface eth0\n    virtual_router_id 51#通道\n    priority 99#优先级，数值越高优先级越高\n    advert_int 1\n    authentication {\n    auth_type PASS\n    auth_pass 1111\n    }\n    virtual_ipaddress {\n    192.168.1.254   #虚拟IP\n    }\n    track_script {\n    chk_nginx  #检测脚本 上面配置的\n    }\n    }\n5脚本/usr/local/nginx/check_nginx.sh”内容：\n    #!/bin/bash\n    \n    if [ “$(ps -ef | grep “nginx: master process“| grep -v grep )” == “” ]\n    \n    then\n    \n    /usr/local/nginx/sbin/nginx\n    \n    sleep 5\n    \n    if [ “$(ps -ef | grep “nginx: master process“| grep -v grep )” == “” ]\n    \n    then\n    \n    killall keepalived\n    \n    fi\n    \n    fi\n\n6编写keepalive和nginx共存脚本\n\n    vim /data/apps/jiance.sh\n    \n    #!/bin/bash\n    while :\n    do\n    nginxpid=`ps -C nginx –no-header |wc -l`\n    if [ $nginxpid -eq 0 ];then\n       /etc/init.d/nginx restart\n      sleep 5\n    nginxpid=`ps -C nginx –no-header |wc -l`\n      if [ $nginxpid -eq 0 ];then\n      /etc/init.d/keepalived stop\n      fi\n    fi\n    sleep 5\n    done\n    }\n7把该脚本制作成系统服务并且开机启动\n    chmod 755 /data/apps/jiance.sh\n    vim /etc/init.d/jiance\n    #!/bin/bash\n    # chkconfig: 2345 10 90\n    # description: jiance ….\n    start() {\n    echo “Starting my process “\n    cd /data/apps/\n    ./jiance.sh\n    }\n    stop() {\n    killall jiance.sh\n    echo “Stoped”\n    }\n    chmod a+wrx /etc/init.d/jiance\n    /etc/init.d/jiance start\n    chmod +x jiance   #增加执行权限\n    chkconfig –add jiance #把jiance添加到系统服务列表\n    chkconfig jiance on #设定jiance的开关（on/off）\n    chkconfig –list jiance   #就可以看到已经注册了jiance的服务\n完成如上步骤keepalive+nginx高可用即搭建完成。","slug":"keepalive+nginx实现高可用","published":1,"updated":"2017-03-01T05:59:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizqklz7j0005lbpvl3ugon59","content":"<p>1安装相应基础服务</p>\n<pre><code>yum install openssl-devel\nyum install popt-devel\n</code></pre><p>2下载并安装keepalive安装包<br>    wget <a href=\"http://www.keepalived.org/software/keepalived-1.2.12.tar.gz\" target=\"_blank\" rel=\"external\">http://www.keepalived.org/software/keepalived-1.2.12.tar.gz</a><br>    tar xzf keepalived-1.2.12.tar.gz;<br>    cd keepalived-1.2.12<br>    ./configure –prefix=/usr/local/keepalived-1.2.12;<br>    make &amp;&amp; make install<br><a id=\"more\"></a><br>3制作keepalive服务<br>    cp /usr/local/keepalived-1.2.12/etc/rc.d/init.d/keepalived /etc/init.d/<br>    cp /usr/local/keepalived-1.2.12/etc/sysconfig/keepalived /etc/sysconfig/<br>    chmod +x /etc/init.d/keepalived;<br>    chkconfig –add keepalived;<br>    mkdir -p /etc/keepalived<br>    ln -s /usr/local/keepalived-1.2.12/sbin/keepalived /usr/sbin/<br>    cp /usr/local/keepalived-1.2.12/etc/keepalived/keepalived.conf /etc/keepalived/<br>    ln -s /usr/local/keepalived-1.2.12/sbin/keepalived /sbin/<br>    service keepalived restart<br>4更改keepalive的配置文件<br>    vim /etc/keepalived/keepalived.conf<br>    keepalive主<br>    ! Configuration File for keepalived</p>\n<pre><code>global_defs {\n\n   router_id nginx_master\n\n}\n\n#监控服务.NGINX mysql等\n\nvrrp_script chk_nginx {\n\nscript “/usr/local/nginx/check_nginx.sh”\n\ninterval 2\n\nweight 2\n\n}\n\nvrrp_instance VI_1 {\n\nstate MASTER\n\ninterface eth0\n\nvirtual_router_id 51   #通道\n\npriority 101#优先级，数值越高优先级越高\n\nadvert_int 1\n\nauthentication {\n\nauth_type PASS\n\nauth_pass 1111\n\n}\n\nvirtual_ipaddress {\n\n192.168.1.254   #虚拟IP\n\n}\n\ntrack_script {\n\nchk_nginx  #检测脚本 上面配置的\n\n}\n</code></pre><p>keepalive从</p>\n<pre><code>! Configuration File for keepalived\n\nglobal_defs {\n   router_id nginx_backup\n}\n#监控服务.NGINX mysql等\nvrrp_script chk_nginx {\nscript “/usr/local/nginx/check_nginx.sh”\ninterval 2\nweight 2\n}\n\nvrrp_instance VI_1 {\nstate BACKUP\ninterface eth0\nvirtual_router_id 51#通道\npriority 99#优先级，数值越高优先级越高\nadvert_int 1\nauthentication {\nauth_type PASS\nauth_pass 1111\n}\nvirtual_ipaddress {\n192.168.1.254   #虚拟IP\n}\ntrack_script {\nchk_nginx  #检测脚本 上面配置的\n}\n}\n</code></pre><p>5脚本/usr/local/nginx/check_nginx.sh”内容：</p>\n<pre><code>#!/bin/bash\n\nif [ “$(ps -ef | grep “nginx: master process“| grep -v grep )” == “” ]\n\nthen\n\n/usr/local/nginx/sbin/nginx\n\nsleep 5\n\nif [ “$(ps -ef | grep “nginx: master process“| grep -v grep )” == “” ]\n\nthen\n\nkillall keepalived\n\nfi\n\nfi\n</code></pre><p>6编写keepalive和nginx共存脚本</p>\n<pre><code>vim /data/apps/jiance.sh\n\n#!/bin/bash\nwhile :\ndo\nnginxpid=`ps -C nginx –no-header |wc -l`\nif [ $nginxpid -eq 0 ];then\n   /etc/init.d/nginx restart\n  sleep 5\nnginxpid=`ps -C nginx –no-header |wc -l`\n  if [ $nginxpid -eq 0 ];then\n  /etc/init.d/keepalived stop\n  fi\nfi\nsleep 5\ndone\n}\n</code></pre><p>7把该脚本制作成系统服务并且开机启动<br>    chmod 755 /data/apps/jiance.sh<br>    vim /etc/init.d/jiance</p>\n<pre><code>#!/bin/bash\n# chkconfig: 2345 10 90\n# description: jiance ….\nstart() {\necho “Starting my process “\ncd /data/apps/\n./jiance.sh\n}\nstop() {\nkillall jiance.sh\necho “Stoped”\n}\nchmod a+wrx /etc/init.d/jiance\n/etc/init.d/jiance start\nchmod +x jiance   #增加执行权限\nchkconfig –add jiance #把jiance添加到系统服务列表\nchkconfig jiance on #设定jiance的开关（on/off）\nchkconfig –list jiance   #就可以看到已经注册了jiance的服务\n</code></pre><p>完成如上步骤keepalive+nginx高可用即搭建完成。</p>\n","excerpt":"<p>1安装相应基础服务</p>\n<pre><code>yum install openssl-devel\nyum install popt-devel\n</code></pre><p>2下载并安装keepalive安装包<br>    wget <a href=\"http://www.keepalived.org/software/keepalived-1.2.12.tar.gz\">http://www.keepalived.org/software/keepalived-1.2.12.tar.gz</a><br>    tar xzf keepalived-1.2.12.tar.gz;<br>    cd keepalived-1.2.12<br>    ./configure –prefix=/usr/local/keepalived-1.2.12;<br>    make &amp;&amp; make install<br>","more":"<br>3制作keepalive服务<br>    cp /usr/local/keepalived-1.2.12/etc/rc.d/init.d/keepalived /etc/init.d/<br>    cp /usr/local/keepalived-1.2.12/etc/sysconfig/keepalived /etc/sysconfig/<br>    chmod +x /etc/init.d/keepalived;<br>    chkconfig –add keepalived;<br>    mkdir -p /etc/keepalived<br>    ln -s /usr/local/keepalived-1.2.12/sbin/keepalived /usr/sbin/<br>    cp /usr/local/keepalived-1.2.12/etc/keepalived/keepalived.conf /etc/keepalived/<br>    ln -s /usr/local/keepalived-1.2.12/sbin/keepalived /sbin/<br>    service keepalived restart<br>4更改keepalive的配置文件<br>    vim /etc/keepalived/keepalived.conf<br>    keepalive主<br>    ! Configuration File for keepalived</p>\n<pre><code>global_defs {\n\n   router_id nginx_master\n\n}\n\n#监控服务.NGINX mysql等\n\nvrrp_script chk_nginx {\n\nscript “/usr/local/nginx/check_nginx.sh”\n\ninterval 2\n\nweight 2\n\n}\n\nvrrp_instance VI_1 {\n\nstate MASTER\n\ninterface eth0\n\nvirtual_router_id 51   #通道\n\npriority 101#优先级，数值越高优先级越高\n\nadvert_int 1\n\nauthentication {\n\nauth_type PASS\n\nauth_pass 1111\n\n}\n\nvirtual_ipaddress {\n\n192.168.1.254   #虚拟IP\n\n}\n\ntrack_script {\n\nchk_nginx  #检测脚本 上面配置的\n\n}\n</code></pre><p>keepalive从</p>\n<pre><code>! Configuration File for keepalived\n\nglobal_defs {\n   router_id nginx_backup\n}\n#监控服务.NGINX mysql等\nvrrp_script chk_nginx {\nscript “/usr/local/nginx/check_nginx.sh”\ninterval 2\nweight 2\n}\n\nvrrp_instance VI_1 {\nstate BACKUP\ninterface eth0\nvirtual_router_id 51#通道\npriority 99#优先级，数值越高优先级越高\nadvert_int 1\nauthentication {\nauth_type PASS\nauth_pass 1111\n}\nvirtual_ipaddress {\n192.168.1.254   #虚拟IP\n}\ntrack_script {\nchk_nginx  #检测脚本 上面配置的\n}\n}\n</code></pre><p>5脚本/usr/local/nginx/check_nginx.sh”内容：</p>\n<pre><code>#!/bin/bash\n\nif [ “$(ps -ef | grep “nginx: master process“| grep -v grep )” == “” ]\n\nthen\n\n/usr/local/nginx/sbin/nginx\n\nsleep 5\n\nif [ “$(ps -ef | grep “nginx: master process“| grep -v grep )” == “” ]\n\nthen\n\nkillall keepalived\n\nfi\n\nfi\n</code></pre><p>6编写keepalive和nginx共存脚本</p>\n<pre><code>vim /data/apps/jiance.sh\n\n#!/bin/bash\nwhile :\ndo\nnginxpid=`ps -C nginx –no-header |wc -l`\nif [ $nginxpid -eq 0 ];then\n   /etc/init.d/nginx restart\n  sleep 5\nnginxpid=`ps -C nginx –no-header |wc -l`\n  if [ $nginxpid -eq 0 ];then\n  /etc/init.d/keepalived stop\n  fi\nfi\nsleep 5\ndone\n}\n</code></pre><p>7把该脚本制作成系统服务并且开机启动<br>    chmod 755 /data/apps/jiance.sh<br>    vim /etc/init.d/jiance</p>\n<pre><code>#!/bin/bash\n# chkconfig: 2345 10 90\n# description: jiance ….\nstart() {\necho “Starting my process “\ncd /data/apps/\n./jiance.sh\n}\nstop() {\nkillall jiance.sh\necho “Stoped”\n}\nchmod a+wrx /etc/init.d/jiance\n/etc/init.d/jiance start\nchmod +x jiance   #增加执行权限\nchkconfig –add jiance #把jiance添加到系统服务列表\nchkconfig jiance on #设定jiance的开关（on/off）\nchkconfig –list jiance   #就可以看到已经注册了jiance的服务\n</code></pre><p>完成如上步骤keepalive+nginx高可用即搭建完成。</p>"},{"title":"路由跟踪指令traceroute","date":"2016-11-03T04:00:00.000Z","_content":"通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的\n<!--more-->\nlinux系统中，我们称之为traceroute,在MS Windows中为tracert。 traceroute通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备traceroute要测3次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其IP地址。\n在大多数情况下，我们会在linux主机系统下，直接执行命令行：traceroute hostname\n而在Windows系统下是执行tracert的命令： tracert hostname\n1.命令格式：\ntraceroute[参数][主机]\n2.命令功能：\ntraceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。\n具体参数格式：traceroute [-dFlnrvx][-f<存活数值>][-g<网关>...][-i<网络界面>][-m<存活数值>][-p<通信端口>][-s<来源地址>][-t<服务类型>][-w<超时秒数>][主机名称或IP地址][数据包大小]\n3.命令参数：\n-d 使用Socket层级的排错功能。\n-f 设置第一个检测数据包的存活数值TTL的大小。\n-F 设置勿离断位。\n-g 设置来源路由网关，最多可设置8个。\n-i 使用指定的网络界面送出数据包。\n-I 使用ICMP回应取代UDP资料信息。\n-m 设置检测数据包的最大存活数值TTL的大小。\n-n 直接使用IP地址而非主机名称。\n-p 设置UDP传输协议的通信端口。\n-r 忽略普通的Routing Table，直接将数据包送到远端主机上。\n-s 设置本地主机送出数据包的IP地址。\n-t 设置检测数据包的TOS数值。\n-v 详细显示指令的执行过程。\n-w 设置等待远端主机回报的时间。\n-x 开启或关闭数据包的正确性检验。\n4.使用实例：\n实例1：traceroute 用法简单、最常用的用法\n命令：traceroute www.baidu.com \n输出：\n\n复制代码\n代码如下:\n\n[root@localhost ~]# traceroute www.baidu.com\ntraceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets\n1 192.168.74.2 (192.168.74.2) 2.606 ms 2.771 ms 2.950 ms\n2 211.151.56.57 (211.151.56.57) 0.596 ms 0.598 ms 0.591 ms\n3 211.151.227.206 (211.151.227.206) 0.546 ms 0.544 ms 0.538 ms\n4 210.77.139.145 (210.77.139.145) 0.710 ms 0.748 ms 0.801 ms\n5 202.106.42.101 (202.106.42.101) 6.759 ms 6.945 ms 7.107 ms\n6 61.148.154.97 (61.148.154.97) 718.908 ms * bt-228-025.bta.net.cn (202.106.228.25) 5.177 ms\n7 124.65.58.213 (124.65.58.213) 4.343 ms 4.336 ms 4.367 ms\n8 202.106.35.190 (202.106.35.190) 1.795 ms 61.148.156.138 (61.148.156.138) 1.899 ms 1.951 ms\n9 * * *\n30 * * *\n[root@localhost ~]# \n说明：\n记录按序列号从1开始，每个纪录就是一跳 ，每跳表示一个网关，我们看到每行有三个时间，单位是 ms，其实就是-q的默认参数。探测数据包向每个网关发送三个数据包后，网关响应后返回的时间；如果您用 traceroute -q 4 www.58.com ，表示向每个网关发送4个数据包。\n有时我们traceroute 一台主机时，会看到有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了ICMP的返回信息，所以我们得不到什么相关的数据包返回数据。\n有时我们在某一网关处延时比较长，有可能是某台网关比较阻塞，也可能是物理设备本身的原因。当然如果某台DNS出现问题时，不能解析主机名、域名时，也会 有延时长的现象；您可以加-n 参数来避免DNS解析，以IP格式输出数据。\n如果在局域网中的不同网段之间，我们可以通过traceroute 来排查问题所在，是主机的问题还是网关的问题。如果我们通过远程来访问某台服务器遇到问题时，我们用到traceroute 追踪数据包所经过的网关，提交IDC服务商，也有助于解决问题；但目前看来在国内解决这样的问题是比较困难的，就是我们发现问题所在，IDC服务商也不可能帮助我们解决。\n实例2：跳数设置\n命令：traceroute -m 10 www.baidu.com\n输出：\n\n复制代码\n代码如下:\n\n[root@localhost ~]# traceroute -m 10 www.baidu.com\ntraceroute to www.baidu.com (61.135.169.105), 10 hops max, 40 byte packets\n1 192.168.74.2 (192.168.74.2) 1.534 ms 1.775 ms 1.961 ms\n2 211.151.56.1 (211.151.56.1) 0.508 ms 0.514 ms 0.507 ms\n3 211.151.227.206 (211.151.227.206) 0.571 ms 0.558 ms 0.550 ms\n4 210.77.139.145 (210.77.139.145) 0.708 ms 0.729 ms 0.785 ms\n5 202.106.42.101 (202.106.42.101) 7.978 ms 8.155 ms 8.311 ms\n6 bt-228-037.bta.net.cn (202.106.228.37) 772.460 ms bt-228-025.bta.net.cn (202.106.228.25) 2.152 ms 61.148.154.97 (61.148.154.97) 772.107 ms\n7 124.65.58.221 (124.65.58.221) 4.875 ms 61.148.146.29 (61.148.146.29) 2.124 ms 124.65.58.221 (124.65.58.221) 4.854 ms\n8 123.126.6.198 (123.126.6.198) 2.944 ms 61.148.156.6 (61.148.156.6) 3.505 ms 123.126.6.198 (123.126.6.198) 2.885 ms\n9 * * *\n10 * * *\n[root@localhost ~]#\n\n \n实例3：显示IP地址，不查主机名\n命令：traceroute -n www.baidu.com\n输出：\n\n复制代码\n代码如下:\n\n[root@localhost ~]# traceroute -n www.baidu.com\ntraceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets\n1 211.151.74.2 5.430 ms 5.636 ms 5.802 ms\n2 211.151.56.57 0.627 ms 0.625 ms 0.617 ms\n3 211.151.227.206 0.575 ms 0.584 ms 0.576 ms\n4 210.77.139.145 0.703 ms 0.754 ms 0.806 ms\n5 202.106.42.101 23.683 ms 23.869 ms 23.998 ms\n6 202.106.228.37 247.101 ms * *\n7 61.148.146.29 5.256 ms 124.65.58.213 4.386 ms 4.373 ms\n8 202.106.35.190 1.610 ms 61.148.156.138 1.786 ms 61.148.3.34 2.089 ms\n9 * * *\n30 * * *\n[root@localhost ~]# traceroute www.baidu.com\ntraceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets\n1 211.151.74.2 (211.151.74.2) 4.671 ms 4.865 ms 5.055 ms\n2 211.151.56.57 (211.151.56.57) 0.619 ms 0.618 ms 0.612 ms\n3 211.151.227.206 (211.151.227.206) 0.620 ms 0.642 ms 0.636 ms\n4 210.77.139.145 (210.77.139.145) 0.720 ms 0.772 ms 0.816 ms\n5 202.106.42.101 (202.106.42.101) 7.667 ms 7.910 ms 8.012 ms\n6 bt-228-025.bta.net.cn (202.106.228.25) 2.965 ms 2.440 ms 61.148.154.97 (61.148.154.97) 431.337 ms\n7 124.65.58.213 (124.65.58.213) 5.134 ms 5.124 ms 5.044 ms\n8 202.106.35.190 (202.106.35.190) 1.917 ms 2.052 ms 2.059 ms\n9 * * *\n30 * * *\n[root@localhost ~]# \n实例4：探测包使用的基本UDP端口设置6888\n命令：traceroute -p 6888 www.baidu.com\n输出：\n\n复制代码\n代码如下:\n\n[root@localhost ~]# traceroute -p 6888 www.baidu.com\ntraceroute to www.baidu.com (220.181.111.147), 30 hops max, 40 byte packets\n1 211.151.74.2 (211.151.74.2) 4.927 ms 5.121 ms 5.298 ms\n2 211.151.56.1 (211.151.56.1) 0.500 ms 0.499 ms 0.509 ms\n3 211.151.224.90 (211.151.224.90) 0.637 ms 0.631 ms 0.641 ms\n4 * * *\n5 220.181.70.98 (220.181.70.98) 5.050 ms 5.313 ms 5.596 ms\n6 220.181.17.94 (220.181.17.94) 1.665 ms !X * *\n[root@localhost ~]# \n实例5：把探测包的个数设置为值4\n命令：traceroute -q 4 www.baidu.com\n输出：\n\n复制代码\n代码如下:\n\n[root@localhost ~]# traceroute -q 4 www.baidu.com\ntraceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets\n1 211.151.74.2 (211.151.74.2) 40.633 ms 40.819 ms 41.004 ms 41.188 ms\n2 211.151.56.57 (211.151.56.57) 0.637 ms 0.633 ms 0.627 ms 0.619 ms\n3 211.151.227.206 (211.151.227.206) 0.505 ms 0.580 ms 0.571 ms 0.569 ms\n4 210.77.139.145 (210.77.139.145) 0.753 ms 0.800 ms 0.853 ms 0.904 ms\n5 202.106.42.101 (202.106.42.101) 7.449 ms 7.543 ms 7.738 ms 7.893 ms\n6 61.148.154.97 (61.148.154.97) 316.817 ms bt-228-025.bta.net.cn (202.106.228.25) 3.695 ms 3.672 ms *\n7 124.65.58.213 (124.65.58.213) 3.056 ms 2.993 ms 2.960 ms 61.148.146.29 (61.148.146.29) 2.837 ms\n8 61.148.3.34 (61.148.3.34) 2.179 ms 2.295 ms 2.442 ms 202.106.35.190 (202.106.35.190) 7.136 ms\n9 * * * *\n30 * * * *\n[root@localhost ~]# \n\n实例6：绕过正常的路由表，直接发送到网络相连的主机\n命令：traceroute -r www.baidu.com\n输出：\n\n复制代码\n代码如下:\n\n[root@localhost ~]# traceroute -r www.baidu.com\ntraceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets\nconnect: 网络不可达\n[root@localhost ~]# \n实例7：把对外发探测包的等待响应时间设置为3秒\n命令：traceroute -w 3 www.baidu.com\n输出：\n\n复制代码\n代码如下:\n\n[root@localhost ~]# traceroute -w 3 www.baidu.com\ntraceroute to www.baidu.com (61.135.169.105), 30 hops max, 40 byte packets\n1 211.151.74.2 (211.151.74.2) 2.306 ms 2.469 ms 2.650 ms\n2 211.151.56.1 (211.151.56.1) 0.621 ms 0.613 ms 0.603 ms\n3 211.151.227.206 (211.151.227.206) 0.557 ms 0.560 ms 0.552 ms\n4 210.77.139.145 (210.77.139.145) 0.708 ms 0.761 ms 0.817 ms\n5 202.106.42.101 (202.106.42.101) 7.520 ms 7.774 ms 7.902 ms\n6 bt-228-025.bta.net.cn (202.106.228.25) 2.890 ms 2.369 ms 61.148.154.97 (61.148.154.97) 471.961 ms\n7 124.65.58.221 (124.65.58.221) 4.490 ms 4.483 ms 4.472 ms\n8 123.126.6.198 (123.126.6.198) 2.948 ms 61.148.156.6 (61.148.156.6) 7.688 ms 7.756 ms\n9 * * *\n30 * * *\n[root@localhost ~]# \n\nTraceroute的工作原理：\nTraceroute最简单的基本用法是：traceroute hostname\nTraceroute程序的设计是利用ICMP及IP header的TTL（Time To Live）栏位（field）。首先，traceroute送出一个TTL是1的IP datagram（其实，每次送出的为3个40字节的包，包括源地址，目的地址和包发出的时间标签）到目的地，当路径上的第一个路由器（router）收到这个datagram时，它将TTL减1。此时，TTL变为0了，所以该路由器会将此datagram丢掉，并送回一个「ICMP time exceeded」消息（包括发IP包的源地址，IP包的所有内容及路由器的IP地址），traceroute 收到这个消息后，便知道这个路由器存在于这个路径上，接着traceroute 再送出另一个TTL是2 的datagram，发现第2 个路由器...... traceroute 每次将送出的datagram的TTL 加1来发现另一个路由器，这个重复的动作一直持续到某个datagram 抵达目的地。当datagram到达目的地后，该主机并不会送回ICMP time exceeded消息，因为它已是目的地了，那么traceroute如何得知目的地到达了呢？\nTraceroute在送出UDP datagrams到目的地时，它所选择送达的port number 是一个一般应用程序都不会用的号码（30000 以上），所以当此UDP datagram 到达目的地后该主机会送回一个「ICMP port unreachable」的消息，而当traceroute 收到这个消息时，便知道目的地已经到达了。所以traceroute 在Server端也是没有所谓的Daemon 程式。\nTraceroute提取发 ICMP TTL到期消息设备的IP地址并作域名解析。每次 ，Traceroute都打印出一系列数据,包括所经过的路由设备的域名及 IP地址,三个包每次来回所花时间。\nwindows之tracert:\n格式：\ntracert [-d] [-h maximum_hops] [-j host-list] [-w timeout] target_name\n参数说明：\ntracert [-d] [-h maximum_hops] [-j computer-list] [-w timeout] target_name\n该诊断实用程序通过向目的地发送具有不同生存时间 (TL) 的 Internet 控制信息协议 (CMP) 回应报文，以确定至目的地的路由。路径上的每个路由器都要在转发该 ICMP 回应报文之前将其 TTL 值至少减 1，因此 TTL 是有效的跳转计数。当报文的 TTL 值减少到 0 时，路由器向源系统发回 ICMP 超时信息。通过发送 TTL 为 1 的第一个回应报文并且在随后的发送中每次将 TTL 值加 1，直到目标响应或达到最大 TTL 值，Tracert 可以确定路由。通过检查中间路由器发发回的 ICMP 超时 (ime Exceeded) 信息，可以确定路由器。注意，有些路由器“安静”地丢弃生存时间 (TLS) 过期的报文并且对 tracert 无效。\n参数：\n-d 指定不对计算机名解析地址。\n-h maximum_hops 指定查找目标的跳转的最大数目。\n-jcomputer-list 指定在 computer-list 中松散源路由。\n-w timeout 等待由 timeout 对每个应答指定的毫秒数。\ntarget_name 目标计算机的名称。\n实例：\n\n复制代码\n代码如下:\n\nC:\\Users\\Administrator>tracert www.58.com\nTracing route to www.58.com [221.187.111.30]\nover a maximum of 30 hops:\n1 1 ms 1 ms 1 ms 10.58.156.1\n2 1 ms <1 ms <1 ms 10.10.10.1\n3 1 ms 1 ms 1 ms 211.103.193.129\n4 2 ms 2 ms 2 ms 10.255.109.129\n5 1 ms 1 ms 3 ms 124.205.98.205\n6 2 ms 2 ms 2 ms 124.205.98.253\n7 2 ms 6 ms 1 ms 202.99.1.125\n8 5 ms 6 ms 5 ms 118.186.0.113\n9 207 ms * * 118.186.0.106\n10 8 ms 6 ms 11 ms 124.238.226.201\n11 6 ms 7 ms 6 ms 219.148.19.177\n12 12 ms 12 ms 16 ms 219.148.18.117\n13 14 ms 17 ms 16 ms 219.148.19.125\n14 13 ms 13 ms 12 ms 202.97.80.113\n15 * * * Request timed out.\n16 12 ms 12 ms 17 ms bj141-147-82.bjtelecom.net [219.141.147.82]\n17 13 ms 13 ms 12 ms 202.97.48.2\n18 * * * Request timed out.\n19 14 ms 14 ms 12 ms 221.187.224.85\n20 15 ms 13 ms 12 ms 221.187.104.2\n21 * * * Request timed out.\n22 15 ms 17 ms 18 ms 221.187.111.30\nTrace complete.","source":"_posts/linux traceroute 命令详解.md","raw":"---\ntitle: 路由跟踪指令traceroute\ndate: 2016-11-03\ntags:\n---\n通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的\n<!--more-->\nlinux系统中，我们称之为traceroute,在MS Windows中为tracert。 traceroute通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备traceroute要测3次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其IP地址。\n在大多数情况下，我们会在linux主机系统下，直接执行命令行：traceroute hostname\n而在Windows系统下是执行tracert的命令： tracert hostname\n1.命令格式：\ntraceroute[参数][主机]\n2.命令功能：\ntraceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。\n具体参数格式：traceroute [-dFlnrvx][-f<存活数值>][-g<网关>...][-i<网络界面>][-m<存活数值>][-p<通信端口>][-s<来源地址>][-t<服务类型>][-w<超时秒数>][主机名称或IP地址][数据包大小]\n3.命令参数：\n-d 使用Socket层级的排错功能。\n-f 设置第一个检测数据包的存活数值TTL的大小。\n-F 设置勿离断位。\n-g 设置来源路由网关，最多可设置8个。\n-i 使用指定的网络界面送出数据包。\n-I 使用ICMP回应取代UDP资料信息。\n-m 设置检测数据包的最大存活数值TTL的大小。\n-n 直接使用IP地址而非主机名称。\n-p 设置UDP传输协议的通信端口。\n-r 忽略普通的Routing Table，直接将数据包送到远端主机上。\n-s 设置本地主机送出数据包的IP地址。\n-t 设置检测数据包的TOS数值。\n-v 详细显示指令的执行过程。\n-w 设置等待远端主机回报的时间。\n-x 开启或关闭数据包的正确性检验。\n4.使用实例：\n实例1：traceroute 用法简单、最常用的用法\n命令：traceroute www.baidu.com \n输出：\n\n复制代码\n代码如下:\n\n[root@localhost ~]# traceroute www.baidu.com\ntraceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets\n1 192.168.74.2 (192.168.74.2) 2.606 ms 2.771 ms 2.950 ms\n2 211.151.56.57 (211.151.56.57) 0.596 ms 0.598 ms 0.591 ms\n3 211.151.227.206 (211.151.227.206) 0.546 ms 0.544 ms 0.538 ms\n4 210.77.139.145 (210.77.139.145) 0.710 ms 0.748 ms 0.801 ms\n5 202.106.42.101 (202.106.42.101) 6.759 ms 6.945 ms 7.107 ms\n6 61.148.154.97 (61.148.154.97) 718.908 ms * bt-228-025.bta.net.cn (202.106.228.25) 5.177 ms\n7 124.65.58.213 (124.65.58.213) 4.343 ms 4.336 ms 4.367 ms\n8 202.106.35.190 (202.106.35.190) 1.795 ms 61.148.156.138 (61.148.156.138) 1.899 ms 1.951 ms\n9 * * *\n30 * * *\n[root@localhost ~]# \n说明：\n记录按序列号从1开始，每个纪录就是一跳 ，每跳表示一个网关，我们看到每行有三个时间，单位是 ms，其实就是-q的默认参数。探测数据包向每个网关发送三个数据包后，网关响应后返回的时间；如果您用 traceroute -q 4 www.58.com ，表示向每个网关发送4个数据包。\n有时我们traceroute 一台主机时，会看到有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了ICMP的返回信息，所以我们得不到什么相关的数据包返回数据。\n有时我们在某一网关处延时比较长，有可能是某台网关比较阻塞，也可能是物理设备本身的原因。当然如果某台DNS出现问题时，不能解析主机名、域名时，也会 有延时长的现象；您可以加-n 参数来避免DNS解析，以IP格式输出数据。\n如果在局域网中的不同网段之间，我们可以通过traceroute 来排查问题所在，是主机的问题还是网关的问题。如果我们通过远程来访问某台服务器遇到问题时，我们用到traceroute 追踪数据包所经过的网关，提交IDC服务商，也有助于解决问题；但目前看来在国内解决这样的问题是比较困难的，就是我们发现问题所在，IDC服务商也不可能帮助我们解决。\n实例2：跳数设置\n命令：traceroute -m 10 www.baidu.com\n输出：\n\n复制代码\n代码如下:\n\n[root@localhost ~]# traceroute -m 10 www.baidu.com\ntraceroute to www.baidu.com (61.135.169.105), 10 hops max, 40 byte packets\n1 192.168.74.2 (192.168.74.2) 1.534 ms 1.775 ms 1.961 ms\n2 211.151.56.1 (211.151.56.1) 0.508 ms 0.514 ms 0.507 ms\n3 211.151.227.206 (211.151.227.206) 0.571 ms 0.558 ms 0.550 ms\n4 210.77.139.145 (210.77.139.145) 0.708 ms 0.729 ms 0.785 ms\n5 202.106.42.101 (202.106.42.101) 7.978 ms 8.155 ms 8.311 ms\n6 bt-228-037.bta.net.cn (202.106.228.37) 772.460 ms bt-228-025.bta.net.cn (202.106.228.25) 2.152 ms 61.148.154.97 (61.148.154.97) 772.107 ms\n7 124.65.58.221 (124.65.58.221) 4.875 ms 61.148.146.29 (61.148.146.29) 2.124 ms 124.65.58.221 (124.65.58.221) 4.854 ms\n8 123.126.6.198 (123.126.6.198) 2.944 ms 61.148.156.6 (61.148.156.6) 3.505 ms 123.126.6.198 (123.126.6.198) 2.885 ms\n9 * * *\n10 * * *\n[root@localhost ~]#\n\n \n实例3：显示IP地址，不查主机名\n命令：traceroute -n www.baidu.com\n输出：\n\n复制代码\n代码如下:\n\n[root@localhost ~]# traceroute -n www.baidu.com\ntraceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets\n1 211.151.74.2 5.430 ms 5.636 ms 5.802 ms\n2 211.151.56.57 0.627 ms 0.625 ms 0.617 ms\n3 211.151.227.206 0.575 ms 0.584 ms 0.576 ms\n4 210.77.139.145 0.703 ms 0.754 ms 0.806 ms\n5 202.106.42.101 23.683 ms 23.869 ms 23.998 ms\n6 202.106.228.37 247.101 ms * *\n7 61.148.146.29 5.256 ms 124.65.58.213 4.386 ms 4.373 ms\n8 202.106.35.190 1.610 ms 61.148.156.138 1.786 ms 61.148.3.34 2.089 ms\n9 * * *\n30 * * *\n[root@localhost ~]# traceroute www.baidu.com\ntraceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets\n1 211.151.74.2 (211.151.74.2) 4.671 ms 4.865 ms 5.055 ms\n2 211.151.56.57 (211.151.56.57) 0.619 ms 0.618 ms 0.612 ms\n3 211.151.227.206 (211.151.227.206) 0.620 ms 0.642 ms 0.636 ms\n4 210.77.139.145 (210.77.139.145) 0.720 ms 0.772 ms 0.816 ms\n5 202.106.42.101 (202.106.42.101) 7.667 ms 7.910 ms 8.012 ms\n6 bt-228-025.bta.net.cn (202.106.228.25) 2.965 ms 2.440 ms 61.148.154.97 (61.148.154.97) 431.337 ms\n7 124.65.58.213 (124.65.58.213) 5.134 ms 5.124 ms 5.044 ms\n8 202.106.35.190 (202.106.35.190) 1.917 ms 2.052 ms 2.059 ms\n9 * * *\n30 * * *\n[root@localhost ~]# \n实例4：探测包使用的基本UDP端口设置6888\n命令：traceroute -p 6888 www.baidu.com\n输出：\n\n复制代码\n代码如下:\n\n[root@localhost ~]# traceroute -p 6888 www.baidu.com\ntraceroute to www.baidu.com (220.181.111.147), 30 hops max, 40 byte packets\n1 211.151.74.2 (211.151.74.2) 4.927 ms 5.121 ms 5.298 ms\n2 211.151.56.1 (211.151.56.1) 0.500 ms 0.499 ms 0.509 ms\n3 211.151.224.90 (211.151.224.90) 0.637 ms 0.631 ms 0.641 ms\n4 * * *\n5 220.181.70.98 (220.181.70.98) 5.050 ms 5.313 ms 5.596 ms\n6 220.181.17.94 (220.181.17.94) 1.665 ms !X * *\n[root@localhost ~]# \n实例5：把探测包的个数设置为值4\n命令：traceroute -q 4 www.baidu.com\n输出：\n\n复制代码\n代码如下:\n\n[root@localhost ~]# traceroute -q 4 www.baidu.com\ntraceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets\n1 211.151.74.2 (211.151.74.2) 40.633 ms 40.819 ms 41.004 ms 41.188 ms\n2 211.151.56.57 (211.151.56.57) 0.637 ms 0.633 ms 0.627 ms 0.619 ms\n3 211.151.227.206 (211.151.227.206) 0.505 ms 0.580 ms 0.571 ms 0.569 ms\n4 210.77.139.145 (210.77.139.145) 0.753 ms 0.800 ms 0.853 ms 0.904 ms\n5 202.106.42.101 (202.106.42.101) 7.449 ms 7.543 ms 7.738 ms 7.893 ms\n6 61.148.154.97 (61.148.154.97) 316.817 ms bt-228-025.bta.net.cn (202.106.228.25) 3.695 ms 3.672 ms *\n7 124.65.58.213 (124.65.58.213) 3.056 ms 2.993 ms 2.960 ms 61.148.146.29 (61.148.146.29) 2.837 ms\n8 61.148.3.34 (61.148.3.34) 2.179 ms 2.295 ms 2.442 ms 202.106.35.190 (202.106.35.190) 7.136 ms\n9 * * * *\n30 * * * *\n[root@localhost ~]# \n\n实例6：绕过正常的路由表，直接发送到网络相连的主机\n命令：traceroute -r www.baidu.com\n输出：\n\n复制代码\n代码如下:\n\n[root@localhost ~]# traceroute -r www.baidu.com\ntraceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets\nconnect: 网络不可达\n[root@localhost ~]# \n实例7：把对外发探测包的等待响应时间设置为3秒\n命令：traceroute -w 3 www.baidu.com\n输出：\n\n复制代码\n代码如下:\n\n[root@localhost ~]# traceroute -w 3 www.baidu.com\ntraceroute to www.baidu.com (61.135.169.105), 30 hops max, 40 byte packets\n1 211.151.74.2 (211.151.74.2) 2.306 ms 2.469 ms 2.650 ms\n2 211.151.56.1 (211.151.56.1) 0.621 ms 0.613 ms 0.603 ms\n3 211.151.227.206 (211.151.227.206) 0.557 ms 0.560 ms 0.552 ms\n4 210.77.139.145 (210.77.139.145) 0.708 ms 0.761 ms 0.817 ms\n5 202.106.42.101 (202.106.42.101) 7.520 ms 7.774 ms 7.902 ms\n6 bt-228-025.bta.net.cn (202.106.228.25) 2.890 ms 2.369 ms 61.148.154.97 (61.148.154.97) 471.961 ms\n7 124.65.58.221 (124.65.58.221) 4.490 ms 4.483 ms 4.472 ms\n8 123.126.6.198 (123.126.6.198) 2.948 ms 61.148.156.6 (61.148.156.6) 7.688 ms 7.756 ms\n9 * * *\n30 * * *\n[root@localhost ~]# \n\nTraceroute的工作原理：\nTraceroute最简单的基本用法是：traceroute hostname\nTraceroute程序的设计是利用ICMP及IP header的TTL（Time To Live）栏位（field）。首先，traceroute送出一个TTL是1的IP datagram（其实，每次送出的为3个40字节的包，包括源地址，目的地址和包发出的时间标签）到目的地，当路径上的第一个路由器（router）收到这个datagram时，它将TTL减1。此时，TTL变为0了，所以该路由器会将此datagram丢掉，并送回一个「ICMP time exceeded」消息（包括发IP包的源地址，IP包的所有内容及路由器的IP地址），traceroute 收到这个消息后，便知道这个路由器存在于这个路径上，接着traceroute 再送出另一个TTL是2 的datagram，发现第2 个路由器...... traceroute 每次将送出的datagram的TTL 加1来发现另一个路由器，这个重复的动作一直持续到某个datagram 抵达目的地。当datagram到达目的地后，该主机并不会送回ICMP time exceeded消息，因为它已是目的地了，那么traceroute如何得知目的地到达了呢？\nTraceroute在送出UDP datagrams到目的地时，它所选择送达的port number 是一个一般应用程序都不会用的号码（30000 以上），所以当此UDP datagram 到达目的地后该主机会送回一个「ICMP port unreachable」的消息，而当traceroute 收到这个消息时，便知道目的地已经到达了。所以traceroute 在Server端也是没有所谓的Daemon 程式。\nTraceroute提取发 ICMP TTL到期消息设备的IP地址并作域名解析。每次 ，Traceroute都打印出一系列数据,包括所经过的路由设备的域名及 IP地址,三个包每次来回所花时间。\nwindows之tracert:\n格式：\ntracert [-d] [-h maximum_hops] [-j host-list] [-w timeout] target_name\n参数说明：\ntracert [-d] [-h maximum_hops] [-j computer-list] [-w timeout] target_name\n该诊断实用程序通过向目的地发送具有不同生存时间 (TL) 的 Internet 控制信息协议 (CMP) 回应报文，以确定至目的地的路由。路径上的每个路由器都要在转发该 ICMP 回应报文之前将其 TTL 值至少减 1，因此 TTL 是有效的跳转计数。当报文的 TTL 值减少到 0 时，路由器向源系统发回 ICMP 超时信息。通过发送 TTL 为 1 的第一个回应报文并且在随后的发送中每次将 TTL 值加 1，直到目标响应或达到最大 TTL 值，Tracert 可以确定路由。通过检查中间路由器发发回的 ICMP 超时 (ime Exceeded) 信息，可以确定路由器。注意，有些路由器“安静”地丢弃生存时间 (TLS) 过期的报文并且对 tracert 无效。\n参数：\n-d 指定不对计算机名解析地址。\n-h maximum_hops 指定查找目标的跳转的最大数目。\n-jcomputer-list 指定在 computer-list 中松散源路由。\n-w timeout 等待由 timeout 对每个应答指定的毫秒数。\ntarget_name 目标计算机的名称。\n实例：\n\n复制代码\n代码如下:\n\nC:\\Users\\Administrator>tracert www.58.com\nTracing route to www.58.com [221.187.111.30]\nover a maximum of 30 hops:\n1 1 ms 1 ms 1 ms 10.58.156.1\n2 1 ms <1 ms <1 ms 10.10.10.1\n3 1 ms 1 ms 1 ms 211.103.193.129\n4 2 ms 2 ms 2 ms 10.255.109.129\n5 1 ms 1 ms 3 ms 124.205.98.205\n6 2 ms 2 ms 2 ms 124.205.98.253\n7 2 ms 6 ms 1 ms 202.99.1.125\n8 5 ms 6 ms 5 ms 118.186.0.113\n9 207 ms * * 118.186.0.106\n10 8 ms 6 ms 11 ms 124.238.226.201\n11 6 ms 7 ms 6 ms 219.148.19.177\n12 12 ms 12 ms 16 ms 219.148.18.117\n13 14 ms 17 ms 16 ms 219.148.19.125\n14 13 ms 13 ms 12 ms 202.97.80.113\n15 * * * Request timed out.\n16 12 ms 12 ms 17 ms bj141-147-82.bjtelecom.net [219.141.147.82]\n17 13 ms 13 ms 12 ms 202.97.48.2\n18 * * * Request timed out.\n19 14 ms 14 ms 12 ms 221.187.224.85\n20 15 ms 13 ms 12 ms 221.187.104.2\n21 * * * Request timed out.\n22 15 ms 17 ms 18 ms 221.187.111.30\nTrace complete.","slug":"linux traceroute 命令详解","published":1,"updated":"2017-03-01T05:59:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizqklz7p0006lbpvsmqy36sw","content":"<p>通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的<br><a id=\"more\"></a><br>linux系统中，我们称之为traceroute,在MS Windows中为tracert。 traceroute通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备traceroute要测3次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其IP地址。<br>在大多数情况下，我们会在linux主机系统下，直接执行命令行：traceroute hostname<br>而在Windows系统下是执行tracert的命令： tracert hostname<br>1.命令格式：<br>traceroute[参数][主机]<br>2.命令功能：<br>traceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。<br>具体参数格式：traceroute [-dFlnrvx][-f&lt;存活数值&gt;][-g&lt;网关&gt;…][-i&lt;网络界面&gt;][-m&lt;存活数值&gt;][-p&lt;通信端口&gt;][-s&lt;来源地址&gt;][-t&lt;服务类型&gt;][-w&lt;超时秒数&gt;][主机名称或IP地址][数据包大小]<br>3.命令参数：<br>-d 使用Socket层级的排错功能。<br>-f 设置第一个检测数据包的存活数值TTL的大小。<br>-F 设置勿离断位。<br>-g 设置来源路由网关，最多可设置8个。<br>-i 使用指定的网络界面送出数据包。<br>-I 使用ICMP回应取代UDP资料信息。<br>-m 设置检测数据包的最大存活数值TTL的大小。<br>-n 直接使用IP地址而非主机名称。<br>-p 设置UDP传输协议的通信端口。<br>-r 忽略普通的Routing Table，直接将数据包送到远端主机上。<br>-s 设置本地主机送出数据包的IP地址。<br>-t 设置检测数据包的TOS数值。<br>-v 详细显示指令的执行过程。<br>-w 设置等待远端主机回报的时间。<br>-x 开启或关闭数据包的正确性检验。<br>4.使用实例：<br>实例1：traceroute 用法简单、最常用的用法<br>命令：traceroute www.baidu.com<br>输出：</p>\n<p>复制代码<br>代码如下:</p>\n<p>[root@localhost ~]# traceroute www.baidu.com<br>traceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets<br>1 192.168.74.2 (192.168.74.2) 2.606 ms 2.771 ms 2.950 ms<br>2 211.151.56.57 (211.151.56.57) 0.596 ms 0.598 ms 0.591 ms<br>3 211.151.227.206 (211.151.227.206) 0.546 ms 0.544 ms 0.538 ms<br>4 210.77.139.145 (210.77.139.145) 0.710 ms 0.748 ms 0.801 ms<br>5 202.106.42.101 (202.106.42.101) 6.759 ms 6.945 ms 7.107 ms<br>6 61.148.154.97 (61.148.154.97) 718.908 ms <em> bt-228-025.bta.net.cn (202.106.228.25) 5.177 ms<br>7 124.65.58.213 (124.65.58.213) 4.343 ms 4.336 ms 4.367 ms<br>8 202.106.35.190 (202.106.35.190) 1.795 ms 61.148.156.138 (61.148.156.138) 1.899 ms 1.951 ms<br>9 </em> <em> </em><br>30 <em> </em> *<br>[root@localhost ~]#<br>说明：<br>记录按序列号从1开始，每个纪录就是一跳 ，每跳表示一个网关，我们看到每行有三个时间，单位是 ms，其实就是-q的默认参数。探测数据包向每个网关发送三个数据包后，网关响应后返回的时间；如果您用 traceroute -q 4 www.58.com ，表示向每个网关发送4个数据包。<br>有时我们traceroute 一台主机时，会看到有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了ICMP的返回信息，所以我们得不到什么相关的数据包返回数据。<br>有时我们在某一网关处延时比较长，有可能是某台网关比较阻塞，也可能是物理设备本身的原因。当然如果某台DNS出现问题时，不能解析主机名、域名时，也会 有延时长的现象；您可以加-n 参数来避免DNS解析，以IP格式输出数据。<br>如果在局域网中的不同网段之间，我们可以通过traceroute 来排查问题所在，是主机的问题还是网关的问题。如果我们通过远程来访问某台服务器遇到问题时，我们用到traceroute 追踪数据包所经过的网关，提交IDC服务商，也有助于解决问题；但目前看来在国内解决这样的问题是比较困难的，就是我们发现问题所在，IDC服务商也不可能帮助我们解决。<br>实例2：跳数设置<br>命令：traceroute -m 10 www.baidu.com<br>输出：</p>\n<p>复制代码<br>代码如下:</p>\n<p>[root@localhost ~]# traceroute -m 10 www.baidu.com<br>traceroute to www.baidu.com (61.135.169.105), 10 hops max, 40 byte packets<br>1 192.168.74.2 (192.168.74.2) 1.534 ms 1.775 ms 1.961 ms<br>2 211.151.56.1 (211.151.56.1) 0.508 ms 0.514 ms 0.507 ms<br>3 211.151.227.206 (211.151.227.206) 0.571 ms 0.558 ms 0.550 ms<br>4 210.77.139.145 (210.77.139.145) 0.708 ms 0.729 ms 0.785 ms<br>5 202.106.42.101 (202.106.42.101) 7.978 ms 8.155 ms 8.311 ms<br>6 bt-228-037.bta.net.cn (202.106.228.37) 772.460 ms bt-228-025.bta.net.cn (202.106.228.25) 2.152 ms 61.148.154.97 (61.148.154.97) 772.107 ms<br>7 124.65.58.221 (124.65.58.221) 4.875 ms 61.148.146.29 (61.148.146.29) 2.124 ms 124.65.58.221 (124.65.58.221) 4.854 ms<br>8 123.126.6.198 (123.126.6.198) 2.944 ms 61.148.156.6 (61.148.156.6) 3.505 ms 123.126.6.198 (123.126.6.198) 2.885 ms<br>9 <em> </em> <em><br>10 </em> <em> </em><br>[root@localhost ~]#</p>\n<p>实例3：显示IP地址，不查主机名<br>命令：traceroute -n www.baidu.com<br>输出：</p>\n<p>复制代码<br>代码如下:</p>\n<p>[root@localhost ~]# traceroute -n www.baidu.com<br>traceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets<br>1 211.151.74.2 5.430 ms 5.636 ms 5.802 ms<br>2 211.151.56.57 0.627 ms 0.625 ms 0.617 ms<br>3 211.151.227.206 0.575 ms 0.584 ms 0.576 ms<br>4 210.77.139.145 0.703 ms 0.754 ms 0.806 ms<br>5 202.106.42.101 23.683 ms 23.869 ms 23.998 ms<br>6 202.106.228.37 247.101 ms <em> </em><br>7 61.148.146.29 5.256 ms 124.65.58.213 4.386 ms 4.373 ms<br>8 202.106.35.190 1.610 ms 61.148.156.138 1.786 ms 61.148.3.34 2.089 ms<br>9 <em> </em> <em><br>30 </em> <em> </em><br>[root@localhost ~]# traceroute www.baidu.com<br>traceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets<br>1 211.151.74.2 (211.151.74.2) 4.671 ms 4.865 ms 5.055 ms<br>2 211.151.56.57 (211.151.56.57) 0.619 ms 0.618 ms 0.612 ms<br>3 211.151.227.206 (211.151.227.206) 0.620 ms 0.642 ms 0.636 ms<br>4 210.77.139.145 (210.77.139.145) 0.720 ms 0.772 ms 0.816 ms<br>5 202.106.42.101 (202.106.42.101) 7.667 ms 7.910 ms 8.012 ms<br>6 bt-228-025.bta.net.cn (202.106.228.25) 2.965 ms 2.440 ms 61.148.154.97 (61.148.154.97) 431.337 ms<br>7 124.65.58.213 (124.65.58.213) 5.134 ms 5.124 ms 5.044 ms<br>8 202.106.35.190 (202.106.35.190) 1.917 ms 2.052 ms 2.059 ms<br>9 <em> </em> <em><br>30 </em> <em> </em><br>[root@localhost ~]#<br>实例4：探测包使用的基本UDP端口设置6888<br>命令：traceroute -p 6888 www.baidu.com<br>输出：</p>\n<p>复制代码<br>代码如下:</p>\n<p>[root@localhost ~]# traceroute -p 6888 www.baidu.com<br>traceroute to www.baidu.com (220.181.111.147), 30 hops max, 40 byte packets<br>1 211.151.74.2 (211.151.74.2) 4.927 ms 5.121 ms 5.298 ms<br>2 211.151.56.1 (211.151.56.1) 0.500 ms 0.499 ms 0.509 ms<br>3 211.151.224.90 (211.151.224.90) 0.637 ms 0.631 ms 0.641 ms<br>4 <em> </em> <em><br>5 220.181.70.98 (220.181.70.98) 5.050 ms 5.313 ms 5.596 ms<br>6 220.181.17.94 (220.181.17.94) 1.665 ms !X </em> *<br>[root@localhost ~]#<br>实例5：把探测包的个数设置为值4<br>命令：traceroute -q 4 www.baidu.com<br>输出：</p>\n<p>复制代码<br>代码如下:</p>\n<p>[root@localhost ~]# traceroute -q 4 www.baidu.com<br>traceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets<br>1 211.151.74.2 (211.151.74.2) 40.633 ms 40.819 ms 41.004 ms 41.188 ms<br>2 211.151.56.57 (211.151.56.57) 0.637 ms 0.633 ms 0.627 ms 0.619 ms<br>3 211.151.227.206 (211.151.227.206) 0.505 ms 0.580 ms 0.571 ms 0.569 ms<br>4 210.77.139.145 (210.77.139.145) 0.753 ms 0.800 ms 0.853 ms 0.904 ms<br>5 202.106.42.101 (202.106.42.101) 7.449 ms 7.543 ms 7.738 ms 7.893 ms<br>6 61.148.154.97 (61.148.154.97) 316.817 ms bt-228-025.bta.net.cn (202.106.228.25) 3.695 ms 3.672 ms <em><br>7 124.65.58.213 (124.65.58.213) 3.056 ms 2.993 ms 2.960 ms 61.148.146.29 (61.148.146.29) 2.837 ms<br>8 61.148.3.34 (61.148.3.34) 2.179 ms 2.295 ms 2.442 ms 202.106.35.190 (202.106.35.190) 7.136 ms<br>9 </em> <em> </em> <em><br>30 </em> <em> </em> *<br>[root@localhost ~]# </p>\n<p>实例6：绕过正常的路由表，直接发送到网络相连的主机<br>命令：traceroute -r www.baidu.com<br>输出：</p>\n<p>复制代码<br>代码如下:</p>\n<p>[root@localhost ~]# traceroute -r www.baidu.com<br>traceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets<br>connect: 网络不可达<br>[root@localhost ~]#<br>实例7：把对外发探测包的等待响应时间设置为3秒<br>命令：traceroute -w 3 www.baidu.com<br>输出：</p>\n<p>复制代码<br>代码如下:</p>\n<p>[root@localhost ~]# traceroute -w 3 www.baidu.com<br>traceroute to www.baidu.com (61.135.169.105), 30 hops max, 40 byte packets<br>1 211.151.74.2 (211.151.74.2) 2.306 ms 2.469 ms 2.650 ms<br>2 211.151.56.1 (211.151.56.1) 0.621 ms 0.613 ms 0.603 ms<br>3 211.151.227.206 (211.151.227.206) 0.557 ms 0.560 ms 0.552 ms<br>4 210.77.139.145 (210.77.139.145) 0.708 ms 0.761 ms 0.817 ms<br>5 202.106.42.101 (202.106.42.101) 7.520 ms 7.774 ms 7.902 ms<br>6 bt-228-025.bta.net.cn (202.106.228.25) 2.890 ms 2.369 ms 61.148.154.97 (61.148.154.97) 471.961 ms<br>7 124.65.58.221 (124.65.58.221) 4.490 ms 4.483 ms 4.472 ms<br>8 123.126.6.198 (123.126.6.198) 2.948 ms 61.148.156.6 (61.148.156.6) 7.688 ms 7.756 ms<br>9 <em> </em> <em><br>30 </em> <em> </em><br>[root@localhost ~]# </p>\n<p>Traceroute的工作原理：<br>Traceroute最简单的基本用法是：traceroute hostname<br>Traceroute程序的设计是利用ICMP及IP header的TTL（Time To Live）栏位（field）。首先，traceroute送出一个TTL是1的IP datagram（其实，每次送出的为3个40字节的包，包括源地址，目的地址和包发出的时间标签）到目的地，当路径上的第一个路由器（router）收到这个datagram时，它将TTL减1。此时，TTL变为0了，所以该路由器会将此datagram丢掉，并送回一个「ICMP time exceeded」消息（包括发IP包的源地址，IP包的所有内容及路由器的IP地址），traceroute 收到这个消息后，便知道这个路由器存在于这个路径上，接着traceroute 再送出另一个TTL是2 的datagram，发现第2 个路由器…… traceroute 每次将送出的datagram的TTL 加1来发现另一个路由器，这个重复的动作一直持续到某个datagram 抵达目的地。当datagram到达目的地后，该主机并不会送回ICMP time exceeded消息，因为它已是目的地了，那么traceroute如何得知目的地到达了呢？<br>Traceroute在送出UDP datagrams到目的地时，它所选择送达的port number 是一个一般应用程序都不会用的号码（30000 以上），所以当此UDP datagram 到达目的地后该主机会送回一个「ICMP port unreachable」的消息，而当traceroute 收到这个消息时，便知道目的地已经到达了。所以traceroute 在Server端也是没有所谓的Daemon 程式。<br>Traceroute提取发 ICMP TTL到期消息设备的IP地址并作域名解析。每次 ，Traceroute都打印出一系列数据,包括所经过的路由设备的域名及 IP地址,三个包每次来回所花时间。<br>windows之tracert:<br>格式：<br>tracert [-d] [-h maximum_hops] [-j host-list] [-w timeout] target_name<br>参数说明：<br>tracert [-d] [-h maximum_hops] [-j computer-list] [-w timeout] target_name<br>该诊断实用程序通过向目的地发送具有不同生存时间 (TL) 的 Internet 控制信息协议 (CMP) 回应报文，以确定至目的地的路由。路径上的每个路由器都要在转发该 ICMP 回应报文之前将其 TTL 值至少减 1，因此 TTL 是有效的跳转计数。当报文的 TTL 值减少到 0 时，路由器向源系统发回 ICMP 超时信息。通过发送 TTL 为 1 的第一个回应报文并且在随后的发送中每次将 TTL 值加 1，直到目标响应或达到最大 TTL 值，Tracert 可以确定路由。通过检查中间路由器发发回的 ICMP 超时 (ime Exceeded) 信息，可以确定路由器。注意，有些路由器“安静”地丢弃生存时间 (TLS) 过期的报文并且对 tracert 无效。<br>参数：<br>-d 指定不对计算机名解析地址。<br>-h maximum_hops 指定查找目标的跳转的最大数目。<br>-jcomputer-list 指定在 computer-list 中松散源路由。<br>-w timeout 等待由 timeout 对每个应答指定的毫秒数。<br>target_name 目标计算机的名称。<br>实例：</p>\n<p>复制代码<br>代码如下:</p>\n<p>C:\\Users\\Administrator&gt;tracert www.58.com<br>Tracing route to www.58.com [221.187.111.30]<br>over a maximum of 30 hops:<br>1 1 ms 1 ms 1 ms 10.58.156.1<br>2 1 ms &lt;1 ms &lt;1 ms 10.10.10.1<br>3 1 ms 1 ms 1 ms 211.103.193.129<br>4 2 ms 2 ms 2 ms 10.255.109.129<br>5 1 ms 1 ms 3 ms 124.205.98.205<br>6 2 ms 2 ms 2 ms 124.205.98.253<br>7 2 ms 6 ms 1 ms 202.99.1.125<br>8 5 ms 6 ms 5 ms 118.186.0.113<br>9 207 ms <em> </em> 118.186.0.106<br>10 8 ms 6 ms 11 ms 124.238.226.201<br>11 6 ms 7 ms 6 ms 219.148.19.177<br>12 12 ms 12 ms 16 ms 219.148.18.117<br>13 14 ms 17 ms 16 ms 219.148.19.125<br>14 13 ms 13 ms 12 ms 202.97.80.113<br>15 <em> </em> <em> Request timed out.<br>16 12 ms 12 ms 17 ms bj141-147-82.bjtelecom.net [219.141.147.82]<br>17 13 ms 13 ms 12 ms 202.97.48.2<br>18 </em> <em> </em> Request timed out.<br>19 14 ms 14 ms 12 ms 221.187.224.85<br>20 15 ms 13 ms 12 ms 221.187.104.2<br>21 <em> </em> * Request timed out.<br>22 15 ms 17 ms 18 ms 221.187.111.30<br>Trace complete.</p>\n","excerpt":"<p>通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的<br>","more":"<br>linux系统中，我们称之为traceroute,在MS Windows中为tracert。 traceroute通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备traceroute要测3次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其IP地址。<br>在大多数情况下，我们会在linux主机系统下，直接执行命令行：traceroute hostname<br>而在Windows系统下是执行tracert的命令： tracert hostname<br>1.命令格式：<br>traceroute[参数][主机]<br>2.命令功能：<br>traceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。<br>具体参数格式：traceroute [-dFlnrvx][-f&lt;存活数值&gt;][-g&lt;网关&gt;…][-i&lt;网络界面&gt;][-m&lt;存活数值&gt;][-p&lt;通信端口&gt;][-s&lt;来源地址&gt;][-t&lt;服务类型&gt;][-w&lt;超时秒数&gt;][主机名称或IP地址][数据包大小]<br>3.命令参数：<br>-d 使用Socket层级的排错功能。<br>-f 设置第一个检测数据包的存活数值TTL的大小。<br>-F 设置勿离断位。<br>-g 设置来源路由网关，最多可设置8个。<br>-i 使用指定的网络界面送出数据包。<br>-I 使用ICMP回应取代UDP资料信息。<br>-m 设置检测数据包的最大存活数值TTL的大小。<br>-n 直接使用IP地址而非主机名称。<br>-p 设置UDP传输协议的通信端口。<br>-r 忽略普通的Routing Table，直接将数据包送到远端主机上。<br>-s 设置本地主机送出数据包的IP地址。<br>-t 设置检测数据包的TOS数值。<br>-v 详细显示指令的执行过程。<br>-w 设置等待远端主机回报的时间。<br>-x 开启或关闭数据包的正确性检验。<br>4.使用实例：<br>实例1：traceroute 用法简单、最常用的用法<br>命令：traceroute www.baidu.com<br>输出：</p>\n<p>复制代码<br>代码如下:</p>\n<p>[root@localhost ~]# traceroute www.baidu.com<br>traceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets<br>1 192.168.74.2 (192.168.74.2) 2.606 ms 2.771 ms 2.950 ms<br>2 211.151.56.57 (211.151.56.57) 0.596 ms 0.598 ms 0.591 ms<br>3 211.151.227.206 (211.151.227.206) 0.546 ms 0.544 ms 0.538 ms<br>4 210.77.139.145 (210.77.139.145) 0.710 ms 0.748 ms 0.801 ms<br>5 202.106.42.101 (202.106.42.101) 6.759 ms 6.945 ms 7.107 ms<br>6 61.148.154.97 (61.148.154.97) 718.908 ms <em> bt-228-025.bta.net.cn (202.106.228.25) 5.177 ms<br>7 124.65.58.213 (124.65.58.213) 4.343 ms 4.336 ms 4.367 ms<br>8 202.106.35.190 (202.106.35.190) 1.795 ms 61.148.156.138 (61.148.156.138) 1.899 ms 1.951 ms<br>9 </em> <em> </em><br>30 <em> </em> *<br>[root@localhost ~]#<br>说明：<br>记录按序列号从1开始，每个纪录就是一跳 ，每跳表示一个网关，我们看到每行有三个时间，单位是 ms，其实就是-q的默认参数。探测数据包向每个网关发送三个数据包后，网关响应后返回的时间；如果您用 traceroute -q 4 www.58.com ，表示向每个网关发送4个数据包。<br>有时我们traceroute 一台主机时，会看到有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了ICMP的返回信息，所以我们得不到什么相关的数据包返回数据。<br>有时我们在某一网关处延时比较长，有可能是某台网关比较阻塞，也可能是物理设备本身的原因。当然如果某台DNS出现问题时，不能解析主机名、域名时，也会 有延时长的现象；您可以加-n 参数来避免DNS解析，以IP格式输出数据。<br>如果在局域网中的不同网段之间，我们可以通过traceroute 来排查问题所在，是主机的问题还是网关的问题。如果我们通过远程来访问某台服务器遇到问题时，我们用到traceroute 追踪数据包所经过的网关，提交IDC服务商，也有助于解决问题；但目前看来在国内解决这样的问题是比较困难的，就是我们发现问题所在，IDC服务商也不可能帮助我们解决。<br>实例2：跳数设置<br>命令：traceroute -m 10 www.baidu.com<br>输出：</p>\n<p>复制代码<br>代码如下:</p>\n<p>[root@localhost ~]# traceroute -m 10 www.baidu.com<br>traceroute to www.baidu.com (61.135.169.105), 10 hops max, 40 byte packets<br>1 192.168.74.2 (192.168.74.2) 1.534 ms 1.775 ms 1.961 ms<br>2 211.151.56.1 (211.151.56.1) 0.508 ms 0.514 ms 0.507 ms<br>3 211.151.227.206 (211.151.227.206) 0.571 ms 0.558 ms 0.550 ms<br>4 210.77.139.145 (210.77.139.145) 0.708 ms 0.729 ms 0.785 ms<br>5 202.106.42.101 (202.106.42.101) 7.978 ms 8.155 ms 8.311 ms<br>6 bt-228-037.bta.net.cn (202.106.228.37) 772.460 ms bt-228-025.bta.net.cn (202.106.228.25) 2.152 ms 61.148.154.97 (61.148.154.97) 772.107 ms<br>7 124.65.58.221 (124.65.58.221) 4.875 ms 61.148.146.29 (61.148.146.29) 2.124 ms 124.65.58.221 (124.65.58.221) 4.854 ms<br>8 123.126.6.198 (123.126.6.198) 2.944 ms 61.148.156.6 (61.148.156.6) 3.505 ms 123.126.6.198 (123.126.6.198) 2.885 ms<br>9 <em> </em> <em><br>10 </em> <em> </em><br>[root@localhost ~]#</p>\n<p>实例3：显示IP地址，不查主机名<br>命令：traceroute -n www.baidu.com<br>输出：</p>\n<p>复制代码<br>代码如下:</p>\n<p>[root@localhost ~]# traceroute -n www.baidu.com<br>traceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets<br>1 211.151.74.2 5.430 ms 5.636 ms 5.802 ms<br>2 211.151.56.57 0.627 ms 0.625 ms 0.617 ms<br>3 211.151.227.206 0.575 ms 0.584 ms 0.576 ms<br>4 210.77.139.145 0.703 ms 0.754 ms 0.806 ms<br>5 202.106.42.101 23.683 ms 23.869 ms 23.998 ms<br>6 202.106.228.37 247.101 ms <em> </em><br>7 61.148.146.29 5.256 ms 124.65.58.213 4.386 ms 4.373 ms<br>8 202.106.35.190 1.610 ms 61.148.156.138 1.786 ms 61.148.3.34 2.089 ms<br>9 <em> </em> <em><br>30 </em> <em> </em><br>[root@localhost ~]# traceroute www.baidu.com<br>traceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets<br>1 211.151.74.2 (211.151.74.2) 4.671 ms 4.865 ms 5.055 ms<br>2 211.151.56.57 (211.151.56.57) 0.619 ms 0.618 ms 0.612 ms<br>3 211.151.227.206 (211.151.227.206) 0.620 ms 0.642 ms 0.636 ms<br>4 210.77.139.145 (210.77.139.145) 0.720 ms 0.772 ms 0.816 ms<br>5 202.106.42.101 (202.106.42.101) 7.667 ms 7.910 ms 8.012 ms<br>6 bt-228-025.bta.net.cn (202.106.228.25) 2.965 ms 2.440 ms 61.148.154.97 (61.148.154.97) 431.337 ms<br>7 124.65.58.213 (124.65.58.213) 5.134 ms 5.124 ms 5.044 ms<br>8 202.106.35.190 (202.106.35.190) 1.917 ms 2.052 ms 2.059 ms<br>9 <em> </em> <em><br>30 </em> <em> </em><br>[root@localhost ~]#<br>实例4：探测包使用的基本UDP端口设置6888<br>命令：traceroute -p 6888 www.baidu.com<br>输出：</p>\n<p>复制代码<br>代码如下:</p>\n<p>[root@localhost ~]# traceroute -p 6888 www.baidu.com<br>traceroute to www.baidu.com (220.181.111.147), 30 hops max, 40 byte packets<br>1 211.151.74.2 (211.151.74.2) 4.927 ms 5.121 ms 5.298 ms<br>2 211.151.56.1 (211.151.56.1) 0.500 ms 0.499 ms 0.509 ms<br>3 211.151.224.90 (211.151.224.90) 0.637 ms 0.631 ms 0.641 ms<br>4 <em> </em> <em><br>5 220.181.70.98 (220.181.70.98) 5.050 ms 5.313 ms 5.596 ms<br>6 220.181.17.94 (220.181.17.94) 1.665 ms !X </em> *<br>[root@localhost ~]#<br>实例5：把探测包的个数设置为值4<br>命令：traceroute -q 4 www.baidu.com<br>输出：</p>\n<p>复制代码<br>代码如下:</p>\n<p>[root@localhost ~]# traceroute -q 4 www.baidu.com<br>traceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets<br>1 211.151.74.2 (211.151.74.2) 40.633 ms 40.819 ms 41.004 ms 41.188 ms<br>2 211.151.56.57 (211.151.56.57) 0.637 ms 0.633 ms 0.627 ms 0.619 ms<br>3 211.151.227.206 (211.151.227.206) 0.505 ms 0.580 ms 0.571 ms 0.569 ms<br>4 210.77.139.145 (210.77.139.145) 0.753 ms 0.800 ms 0.853 ms 0.904 ms<br>5 202.106.42.101 (202.106.42.101) 7.449 ms 7.543 ms 7.738 ms 7.893 ms<br>6 61.148.154.97 (61.148.154.97) 316.817 ms bt-228-025.bta.net.cn (202.106.228.25) 3.695 ms 3.672 ms <em><br>7 124.65.58.213 (124.65.58.213) 3.056 ms 2.993 ms 2.960 ms 61.148.146.29 (61.148.146.29) 2.837 ms<br>8 61.148.3.34 (61.148.3.34) 2.179 ms 2.295 ms 2.442 ms 202.106.35.190 (202.106.35.190) 7.136 ms<br>9 </em> <em> </em> <em><br>30 </em> <em> </em> *<br>[root@localhost ~]# </p>\n<p>实例6：绕过正常的路由表，直接发送到网络相连的主机<br>命令：traceroute -r www.baidu.com<br>输出：</p>\n<p>复制代码<br>代码如下:</p>\n<p>[root@localhost ~]# traceroute -r www.baidu.com<br>traceroute to www.baidu.com (61.135.169.125), 30 hops max, 40 byte packets<br>connect: 网络不可达<br>[root@localhost ~]#<br>实例7：把对外发探测包的等待响应时间设置为3秒<br>命令：traceroute -w 3 www.baidu.com<br>输出：</p>\n<p>复制代码<br>代码如下:</p>\n<p>[root@localhost ~]# traceroute -w 3 www.baidu.com<br>traceroute to www.baidu.com (61.135.169.105), 30 hops max, 40 byte packets<br>1 211.151.74.2 (211.151.74.2) 2.306 ms 2.469 ms 2.650 ms<br>2 211.151.56.1 (211.151.56.1) 0.621 ms 0.613 ms 0.603 ms<br>3 211.151.227.206 (211.151.227.206) 0.557 ms 0.560 ms 0.552 ms<br>4 210.77.139.145 (210.77.139.145) 0.708 ms 0.761 ms 0.817 ms<br>5 202.106.42.101 (202.106.42.101) 7.520 ms 7.774 ms 7.902 ms<br>6 bt-228-025.bta.net.cn (202.106.228.25) 2.890 ms 2.369 ms 61.148.154.97 (61.148.154.97) 471.961 ms<br>7 124.65.58.221 (124.65.58.221) 4.490 ms 4.483 ms 4.472 ms<br>8 123.126.6.198 (123.126.6.198) 2.948 ms 61.148.156.6 (61.148.156.6) 7.688 ms 7.756 ms<br>9 <em> </em> <em><br>30 </em> <em> </em><br>[root@localhost ~]# </p>\n<p>Traceroute的工作原理：<br>Traceroute最简单的基本用法是：traceroute hostname<br>Traceroute程序的设计是利用ICMP及IP header的TTL（Time To Live）栏位（field）。首先，traceroute送出一个TTL是1的IP datagram（其实，每次送出的为3个40字节的包，包括源地址，目的地址和包发出的时间标签）到目的地，当路径上的第一个路由器（router）收到这个datagram时，它将TTL减1。此时，TTL变为0了，所以该路由器会将此datagram丢掉，并送回一个「ICMP time exceeded」消息（包括发IP包的源地址，IP包的所有内容及路由器的IP地址），traceroute 收到这个消息后，便知道这个路由器存在于这个路径上，接着traceroute 再送出另一个TTL是2 的datagram，发现第2 个路由器…… traceroute 每次将送出的datagram的TTL 加1来发现另一个路由器，这个重复的动作一直持续到某个datagram 抵达目的地。当datagram到达目的地后，该主机并不会送回ICMP time exceeded消息，因为它已是目的地了，那么traceroute如何得知目的地到达了呢？<br>Traceroute在送出UDP datagrams到目的地时，它所选择送达的port number 是一个一般应用程序都不会用的号码（30000 以上），所以当此UDP datagram 到达目的地后该主机会送回一个「ICMP port unreachable」的消息，而当traceroute 收到这个消息时，便知道目的地已经到达了。所以traceroute 在Server端也是没有所谓的Daemon 程式。<br>Traceroute提取发 ICMP TTL到期消息设备的IP地址并作域名解析。每次 ，Traceroute都打印出一系列数据,包括所经过的路由设备的域名及 IP地址,三个包每次来回所花时间。<br>windows之tracert:<br>格式：<br>tracert [-d] [-h maximum_hops] [-j host-list] [-w timeout] target_name<br>参数说明：<br>tracert [-d] [-h maximum_hops] [-j computer-list] [-w timeout] target_name<br>该诊断实用程序通过向目的地发送具有不同生存时间 (TL) 的 Internet 控制信息协议 (CMP) 回应报文，以确定至目的地的路由。路径上的每个路由器都要在转发该 ICMP 回应报文之前将其 TTL 值至少减 1，因此 TTL 是有效的跳转计数。当报文的 TTL 值减少到 0 时，路由器向源系统发回 ICMP 超时信息。通过发送 TTL 为 1 的第一个回应报文并且在随后的发送中每次将 TTL 值加 1，直到目标响应或达到最大 TTL 值，Tracert 可以确定路由。通过检查中间路由器发发回的 ICMP 超时 (ime Exceeded) 信息，可以确定路由器。注意，有些路由器“安静”地丢弃生存时间 (TLS) 过期的报文并且对 tracert 无效。<br>参数：<br>-d 指定不对计算机名解析地址。<br>-h maximum_hops 指定查找目标的跳转的最大数目。<br>-jcomputer-list 指定在 computer-list 中松散源路由。<br>-w timeout 等待由 timeout 对每个应答指定的毫秒数。<br>target_name 目标计算机的名称。<br>实例：</p>\n<p>复制代码<br>代码如下:</p>\n<p>C:\\Users\\Administrator&gt;tracert www.58.com<br>Tracing route to www.58.com [221.187.111.30]<br>over a maximum of 30 hops:<br>1 1 ms 1 ms 1 ms 10.58.156.1<br>2 1 ms &lt;1 ms &lt;1 ms 10.10.10.1<br>3 1 ms 1 ms 1 ms 211.103.193.129<br>4 2 ms 2 ms 2 ms 10.255.109.129<br>5 1 ms 1 ms 3 ms 124.205.98.205<br>6 2 ms 2 ms 2 ms 124.205.98.253<br>7 2 ms 6 ms 1 ms 202.99.1.125<br>8 5 ms 6 ms 5 ms 118.186.0.113<br>9 207 ms <em> </em> 118.186.0.106<br>10 8 ms 6 ms 11 ms 124.238.226.201<br>11 6 ms 7 ms 6 ms 219.148.19.177<br>12 12 ms 12 ms 16 ms 219.148.18.117<br>13 14 ms 17 ms 16 ms 219.148.19.125<br>14 13 ms 13 ms 12 ms 202.97.80.113<br>15 <em> </em> <em> Request timed out.<br>16 12 ms 12 ms 17 ms bj141-147-82.bjtelecom.net [219.141.147.82]<br>17 13 ms 13 ms 12 ms 202.97.48.2<br>18 </em> <em> </em> Request timed out.<br>19 14 ms 14 ms 12 ms 221.187.224.85<br>20 15 ms 13 ms 12 ms 221.187.104.2<br>21 <em> </em> * Request timed out.<br>22 15 ms 17 ms 18 ms 221.187.111.30<br>Trace complete.</p>"},{"title":"linux 命令rsync+crontab实现自动同步","date":"2016-10-05T04:00:00.000Z","_content":"linux 命令rsync+crontab实现自动同步,这个技术现在已经用得很广泛了,比起第三方的软件要可靠好使,所以得到系统管理员的广泛应用;在此,我给大伙来分享一下;请指教.\n\n首先,我们来了解一下这个命令:\n\nrsync命令格式:rsync [option] 源路径 目标路径;\n<!--more-->\n其中:  \n\n[option]:  \n\n    a:使用archive模式,等于-rlptgoD,即保持原有的文件权限;\n    \n    z:表示传输时压缩数据;\n    \n    v:显示到屏幕中;\n    \n    e:使用远程shell程序(可以使用rsh或ssh;\n    \n    --delete:精确保存副本,源主机删除的文件,目标主机也会同步删除;\n    \n    --include=PATTERN:不排除符合PATTERN的文件或目录;\n    \n    --exclude=PATTERN:排除所有符合PATTERN的文件或目录;\n    \n    --password-file:指定用于rsync服务器的用户验证密码;\n    \n源路径和目标路径可以使用如下格式:\n\n\n    rsync://[USER@]Host[:Port]/Path #--rsync服务器路径;\n    \n    [USER@]Host::Path   #--rsync服务器的另一种表示形式;\n    \n    [USER@]Host:Path#--远程路径;\n    \n    LocalPath   #--本地路径;\n    \n知道上述命令的基本格式了吗?\n\n下面我们来讲安装rsyn命令;\n\n\n    [root@dbserver ~]#yum list rsync*\n    \n    Loaded plugins: fastestmirror, refresh-packagekit, security\n    \n    Loading mirror speeds from cached hostfile\n    \n     * rpmforge: mirrors.neusoft.edu.cn\n    \n    Installed Packages\n    \n    rsync.i686  3.0.6-9.el6   @anaconda-CentOS-201207051201.i386/6.3\n    \n    [root@dbserver ~]#yum -y install rsync*\n    \n前面是查看rsync RPM包,后面是安装rsync这个命令;\n\n安装完后,我们便可以来配置rsync服务器与客服端了;\n\n实例:\n\nA服务器:192.168.1.213\n\nB客户端:192.168.1.210\n\n首先人们配置服务器,look,\n\n在配置服务器之前要先生成密钥,ssh-keygen -t rsa,生成密钥如下:\n\n\n    [root@masternagios .ssh]# ls\n    \n    id_rsa  id_rsa.pub\n    \n    [root@masternagios .ssh]#  scp id_rsa_pub root@192.168.1.210:/root/.ssh/authorized_keys\n\n在客户端也要如下操作:\n\n\n    [root@masternagios .ssh]# ssh-keygen -t rsa\n    \n    [root@masternagios .ssh]# ls\n    \n    id_rsa  id_rsa.pub  authorized_keys(213的公钥)\n    \n    [root@masternagios.ssh]#\n    \n    scp id_rsa_pub root@192.168.1.213:/root/.ssh/authorized_keys\n\n这样两台机可以无密码SSH登陆,以便后面我们同步方便;当然,不要上述的操作也能实现;那么如下操作:\n\n服务端:\n\n    vi /etc/sery.pass  权限:600(chmod 600 /etc/sery.pass)\n    \n    root:123456\n\n客服端:\n    \n    vi /etc/sery_client.pass  权限:600(chmod 600 /etc/sery_client.pass)\n    \n    123456\n\n生成的这两件文件后面有用处的;\n\n然后新建配置文件vi /etc/rsyncd.conf,内容如下图示:\n![](http://hiphotos.baidu.com/exp/pic/item/d872d695d143ad4b038f881c83025aafa50f060e.jpg)\n解析如下:\n\n    uid = root           #root用户访问(我这里用ROOT用户,也可以用其他新建的用户)\n\n    gid = root           #root组用户访问\n\n    use chroot = no      #不能使用chroot\n\n    max connections = 10  #最大连接数\n\n    list = yes           #允许列出文件清单\n\n    pid file = /var/run/rsyncd.pid\n\n    lock file = /var/run/rsyncd.lock\n\n    log file = /var/log/rsyncd.log\n\n    hosts allow  = 192.168.1.2      #只允许这个主机访问\n\n   [data]                    #发布项(注意这个命名)\n\n    path = /webapps/IDManage         #发布的路径\n\n    ignore errors\n\n    read only = yes            #只读\n\n    auth users = root                #认证用户为root\n\n    secrets file = /etc/sery.pass    #密码文件\n\n然后我们来启动:\n\n[root@masternagios ~]# rsync --daemon --config=/etc/rsyncd.conf\n\n    [root@masternagios ~]# ps -ef |grep rsync\n\n    root     21359     1  0 Aug24 ?        00:00:00 rsync --daemon --     config=/etc/rsyncd.conf\n\n    root     24018 23885  0 10:38 pts/0    00:00:00 grep rsync\n\n    [root@masternagios ~]#lsof -i:873\n\n    COMMAND   PID USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME\n\n    rsync   21359 root    4u  IPv4 1558266      0t0  TCP *:rsync (LISTEN)\n\n    rsync   21359 root    5u  IPv6 1558267      0t0  TCP *:rsync (LISTEN)\n\n然后在客户端测试:\n    \n    [root@dbserver ~]# telnet 192.168.1.213 873\n    \n    Trying 192.168.1.213...\n    \n    Connected to 192.168.1.213.\n    \n    Escape character is '^]'.\n    \n    @RSYNCD: 30.0\n    \n    ^]\n    \n    telnet> q\n    \n    Connection closed.\n\n说明网络端口开放,没有问题;通常在这配置时会发现一些问题,比如报错(111)--说明服务器端口未开启,就检查一下rsync服务有没有开启;\n\n报错(1503)(1536)--说明无 [data] #发布项(注意这个命名),这里命令一定要对应上同步::[data];\n\n我们再来把服务端rsync加自动启动;\n\n    echo \"/usr/bin/rsync --daemon --config=/etc/rsyncd.conf\" >>/etc/rc.local\n\n配置客户端;\n\n客户端只要安装rsync这个命令便可以实现,所以,我们来测试同步实现;\n\n    [root@dbserver ~]#rsync -aSvH /webapps/IDManage/ root@192.168.1.213::data --password-file=/etc/sery_client.pass\n    \n可以看到:\n![](http://hiphotos.baidu.com/exp/pic/item/346bd85c10385343bd094ffd9213b07ec88088ed.jpg)\n命令执行成功;说明服务端与客户端都没有问题;\n\n如何自实rsync客户端自动与rsync服务器端同步呢?这里我们用到计划任务命令:crontab;\n\n首先,我们来做一个shell脚本,\n\n    [root@dbserver ~]#vi /tmp/rsyncd.sh\n    \n    #!/bin/bash\n    \n    rsync -aSvH /webapps/IDManage/ root@192.168.1.213::data --password-file=/etc/sery_client.pass\n    \n    wq!   ##保存退出\n    \n    [root@dbserver ~]#crontab -e\n    \n    */5 * * * * sh /tmp/rsyncd.sh #第5分钟执行一次同步;\n    \n    wq!   ##保存退出\n\n看了,到此分享linux 命令rsync+crontab实现自动同步,已经结束;总结一点:rsync命令格式一定要知道:rsync [option] 源路径目标路径,目标路径的格式有几种,大家只要记得一两种便可以了;","source":"_posts/linux_命令rsync+crontab实现自动同步.md","raw":"---\ntitle: linux 命令rsync+crontab实现自动同步\ndate: 2016-10-05\ntags:\n---\nlinux 命令rsync+crontab实现自动同步,这个技术现在已经用得很广泛了,比起第三方的软件要可靠好使,所以得到系统管理员的广泛应用;在此,我给大伙来分享一下;请指教.\n\n首先,我们来了解一下这个命令:\n\nrsync命令格式:rsync [option] 源路径 目标路径;\n<!--more-->\n其中:  \n\n[option]:  \n\n    a:使用archive模式,等于-rlptgoD,即保持原有的文件权限;\n    \n    z:表示传输时压缩数据;\n    \n    v:显示到屏幕中;\n    \n    e:使用远程shell程序(可以使用rsh或ssh;\n    \n    --delete:精确保存副本,源主机删除的文件,目标主机也会同步删除;\n    \n    --include=PATTERN:不排除符合PATTERN的文件或目录;\n    \n    --exclude=PATTERN:排除所有符合PATTERN的文件或目录;\n    \n    --password-file:指定用于rsync服务器的用户验证密码;\n    \n源路径和目标路径可以使用如下格式:\n\n\n    rsync://[USER@]Host[:Port]/Path #--rsync服务器路径;\n    \n    [USER@]Host::Path   #--rsync服务器的另一种表示形式;\n    \n    [USER@]Host:Path#--远程路径;\n    \n    LocalPath   #--本地路径;\n    \n知道上述命令的基本格式了吗?\n\n下面我们来讲安装rsyn命令;\n\n\n    [root@dbserver ~]#yum list rsync*\n    \n    Loaded plugins: fastestmirror, refresh-packagekit, security\n    \n    Loading mirror speeds from cached hostfile\n    \n     * rpmforge: mirrors.neusoft.edu.cn\n    \n    Installed Packages\n    \n    rsync.i686  3.0.6-9.el6   @anaconda-CentOS-201207051201.i386/6.3\n    \n    [root@dbserver ~]#yum -y install rsync*\n    \n前面是查看rsync RPM包,后面是安装rsync这个命令;\n\n安装完后,我们便可以来配置rsync服务器与客服端了;\n\n实例:\n\nA服务器:192.168.1.213\n\nB客户端:192.168.1.210\n\n首先人们配置服务器,look,\n\n在配置服务器之前要先生成密钥,ssh-keygen -t rsa,生成密钥如下:\n\n\n    [root@masternagios .ssh]# ls\n    \n    id_rsa  id_rsa.pub\n    \n    [root@masternagios .ssh]#  scp id_rsa_pub root@192.168.1.210:/root/.ssh/authorized_keys\n\n在客户端也要如下操作:\n\n\n    [root@masternagios .ssh]# ssh-keygen -t rsa\n    \n    [root@masternagios .ssh]# ls\n    \n    id_rsa  id_rsa.pub  authorized_keys(213的公钥)\n    \n    [root@masternagios.ssh]#\n    \n    scp id_rsa_pub root@192.168.1.213:/root/.ssh/authorized_keys\n\n这样两台机可以无密码SSH登陆,以便后面我们同步方便;当然,不要上述的操作也能实现;那么如下操作:\n\n服务端:\n\n    vi /etc/sery.pass  权限:600(chmod 600 /etc/sery.pass)\n    \n    root:123456\n\n客服端:\n    \n    vi /etc/sery_client.pass  权限:600(chmod 600 /etc/sery_client.pass)\n    \n    123456\n\n生成的这两件文件后面有用处的;\n\n然后新建配置文件vi /etc/rsyncd.conf,内容如下图示:\n![](http://hiphotos.baidu.com/exp/pic/item/d872d695d143ad4b038f881c83025aafa50f060e.jpg)\n解析如下:\n\n    uid = root           #root用户访问(我这里用ROOT用户,也可以用其他新建的用户)\n\n    gid = root           #root组用户访问\n\n    use chroot = no      #不能使用chroot\n\n    max connections = 10  #最大连接数\n\n    list = yes           #允许列出文件清单\n\n    pid file = /var/run/rsyncd.pid\n\n    lock file = /var/run/rsyncd.lock\n\n    log file = /var/log/rsyncd.log\n\n    hosts allow  = 192.168.1.2      #只允许这个主机访问\n\n   [data]                    #发布项(注意这个命名)\n\n    path = /webapps/IDManage         #发布的路径\n\n    ignore errors\n\n    read only = yes            #只读\n\n    auth users = root                #认证用户为root\n\n    secrets file = /etc/sery.pass    #密码文件\n\n然后我们来启动:\n\n[root@masternagios ~]# rsync --daemon --config=/etc/rsyncd.conf\n\n    [root@masternagios ~]# ps -ef |grep rsync\n\n    root     21359     1  0 Aug24 ?        00:00:00 rsync --daemon --     config=/etc/rsyncd.conf\n\n    root     24018 23885  0 10:38 pts/0    00:00:00 grep rsync\n\n    [root@masternagios ~]#lsof -i:873\n\n    COMMAND   PID USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME\n\n    rsync   21359 root    4u  IPv4 1558266      0t0  TCP *:rsync (LISTEN)\n\n    rsync   21359 root    5u  IPv6 1558267      0t0  TCP *:rsync (LISTEN)\n\n然后在客户端测试:\n    \n    [root@dbserver ~]# telnet 192.168.1.213 873\n    \n    Trying 192.168.1.213...\n    \n    Connected to 192.168.1.213.\n    \n    Escape character is '^]'.\n    \n    @RSYNCD: 30.0\n    \n    ^]\n    \n    telnet> q\n    \n    Connection closed.\n\n说明网络端口开放,没有问题;通常在这配置时会发现一些问题,比如报错(111)--说明服务器端口未开启,就检查一下rsync服务有没有开启;\n\n报错(1503)(1536)--说明无 [data] #发布项(注意这个命名),这里命令一定要对应上同步::[data];\n\n我们再来把服务端rsync加自动启动;\n\n    echo \"/usr/bin/rsync --daemon --config=/etc/rsyncd.conf\" >>/etc/rc.local\n\n配置客户端;\n\n客户端只要安装rsync这个命令便可以实现,所以,我们来测试同步实现;\n\n    [root@dbserver ~]#rsync -aSvH /webapps/IDManage/ root@192.168.1.213::data --password-file=/etc/sery_client.pass\n    \n可以看到:\n![](http://hiphotos.baidu.com/exp/pic/item/346bd85c10385343bd094ffd9213b07ec88088ed.jpg)\n命令执行成功;说明服务端与客户端都没有问题;\n\n如何自实rsync客户端自动与rsync服务器端同步呢?这里我们用到计划任务命令:crontab;\n\n首先,我们来做一个shell脚本,\n\n    [root@dbserver ~]#vi /tmp/rsyncd.sh\n    \n    #!/bin/bash\n    \n    rsync -aSvH /webapps/IDManage/ root@192.168.1.213::data --password-file=/etc/sery_client.pass\n    \n    wq!   ##保存退出\n    \n    [root@dbserver ~]#crontab -e\n    \n    */5 * * * * sh /tmp/rsyncd.sh #第5分钟执行一次同步;\n    \n    wq!   ##保存退出\n\n看了,到此分享linux 命令rsync+crontab实现自动同步,已经结束;总结一点:rsync命令格式一定要知道:rsync [option] 源路径目标路径,目标路径的格式有几种,大家只要记得一两种便可以了;","slug":"linux_命令rsync+crontab实现自动同步","published":1,"updated":"2017-03-01T06:06:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizqklz7q0007lbpvg1lxsue0","content":"<p>linux 命令rsync+crontab实现自动同步,这个技术现在已经用得很广泛了,比起第三方的软件要可靠好使,所以得到系统管理员的广泛应用;在此,我给大伙来分享一下;请指教.</p>\n<p>首先,我们来了解一下这个命令:</p>\n<p>rsync命令格式:rsync [option] 源路径 目标路径;<br><a id=\"more\"></a><br>其中:  </p>\n<p>[option]:  </p>\n<pre><code>a:使用archive模式,等于-rlptgoD,即保持原有的文件权限;\n\nz:表示传输时压缩数据;\n\nv:显示到屏幕中;\n\ne:使用远程shell程序(可以使用rsh或ssh;\n\n--delete:精确保存副本,源主机删除的文件,目标主机也会同步删除;\n\n--include=PATTERN:不排除符合PATTERN的文件或目录;\n\n--exclude=PATTERN:排除所有符合PATTERN的文件或目录;\n\n--password-file:指定用于rsync服务器的用户验证密码;\n</code></pre><p>源路径和目标路径可以使用如下格式:</p>\n<pre><code>rsync://[USER@]Host[:Port]/Path #--rsync服务器路径;\n\n[USER@]Host::Path   #--rsync服务器的另一种表示形式;\n\n[USER@]Host:Path#--远程路径;\n\nLocalPath   #--本地路径;\n</code></pre><p>知道上述命令的基本格式了吗?</p>\n<p>下面我们来讲安装rsyn命令;</p>\n<pre><code>[root@dbserver ~]#yum list rsync*\n\nLoaded plugins: fastestmirror, refresh-packagekit, security\n\nLoading mirror speeds from cached hostfile\n\n * rpmforge: mirrors.neusoft.edu.cn\n\nInstalled Packages\n\nrsync.i686  3.0.6-9.el6   @anaconda-CentOS-201207051201.i386/6.3\n\n[root@dbserver ~]#yum -y install rsync*\n</code></pre><p>前面是查看rsync RPM包,后面是安装rsync这个命令;</p>\n<p>安装完后,我们便可以来配置rsync服务器与客服端了;</p>\n<p>实例:</p>\n<p>A服务器:192.168.1.213</p>\n<p>B客户端:192.168.1.210</p>\n<p>首先人们配置服务器,look,</p>\n<p>在配置服务器之前要先生成密钥,ssh-keygen -t rsa,生成密钥如下:</p>\n<pre><code>[root@masternagios .ssh]# ls\n\nid_rsa  id_rsa.pub\n\n[root@masternagios .ssh]#  scp id_rsa_pub root@192.168.1.210:/root/.ssh/authorized_keys\n</code></pre><p>在客户端也要如下操作:</p>\n<pre><code>[root@masternagios .ssh]# ssh-keygen -t rsa\n\n[root@masternagios .ssh]# ls\n\nid_rsa  id_rsa.pub  authorized_keys(213的公钥)\n\n[root@masternagios.ssh]#\n\nscp id_rsa_pub root@192.168.1.213:/root/.ssh/authorized_keys\n</code></pre><p>这样两台机可以无密码SSH登陆,以便后面我们同步方便;当然,不要上述的操作也能实现;那么如下操作:</p>\n<p>服务端:</p>\n<pre><code>vi /etc/sery.pass  权限:600(chmod 600 /etc/sery.pass)\n\nroot:123456\n</code></pre><p>客服端:</p>\n<pre><code>vi /etc/sery_client.pass  权限:600(chmod 600 /etc/sery_client.pass)\n\n123456\n</code></pre><p>生成的这两件文件后面有用处的;</p>\n<p>然后新建配置文件vi /etc/rsyncd.conf,内容如下图示:<br><img src=\"http://hiphotos.baidu.com/exp/pic/item/d872d695d143ad4b038f881c83025aafa50f060e.jpg\" alt=\"\"><br>解析如下:</p>\n<pre><code>uid = root           #root用户访问(我这里用ROOT用户,也可以用其他新建的用户)\n\ngid = root           #root组用户访问\n\nuse chroot = no      #不能使用chroot\n\nmax connections = 10  #最大连接数\n\nlist = yes           #允许列出文件清单\n\npid file = /var/run/rsyncd.pid\n\nlock file = /var/run/rsyncd.lock\n\nlog file = /var/log/rsyncd.log\n\nhosts allow  = 192.168.1.2      #只允许这个主机访问\n</code></pre><p>   [data]                    #发布项(注意这个命名)</p>\n<pre><code>path = /webapps/IDManage         #发布的路径\n\nignore errors\n\nread only = yes            #只读\n\nauth users = root                #认证用户为root\n\nsecrets file = /etc/sery.pass    #密码文件\n</code></pre><p>然后我们来启动:</p>\n<p>[root@masternagios ~]# rsync –daemon –config=/etc/rsyncd.conf</p>\n<pre><code>[root@masternagios ~]# ps -ef |grep rsync\n\nroot     21359     1  0 Aug24 ?        00:00:00 rsync --daemon --     config=/etc/rsyncd.conf\n\nroot     24018 23885  0 10:38 pts/0    00:00:00 grep rsync\n\n[root@masternagios ~]#lsof -i:873\n\nCOMMAND   PID USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME\n\nrsync   21359 root    4u  IPv4 1558266      0t0  TCP *:rsync (LISTEN)\n\nrsync   21359 root    5u  IPv6 1558267      0t0  TCP *:rsync (LISTEN)\n</code></pre><p>然后在客户端测试:</p>\n<pre><code>[root@dbserver ~]# telnet 192.168.1.213 873\n\nTrying 192.168.1.213...\n\nConnected to 192.168.1.213.\n\nEscape character is &apos;^]&apos;.\n\n@RSYNCD: 30.0\n\n^]\n\ntelnet&gt; q\n\nConnection closed.\n</code></pre><p>说明网络端口开放,没有问题;通常在这配置时会发现一些问题,比如报错(111)–说明服务器端口未开启,就检查一下rsync服务有没有开启;</p>\n<p>报错(1503)(1536)–说明无 [data] #发布项(注意这个命名),这里命令一定要对应上同步::[data];</p>\n<p>我们再来把服务端rsync加自动启动;</p>\n<pre><code>echo &quot;/usr/bin/rsync --daemon --config=/etc/rsyncd.conf&quot; &gt;&gt;/etc/rc.local\n</code></pre><p>配置客户端;</p>\n<p>客户端只要安装rsync这个命令便可以实现,所以,我们来测试同步实现;</p>\n<pre><code>[root@dbserver ~]#rsync -aSvH /webapps/IDManage/ root@192.168.1.213::data --password-file=/etc/sery_client.pass\n</code></pre><p>可以看到:<br><img src=\"http://hiphotos.baidu.com/exp/pic/item/346bd85c10385343bd094ffd9213b07ec88088ed.jpg\" alt=\"\"><br>命令执行成功;说明服务端与客户端都没有问题;</p>\n<p>如何自实rsync客户端自动与rsync服务器端同步呢?这里我们用到计划任务命令:crontab;</p>\n<p>首先,我们来做一个shell脚本,</p>\n<pre><code>[root@dbserver ~]#vi /tmp/rsyncd.sh\n\n#!/bin/bash\n\nrsync -aSvH /webapps/IDManage/ root@192.168.1.213::data --password-file=/etc/sery_client.pass\n\nwq!   ##保存退出\n\n[root@dbserver ~]#crontab -e\n\n*/5 * * * * sh /tmp/rsyncd.sh #第5分钟执行一次同步;\n\nwq!   ##保存退出\n</code></pre><p>看了,到此分享linux 命令rsync+crontab实现自动同步,已经结束;总结一点:rsync命令格式一定要知道:rsync [option] 源路径目标路径,目标路径的格式有几种,大家只要记得一两种便可以了;</p>\n","excerpt":"<p>linux 命令rsync+crontab实现自动同步,这个技术现在已经用得很广泛了,比起第三方的软件要可靠好使,所以得到系统管理员的广泛应用;在此,我给大伙来分享一下;请指教.</p>\n<p>首先,我们来了解一下这个命令:</p>\n<p>rsync命令格式:rsync [option] 源路径 目标路径;<br>","more":"<br>其中:  </p>\n<p>[option]:  </p>\n<pre><code>a:使用archive模式,等于-rlptgoD,即保持原有的文件权限;\n\nz:表示传输时压缩数据;\n\nv:显示到屏幕中;\n\ne:使用远程shell程序(可以使用rsh或ssh;\n\n--delete:精确保存副本,源主机删除的文件,目标主机也会同步删除;\n\n--include=PATTERN:不排除符合PATTERN的文件或目录;\n\n--exclude=PATTERN:排除所有符合PATTERN的文件或目录;\n\n--password-file:指定用于rsync服务器的用户验证密码;\n</code></pre><p>源路径和目标路径可以使用如下格式:</p>\n<pre><code>rsync://[USER@]Host[:Port]/Path #--rsync服务器路径;\n\n[USER@]Host::Path   #--rsync服务器的另一种表示形式;\n\n[USER@]Host:Path#--远程路径;\n\nLocalPath   #--本地路径;\n</code></pre><p>知道上述命令的基本格式了吗?</p>\n<p>下面我们来讲安装rsyn命令;</p>\n<pre><code>[root@dbserver ~]#yum list rsync*\n\nLoaded plugins: fastestmirror, refresh-packagekit, security\n\nLoading mirror speeds from cached hostfile\n\n * rpmforge: mirrors.neusoft.edu.cn\n\nInstalled Packages\n\nrsync.i686  3.0.6-9.el6   @anaconda-CentOS-201207051201.i386/6.3\n\n[root@dbserver ~]#yum -y install rsync*\n</code></pre><p>前面是查看rsync RPM包,后面是安装rsync这个命令;</p>\n<p>安装完后,我们便可以来配置rsync服务器与客服端了;</p>\n<p>实例:</p>\n<p>A服务器:192.168.1.213</p>\n<p>B客户端:192.168.1.210</p>\n<p>首先人们配置服务器,look,</p>\n<p>在配置服务器之前要先生成密钥,ssh-keygen -t rsa,生成密钥如下:</p>\n<pre><code>[root@masternagios .ssh]# ls\n\nid_rsa  id_rsa.pub\n\n[root@masternagios .ssh]#  scp id_rsa_pub root@192.168.1.210:/root/.ssh/authorized_keys\n</code></pre><p>在客户端也要如下操作:</p>\n<pre><code>[root@masternagios .ssh]# ssh-keygen -t rsa\n\n[root@masternagios .ssh]# ls\n\nid_rsa  id_rsa.pub  authorized_keys(213的公钥)\n\n[root@masternagios.ssh]#\n\nscp id_rsa_pub root@192.168.1.213:/root/.ssh/authorized_keys\n</code></pre><p>这样两台机可以无密码SSH登陆,以便后面我们同步方便;当然,不要上述的操作也能实现;那么如下操作:</p>\n<p>服务端:</p>\n<pre><code>vi /etc/sery.pass  权限:600(chmod 600 /etc/sery.pass)\n\nroot:123456\n</code></pre><p>客服端:</p>\n<pre><code>vi /etc/sery_client.pass  权限:600(chmod 600 /etc/sery_client.pass)\n\n123456\n</code></pre><p>生成的这两件文件后面有用处的;</p>\n<p>然后新建配置文件vi /etc/rsyncd.conf,内容如下图示:<br><img src=\"http://hiphotos.baidu.com/exp/pic/item/d872d695d143ad4b038f881c83025aafa50f060e.jpg\" alt=\"\"><br>解析如下:</p>\n<pre><code>uid = root           #root用户访问(我这里用ROOT用户,也可以用其他新建的用户)\n\ngid = root           #root组用户访问\n\nuse chroot = no      #不能使用chroot\n\nmax connections = 10  #最大连接数\n\nlist = yes           #允许列出文件清单\n\npid file = /var/run/rsyncd.pid\n\nlock file = /var/run/rsyncd.lock\n\nlog file = /var/log/rsyncd.log\n\nhosts allow  = 192.168.1.2      #只允许这个主机访问\n</code></pre><p>   [data]                    #发布项(注意这个命名)</p>\n<pre><code>path = /webapps/IDManage         #发布的路径\n\nignore errors\n\nread only = yes            #只读\n\nauth users = root                #认证用户为root\n\nsecrets file = /etc/sery.pass    #密码文件\n</code></pre><p>然后我们来启动:</p>\n<p>[root@masternagios ~]# rsync –daemon –config=/etc/rsyncd.conf</p>\n<pre><code>[root@masternagios ~]# ps -ef |grep rsync\n\nroot     21359     1  0 Aug24 ?        00:00:00 rsync --daemon --     config=/etc/rsyncd.conf\n\nroot     24018 23885  0 10:38 pts/0    00:00:00 grep rsync\n\n[root@masternagios ~]#lsof -i:873\n\nCOMMAND   PID USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME\n\nrsync   21359 root    4u  IPv4 1558266      0t0  TCP *:rsync (LISTEN)\n\nrsync   21359 root    5u  IPv6 1558267      0t0  TCP *:rsync (LISTEN)\n</code></pre><p>然后在客户端测试:</p>\n<pre><code>[root@dbserver ~]# telnet 192.168.1.213 873\n\nTrying 192.168.1.213...\n\nConnected to 192.168.1.213.\n\nEscape character is &apos;^]&apos;.\n\n@RSYNCD: 30.0\n\n^]\n\ntelnet&gt; q\n\nConnection closed.\n</code></pre><p>说明网络端口开放,没有问题;通常在这配置时会发现一些问题,比如报错(111)–说明服务器端口未开启,就检查一下rsync服务有没有开启;</p>\n<p>报错(1503)(1536)–说明无 [data] #发布项(注意这个命名),这里命令一定要对应上同步::[data];</p>\n<p>我们再来把服务端rsync加自动启动;</p>\n<pre><code>echo &quot;/usr/bin/rsync --daemon --config=/etc/rsyncd.conf&quot; &gt;&gt;/etc/rc.local\n</code></pre><p>配置客户端;</p>\n<p>客户端只要安装rsync这个命令便可以实现,所以,我们来测试同步实现;</p>\n<pre><code>[root@dbserver ~]#rsync -aSvH /webapps/IDManage/ root@192.168.1.213::data --password-file=/etc/sery_client.pass\n</code></pre><p>可以看到:<br><img src=\"http://hiphotos.baidu.com/exp/pic/item/346bd85c10385343bd094ffd9213b07ec88088ed.jpg\" alt=\"\"><br>命令执行成功;说明服务端与客户端都没有问题;</p>\n<p>如何自实rsync客户端自动与rsync服务器端同步呢?这里我们用到计划任务命令:crontab;</p>\n<p>首先,我们来做一个shell脚本,</p>\n<pre><code>[root@dbserver ~]#vi /tmp/rsyncd.sh\n\n#!/bin/bash\n\nrsync -aSvH /webapps/IDManage/ root@192.168.1.213::data --password-file=/etc/sery_client.pass\n\nwq!   ##保存退出\n\n[root@dbserver ~]#crontab -e\n\n*/5 * * * * sh /tmp/rsyncd.sh #第5分钟执行一次同步;\n\nwq!   ##保存退出\n</code></pre><p>看了,到此分享linux 命令rsync+crontab实现自动同步,已经结束;总结一点:rsync命令格式一定要知道:rsync [option] 源路径目标路径,目标路径的格式有几种,大家只要记得一两种便可以了;</p>"},{"title":"linux—SSH1","date":"2016-09-02T04:00:00.000Z","_content":"一、远程连接简介\n\nl  远程连接服务器\n\n远程连接服务器通过文字或图形接口的方式来远程登陆系统，在远程的终端前面登陆linux主机并取得操作主机的接口shell，登陆后的操作就像在系统前面一样，这样可以进行系统管理的任务\n<!--more-->\nl  工作站\n\n工作站就是仅提供大量的运作能力给用户而不提供因特网服务的主机\n\nl  当前远程连接的登陆类型\n\n1、加密的远程连接\n\n主要是ssh，也是用到的最多最安全的，而且还可以使用rsync通过ssh协议来进行异地备份\n\n2、图形接口的远程连接\n\nXDMCP、VNC和XRDP，这些方式由于是传输图形所以速度慢，且安全性也不是很好\n\n二、远程连接之SSH\n\nSsh是secure shell protocol（安全的壳程序协议）的简写，可以通过数据包加密技术将传输的数据包加密后再传输到网络上，当前ssh有两个版本，其中version2加上了连接检测的机制，可以避免连接期间被插入恶意攻击码\n\nl  Ssh服务器提供的功能\n\n默认的ssh服务器提供两个服务器功能\n\n1、ssh服务\n\n类似telnet的远程连接，使用shell的服务器，可以用来管理服务器\n\n2、ftp服务\n\n类似ftp服务的sftp-server，可以用来远程上传和下载\n\nl  连接的加密技术\n\n当前常见的网络数据包加密技术主要是通过非对称秘钥系统来处理的，主要是通过两把不同的公钥（public key）和私钥（private key）来进行数据的加密与解密的，且在同一个方向上的连接中这两把钥匙是成对存在的。每台主机都应该有自己的秘钥（公钥和私钥），并且公钥用于加密而私钥用于解密\n\n1、公钥（public key）\n\n提供给远程主机进行数据加密的行为，所有客户端都能取得它进行数据加密\n\n2、私钥（private key）\n\n远程主机使用公钥加密的数据在本地就需要使用私钥进行解密了，其非常重要只能在自己的主机上\n\nl  Ssh服务器端与客户端的链接步骤\n\n1、服务器建立公钥文件\n\n系统安装完成时sshd会朱勇去计算出需要的公钥文件和自己需要的私钥文件，等下次再次启动sshd的时候该服务就会主动去找文件/etc/ssh/ssh_host*\n\n2、客户端主动链接\n\n需要使用客户端程序（如ssh）来连接\n\n3、服务器传送公钥文件给客户端\n\n服务器将将取得的公钥文件/etc/ssh/ssh_host*传送给客户端（由于公钥是给大家使用的，所以此时的传送是明文的）\n\n4、客户端记录并比对该公钥数据，然后计算出自己的公钥和私钥\n\n客户端在第一次连接该服务器后会将服务器的公钥数据记录到客户端的用户主目录下的~ /.ssh/known_hosts内，如果已经记录过该数据则客户端会去比对此次受到的公钥与之前的差异，若接受此次公钥数据那么会计算出客户端自己的公钥和私钥\n\n5、客户端将自己的公钥传送给服务器\n\n此时服务器端会有自己的私钥和客户端的公钥；而客户端会有服务器的公钥和自己的私钥，这时服务器与客户端的秘钥（公钥与私钥）是不一样的，所以才称之为非对称式秘钥系统\n\n6、服务器开始进行双向加解密\n\n1)   服务器传送数据到客户端\n\n将用户的公钥加密后进行发送，客户端接收后用自己的私钥解密\n\n2)   客户端传送数据到服务器\n\n将服务器的公钥加密后进行发送，服务器接受后用自己的私钥解密\n\nl  秘钥文件的建立\n\n1、服务器端启动ssh服务，以生成服务器端的公钥和私钥\n\n\n    [root@baobao ~]# /etc/init.d/sshd restart\n\n停止 sshd：                                                [确定]\n\n生成 SSH1 RSA 主机键：                                     [确定]\n\n生成 SSH2 RSA 主机键：                                     [确定]\n\n正在生成 SSH2 DSA 主机键：                                 [确定]\n\n正在启动 sshd：                                            [确定]\n\n2、客户端利用ssh连接服务器\n\n\n    [root@abao ~]# ssh 172.168.72.68\n\n    The authenticity of host ‘172.168.72.68 (172.168.72.68)’ can’tbe established.\n    \n    RSA key fingerprint is36:cf:9f:46:54:46:4b:b3:b0:48:4a:93:4d:14:81:56.\n    \n    Are you sure you want to continue connecting (yes/no)? yes\n    \n    Warning: Permanently added ‘172.168.72.68’ (RSA) to the list ofknown hosts.\n    \n    root@172.168.72.68’s password:\n    \n    Last login: Sun Sep 28 15:37:10 2014 from localhost\n    \n    [root@baobao ~]# exit\n    \n    logout\n    \n    Connection to 172.168.72.68 closed.\n\n3、删除客户端的秘钥文件\n\n    [root@abao ~]# rm /etc/ssh/ssh_host*\n    \n    rm：是否删除普通文件 “/etc/ssh/ssh_host_dsa_key”？y\n    \n    rm：是否删除普通文件 “/etc/ssh/ssh_host_dsa_key.pub”？y\n    \n    rm：是否删除普通文件 “/etc/ssh/ssh_host_key”？y\n    \n    rm：是否删除普通文件 “/etc/ssh/ssh_host_key.pub”？y\n    \n    rm：是否删除普通文件 “/etc/ssh/ssh_host_rsa_key”？y\n    \n    rm：是否删除普通文件 “/etc/ssh/ssh_host_rsa_key.pub”？y\n\n4、重新启动客户端的sshd服务以查看秘钥文件的建立过程\n\n    [root@abao ~]# /etc/init.d/sshd restart\n    \n    停止 sshd：[确定]\n    \n    生成 SSH1 RSA 主机键： [确定]\n    \n    生成 SSH2 RSA 主机键： [确定]\n    \n    正在生成 SSH2 DSA 主机键： [确定]\n    \n    正在启动 sshd：[确定]\n    \nl  Sshd服务的启动\n\n    [root@baobao ~]# /etc/init.d/sshd restart\n    \n    停止 sshd：[确定]\n    \n    正在启动 sshd：[确定]\n    \n    [root@baobao ~]# netstat -tlnp | grep ssh #注意ssh服务是tcp端口22\n    \n    tcp 0  0 0.0.0.0:22  0.0.0.0:*LISTEN 9262/sshd\n    \n    tcp 0  0:::22:::* LISTEN 9262/sshd\n\n在linux系统中默认就有ssh所需要的软件了，包括可以产生密码等协议的OpenSSL软件和OpenSSH软件，而且在当前的linux系统中都是默认启动ssh的。这个sshd可以同时提供shell与ftp，而且都是在tcp端口22\n\nl  Linux用户ssh客户端的连接程序\n\nLinux客户端默认情况下是可以正常使用ssh的而不必安装额外的软件，而且其默认是启动的\n\n1、 直接登录远程主机的指令ssh（可用作服务器管理）\n\nSsh命令格式为：ssh [-f][-o参数项目][-p非标准端口][账号@]IP地址[命令]\n\n1)   Ssh命令参数介绍\n\n-f：     需要配合后面的[命令]，不登陆远程主机直接发送一个命令过去而已\n\n-o：     主要的参数有：ConnectTimeout=秒数：连接等到的秒数，减少等待的时间\n\nStrictHostKeyChecking=yes/no/ask：默认是ask，如果想要public key主动加入known_host这里设置为no\n\n-p：     如果sshd服务启动在非标准的端口需使用该项目[命令]，不登陆远程主机直接发送一个命令过去，但与-f意义不太相同\n\n2)   ssh使用范例\n\nA：直接登录到远程主机\n\n    [root@abao ~]# ssh 172.168.72.68\n    \n    The authenticity of host ‘172.168.72.68 (172.168.72.68)’ can’tbe established.\n    \n    RSA key fingerprint is36:cf:9f:46:54:46:4b:b3:b0:48:4a:93:4d:14:81:56.   #远程服务器的公钥指纹码\n    \n    Are you sure you want to continue connecting (yes/no)? yes   #将上述指纹码写入服务器公钥记录文件~ /.ssh/known_hosts，等再次登录时就不会出现该指纹码提示了。一定要yes而不是y\n    \n    Warning: Permanently added ‘172.168.72.68’ (RSA) to the list ofknown hosts.\n    \n    root@172.168.72.68’s password:#远程主机的root密码\n    \n    Last login: Sun Sep 28 15:37:10 2014 from localhost\n    \n    [root@baobao ~]# exit #退出远程连接\n    \n    logout\n    \n    Connection to 172.168.72.68 closed.\n\n一般我们使用“ssh 账号 主机IP地址”的登录方式，如果不写账号的话那么会以本地计算机的当前账号来尝试登录远程主机\n\nB：再次登录远程主机\n\n    [root@abao ~]# ssh 172.168.72.68\n    \n    root@172.168.72.68’s password:\n    \n    Last login: Sun Sep 28 16:42:05 2014 from aca84448.ipt.aol.com\n\nC：使用账号axing登录\n\n    [root@baobao ~]# ssh axing@172.168.72.68\n    \n    The authenticity of host ‘172.168.72.68 (172.168.72.68)’ can’tbe established.\n    \n    RSA key fingerprint is 36:cf:9f:46:54:46:4b:b3:b0:48:4a:93:4d:14:81:56.\n    \n    Are you sure you want to continue connecting (yes/no)? yes\n    \n    Warning: Permanently added ‘172.168.72.68’ (RSA) to the list ofknown hosts.\n    \n    axing@172.168.72.68’s password:\n    \n    [axing@baobao ~]$   #远程登陆后身份变为axing\n    \nD：远程登陆执行命令后立刻离开\n\n    [root@abao ~]# ssh axing@172.168.72.68 find / -name passwd  #既后面直接加命令\n    \n    axing@172.168.72.68’s password:\n    \n卡在这里等待命令的执行完毕\n\nE：让远程主机自动运行命令而立刻回到本地端继续工作\n    \n    [root@abao ~]# ssh -faxing@172.168.72.68 shutdown -h now\n    \n    axing@172.168.72.68’s password:\n\nF：自动加上公钥记录而不再询问\n\n    [root@abao ~]# rm ~/.ssh/known_hosts\n    \n    rm：是否删除普通文件 “/root/.ssh/known_hosts”？y\n    \n    [root@abao ~]# ssh -o StrictHostKeyChecking=no root@172.168.72.68#不在要求输入yes或no了\n    \n    Warning: Permanently added ‘172.168.72.68’ (RSA) to the list ofknown hosts.\n    \n    root@172.168.72.68’s password:\n    \n    Last login: Mon Sep 29 14:00:28 2014 from aca84448.ipt.aol.com\n    \n2、服务器公钥记录文件~ /.ssh/known_hosts\n\n当远程登陆服务器时本机会主动将从服务器收到的公钥服务器公钥记录文件~ /.ssh/known_hosts进行比对，如果服务器的公钥文件还没有记录那么就会主动询问是否记录（登陆时候的yes或no行为）；如果收到的公钥已经记录那么会比对记录是否相同，如果相同则继续登陆，如果不同就会离开登陆而返回。但是如果是服务器重新安装那么服务器的公钥就会经常变化，这样的话我们就无法正常远程登陆了\n\nA：模拟服务器重新安装后ssh登陆\n\n    [root@baobao ~]# rm /etc/ssh/ssh_host*\n    \n    rm：是否删除普通文件 “/etc/ssh/ssh_host_dsa_key”？y\n    \n    rm：是否删除普通文件 “/etc/ssh/ssh_host_dsa_key.pub”？y\n    \n    rm：是否删除普通文件 “/etc/ssh/ssh_host_key”？y\n    \n    rm：是否删除普通文件 “/etc/ssh/ssh_host_key.pub”？y\n    \n    rm：是否删除普通文件 “/etc/ssh/ssh_host_rsa_key”？y\n    \n    rm：是否删除普通文件 “/etc/ssh/ssh_host_rsa_key.pub”？y\n    \n    [root@baobao ~]# /etc/init.d/sshd restart\n    \n    停止 sshd：[确定]\n    \n    生成 SSH1 RSA 主机键： [确定]\n    \n    生成 SSH2 RSA 主机键： [确定]\n    \n    正在生成 SSH2 DSA 主机键： [确定]\n    \n    正在启动 sshd：[确定]\n    \n    [root@baobao ~]# ssh 172.168.72.68\n    \n    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n    \n    @WARNING: REMOTE HOSTIDENTIFICATION HAS CHANGED! @\n    \n    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n    \n    IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\n    \n    Someone could be eavesdropping on you right now(man-in-the-middle attack)!\n    \n    It is also possible that the RSA host key has just been changed.\n    \n    The fingerprint for the RSA key sent by the remote host is\n    \n    17:7e:8e:e9:fd:df:1c:e5:c9:9d:cd:30:31:5e:a6:45.\n    \n    Please contact your system administrator.\n    \n    Add correct host key in /root/.ssh/known_hosts to get rid ofthis message.\n    \n    Offending key in /root/.ssh/known_hosts:2#有问题的数据行号\n    \n    RSA host key for 172.168.72.68 has changed and you haverequested strict checking.\n    \n    Host key verification failed.\n    \nB：上述现象解决方法\n    \n    [root@baobao ~]# vim /root/.ssh/known_hosts  #清空该文件\n    \n    [root@baobao ~]# ssh 172.168.72.68\n    \n    The authenticity of host ‘172.168.72.68 (172.168.72.68)’ can’tbe established.\n    \n    RSA key fingerprint is17:7e:8e:e9:fd:df:1c:e5:c9:9d:cd:30:31:5e:a6:45.\n    \n    Are you sure you want to continue connecting (yes/no)? yes#记录公钥\n    \n    Warning: Permanently added ‘172.168.72.68’ (RSA) to the list ofknown hosts.\n    \n    root@172.168.72.68’s password:\n    \n    Last login: Mon Sep 29 14:28:46 2014 from aca84448.ipt.aol.com\n\n3、模拟FTP的文件传输之SFTP\n\n如果想要从远程服务器下载或上传文件就不能使用ssh了，而必须使用sftp或scp，这两个指令也是使用ssh的端口22，只是模拟成ftp与复制的操作而已\n\n1)   SFTP使用的命令\n\nSftp使用的命令与ftp是一样的\n\nA：针对远程服务器的命令\n\n跟linux服务器命令相同\n\nB：针对本机的命令\n\n在基本命令前面加“l”即代表是针对本机的操作，例如sftp> lcd /tmp进入本机的该目录\n\nC：针对资料的上传或下载的命令\n\nput [本地目录或文件][远程]或put [本地目录或文件]（这样会存储到远程主机的目录下）\n\nget [远程目录或文件][本机]或get [远程目录或文件]（这样会存储到当前本机所在目录）\n\n2)   Sftp的使用范例\n\nA：sftp的登陆于退出\n\n    [root@baobao ~]# sftp 172.168.72.68\n    \n    Connecting to 172.168.72.68…\n    \n    root@172.168.72.68’s password:\n    \n    sftp>\n    \n    或\n    \n    [root@baobao ~]# sftp axing@172.168.72.68\n    \n    Connecting to 172.168.72.68…\n    \n    axing@172.168.72.68’s password:\n    \n    sftp> exit\n\nB：上传与下载\n\n    sftp> pwd#查看当前在服务器的目录\n    \n    Remote working directory: /home/axing\n    \n    sftp> lls /etc/hosts #查看本机是否有该文件\n    \n    /etc/hosts\n    \n    sftp> put /etc/hosts #上传该文件到远程服务器\n    \n    Uploading /etc/hosts to /home/axing/hosts#上传到服务器的默认目录\n    \n    /etc/hosts 100%  1580.2KB/s   00:00\n    \n    sftp> ls\n    \n    hosts\n    \n    sftp> ls –a  #查看服务器该目录下的隐藏文件\n    \n    .   ..  .bash_history   .bash_logout.bash_profile   .bashrc .emacs\n    \n    .gnome2.mozillahosts\n    \n    sftp> lcd /tmp#切换到本地的目录/tmp下\n    \n    sftp> get .bashrc #从服务器下载该文件\n    \n    Fetching /home/axing/.bashrc to .bashrc\n    \n    /home/axing/.bashrc   100%  124 0.1KB/s  00:00\n    \n    sftp> lls –a #确认是否下载成功\n    \n    ……………………………………………\n    \n    baoaj  .bashrc  guoal   guobe  guobx guocq  guodj  pulse-Fhzh5o9BSGRy\n    \n    sftp> exit\n\n4、文件异地直接复制SCP\n\n当已经知道服务器上的文件名时可以使用该命令，该命令的上传和下载使用格式如下：\n\n上传：scp [-pr] [-l 速率] file [账号@]主机：目录名（：后没有空格）\n\n下载：scp [-pr] [-l 速率] [账号@]主机：file 目录名（file后有空格）\n\n1)   命令参数介绍\n\n-p：     保留文件的原有权限\n\n-r：     复制整个目录\n\n-l：     传输速率\n\n2)   Scp使用范例\n\nA：上传本地文件到远程服务器\n\n`[root@baobao ~]# scp /etc/hosts* axing@172.168.72.68:~     ` #上传到服务器的用户主目录下\n\naxing@172.168.72.68’s password:\n\nhosts                100% 158     0.2KB/s   00:00\n\nhosts.allow          100% 370     0.4KB/s   00:00\n\nhosts.deny           100% 460     0.5KB/s   00:00\n\nB：从服务器下载文件到本地\n\n    [root@baobao ~]# scp axing@172.168.72.68:/etc/bashrc /tmp\n    \n    axing@172.168.72.68’s password:\n    \n    bashrc   100%2681 2.6KB/s   00:00\n    \nl  windows用户ssh客户端的连接程序\n\n默认的windows并没有ssh的客户端程序，所以需要下载第三方软件才行，常见的有pietty、psftp和filezilla\n\n1、直接连接的pietty（可用作服务器管理）\n\n下载后安装即可使用，不过由于编码的问题中文会显示乱码需要设置该软件才行option—more options—features（右第二个打钩打开键盘数字）—connection—-ssh（右2only选择版本）\n\noption—font（脚本gb2312调整字符集支持中文）\n\n2、psftp\n\n下载后安装并启动，输入open172.168.72.68后连接即可\n\n3、filezilla\n\n下载后安装运行即可，是普通的中文界面ftp软件\n\nl  windows用户远程登陆管理服务器工具xshell（当前最好用的工具）\n\n1、xshell界面\n\n它是windows下当前最好用的远程管理软件，只需要你下载后安装即可使用，一般还有中文版，非常好用，以下是链接后的画面\n\n    Connecting to 172.168.72.68:22…\n    \n    Connection established.\n    \n    To escape to local shell, press ‘Ctrl+Alt+]’.  #回到本地shell\n    \n    Last login: Tue Sep 30 08:55:23 2014 from aca80058.ipt.aol.com\n    \n    [root@baobao ~]# ls\n    \n    123baoae  cheng  last.list  lsrootaf   图片\n    \n    anaconda-ks.cfg  baoagguo.txt  lsrootaa regular_express.txt.1  下载\n    \n    baoaa baoah  homelsrootab   xinzi.txt  音乐\n    \n    baoab   baoai  homefile  lsrootac   公共的 桌面\n    \n    ………………………………………………………\n    \n    [root@baobao ~]#\n\n2、xshell中文乱码解决法案\n\nXshell是个非常不错的工具。但很多时候中文显示为乱码的问题，解决方法其实很简单的，即把xshell编码方式改成UTF-8即可：[文件]–>[打开]–>在打开的session中选择连接的那个然后右键点击[属性] -> [终端]，编码选择为：Unicode(UTF-8)，然后重新连接服务器即可\n\n3、ssh远程登陆日志（重要）\n\n    [root@baobao ~]# cat /var/log/secure\n    \n    thenticationAgent, locale zh_CN.UTF-8)\n    \n    Sep 30 08:55:23 baobao sshd[2916]: Accepted password for rootfrom 172.168.0.88 port 57853 ssh2\n    \n    Sep 30 08:55:23 baobao sshd[2916]: pam_unix(sshd:session):session opened for user root by (uid=0)\n    \n    Sep 30 09:21:21 baobao sshd[3331]: Accepted password for rootfrom 172.168.0.88 port 52386 ssh2\n    \n    Sep 30 09:21:21 baobao sshd[3331]: pam_unix(sshd:session):session opened for user root by (uid=0)\n    \n    Sep 30 09:21:55 baobao sshd[2916]: pam_unix(sshd:session):session closed for user root\n\nl  sshd服务器配置\n\nsshd服务器的详细配置都放在/etc/ssh/sshd_config配置文件里，只要是没有被注释的就是默认值\n\n        [root@baobao ~]# vim /etc/ssh/sshd_config\n    \n    ……………………………………………………\n    \n    #Port 22   #也可以设置多个端口只要添加一行然后重启即可（不建议）\n    \n    #ListenAddress 0.0.0.0 #默认监听所有网卡的接口，如果想指定后面直接写ip即可\n    \n    Protocol 2 #ssh的协议版本\n    \n    # HostKey for protocol version 1   #下面是不同协议版本的秘钥文件host key\n    \n    #HostKey /etc/ssh/ssh_host_key\n    \n    # HostKeys for protocol version 2\n    \n    #HostKey /etc/ssh/ssh_host_rsa_key\n    \n    #HostKey /etc/ssh/ssh_host_dsa_key\n    \n    SyslogFacility AUTHPRIV #ssh登陆记录，默认是/var/log/secure\n    \n    #LoginGraceTime 2m  #登陆超时设置\n    \n    #PermitRootLogin yes#是否允许root登陆，默认是允许的，建议设置为no\n    \n    #StrictModes yes#是否让sshd检查相关权限以免用户将某些权限设置错误\n    \n    PasswordAuthentication yes  #密码验证，当然需要了\n    \n    #PermitEmptyPasswords no#是否允许空密码登陆，当然是no了\n    \n    #IgnoreUserKnownHosts no#是否忽略用户主文件记录，当然是no了\n    \n    #IgnoreRhosts yes   #是否取消~/.ssh/.rhosts认证，当然yes了\n    \n    ChallengeResponseAuthentication no  #该认证不安全，设置为no即可\n    \n    UsePAM yes#最好使用该认证模块记录与管理，所以yes\n    \n    #PrintLastLog yes #显示上次登陆的信息\n    \n    #TCPKeepAlive yes #网络不稳定时为了连接不中断可以设置为no\n    \n    #UsePrivilegeSeparation yes   #使用权限较低的程序来给用户操作\n    \n    DenyUsers #拒绝登陆的用户\n    \n    DenyGroups#拒绝登陆的组\n\n基本上ssh的默认设置已经就很安全了，不过还是建议将root的登陆权限取消，并将ssh的版本设置为2，而且通常这个文件不需要修改，如果修改了需要重启sshd\n\nl  制作不用密码接口登陆的ssh用户\n\n将客户端产生的key复制到服务器中，以后客户端再次登录的时候由于两者在ssh要连接的信号传递中已经比对过key了，所以不再需要输入密码了\n\n1、步骤一，客户端建立两把钥匙\n\n    [root@abao ~]# useradd abao\n    \n    [root@abao ~]# passwd abao\n    \n    更改用户 abao 的密码 。\n    \n    新的 密码：\n    \n    重新输入新的 密码：\n    \n    passwd： 所有的身份验证令牌已经成功更新。\n    \n    服务器上也做上面相同的用户配置\n    \n    [root@abao ~]# su – abao\n    \n    [abao@abao ~]$ ssh-keygen#默认以RSA建立两把钥匙\n    \n    Generating public/private rsa key pair.\n    \n    Enter file in which to save the key (/home/abao/.ssh/id_rsa): 回车\n    \n    Created directory ‘/home/abao/.ssh’. #建立主目录\n    \n    Enter passphrase (empty for no passphrase): 回车\n    \n    Enter same passphrase again: 回车\n    \n    Your identification has been saved in /home/abao/.ssh/id_rsa.   #私钥文件\n    \n    Your public key has been saved in /home/abao/.ssh/id_rsa.pub.   #公钥文件\n    \n    The key fingerprint is:\n    \n    89:1e:87:c9:a8:68:69:df:bd:75:a4:df:54:37:70:f1 abao@abao\n    \n    The key’s randomart image is:\n    \n    +–[ RSA 2048]—-+\n    \n    |   . |\n    \n    |o|\n    \n    | . .E|\n    \n    | o + .o  |\n    \n    |. * S  .   o.|\n    \n    | … . o  o   . o|\n    \n    |.+.   .  o . .  |\n    \n    |o . . . . o o|\n    \n    |   . . o.  . .   |\n    \n    +—————–+\n    \n    [abao@abao ~]$ ls -ld ~/.ssh; ls -l ~/.ssh\n    \n    drwx——. 2 abao abao 4096 9月  30 11:56 /home/abao/.ssh\n    \n    总用量 8\n    \n    -rw——-. 1 abao abao1675 9月  30 11:56 id_rsa\n    \n    -rw-r–r–. 1 abao abao  391 9月  3011:56 id_rsa.pub\n\n默认情况下建立私钥后权限和文件名放置位置都是正确的。身份必须是abao，当执行ssh-keygen的时候才会在用户主目录下生成两把钥匙，需要注意的是~/.ssh/目录必有700的权限，而且私钥文件的权限必须是-rw——-且属于abao才行，否则在秘钥比对中会被误判为危险而无法成功的以公私钥成对文件的机制实现连接\n\n2、步骤二，将公钥文件数据上传到服务器\n\n    [root@baobao ~]# useradd abao  #先在ssh服务器端建立上传文件账户abao\n    [root@baobao ~]# passwd abao\n    更改用户 abao 的密码 。\n    新的 密码：\n    重新输入新的 密码：\n    passwd： 所有的身份验证令牌已经成功更新。\n    [abao@abao ~]$ scp ~/.ssh/id_rsa.pub abao@172.168.72.68:~\n    \n    abao@172.168.72.68’s password:\n    \n    id_rsa.pub100%  3910.4KB/s   00:00\n\n3、步骤三，蒋公钥放置到服务器端的正确目录与文件名\n\n1)   服务器上建立文件~/.ssh\n\n    [root@baobao ~]# su – abao\n    \n    [abao@baobao ~]$ ls -ld .ssh\n    \n    ls: 无法访问.ssh: 没有那个文件或目录\n    \n    [abao@baobao ~]$ mkdir .ssh; chmod 700 .ssh  #注意其权限必须是700\n    \n    [abao@baobao ~]$ ls -ld .ssh\n    \n    drwx——. 2 abao abao 4096 9月  3012:30 .ssh\n\n2)   将公钥文件内的数据使用cat转存到authorized_keys内\n\n    [abao@baobao ~]$ ls -l *pub\n    \n    -rw-r–r–. 1 abao abao 391 9月  3012:26 id_rsa.pub\n    \n    [abao@baobao ~]$ cat id_rsa.pub >> .ssh/authorized_keys\n    \n    [abao@baobao ~]$ chmod 644 .ssh/authorized_keys\n    \n    [abao@baobao ~]$ ls -l .ssh\n    \n    总用量 4\n    \n    -rw-r–r–. 1 abao abao 391 9月  3012:39 authorized_keys\n\n总结：客户端必须制作出两把钥匙，其中私钥必须放到~/.ssh内；而公钥必须上传到服务器端并且放置到用户主目录下的~/.ssh/authorized_keys，同时目录的权限必须是700,而文件权限必须是644\n\n4、步骤四，验证\n\n    [root@abao ~]# ssh abao@172.168.72.68\n    \n    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n    \n    @WARNING: REMOTE HOSTIDENTIFICATION HAS CHANGED! @\n    \n    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n    \n    IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\n    \n    Someone could be eavesdropping on you right now(man-in-the-middle attack)!\n    \n    It is also possible that the RSA host key has just been changed.\n    \n    The fingerprint for the RSA key sent by the remote host is\n    \n    17:7e:8e:e9:fd:df:1c:e5:c9:9d:cd:30:31:5e:a6:45.\n    \n    Please contact your system administrator.\n    \n    Add correct host key in /root/.ssh/known_hosts to get rid ofthis message.\n    \n    Offending key in /root/.ssh/known_hosts:1\n    \n    RSA host key for 172.168.72.68 has changed and you haverequested strict checking.\n    \n    Host key verification failed.\n    \n    [root@abao ~]##看不再需要密码了\n    \n    [root@abao ~]# ifconfig   #查看服务器IP地址\n    \n    eth0  Linkencap:Ethernet  HWaddr00:0C:29:59:D9:E6\n    \n    inet addr:172.168.68.72  Bcast:172.168.255.255  Mask:255.255.0.0\n    \n    inet6 addr:fe80::20c:29ff:fe59:d9e6/64 Scope:Link\n    \n    UP BROADCASTRUNNING MULTICAST  MTU:1500  Metric:1\n    \n    RXpackets:239668 errors:0 dropped:0 overruns:0 frame:0\n    \n    TX packets:855errors:0 dropped:0 overruns:0 carrier:0\n    \n    collisions:0txqueuelen:1000\n    \n    RXbytes:18091942 (17.2 MiB)  TX bytes:71093(69.4 KiB)\n\nl  Ssh的安全设置\n\nSshd所谓的安全其实指的是它的数据加密功能，而对于sshd本身这个服务来说是很不安全的，所以如果不是特别需要请尽量限制在小范围内的几个ip或主机名即可\n\n1、 服务器本身的设置强化/etc/ssh/sshd——config\n\n\n    [root@baobao ~]# vim /etc/ssh/sshd_config\n\n1)   禁止root账号使用sshd服务\n\n    PermitRootLogin no                         #去掉注释并修改为no\n\n2)   禁止nossh这个组的用户使用sshd服务\n\n    DenyGroups nosh\n    \n3)   禁止用户testssh使用sshd服务\n\n    DenyUsers testssh\n    \n    [root@abao ~]# /etc/init.d/sshd restart\n    \n    停止 sshd：[确定]\n    \n    正在启动 sshd：[确定]\n    \n    [root@abao ~]# cat /var/log/secure #验证上述用户不能登陆后查看其日志\n    \n2、TCP Wrapper的使用\n\n    [root@baobao ~]# vim /etc/host.allow  #只允许内网和本机可以远程登陆\n    \n    sshd: 127.0.0.1 192.168.1.0/255.255.255.0192.168.10.0/255.255.255.0\n    \n    [root@baobao ~]# vim /etc/host.deny\n    \n    sshd: all\n\n3、iptables数据包过滤防火墙\n\n    [root@baobao ~]# iptables -A INPUT -i eth0 -s 192.168.1.0/24 -p tcp –dport 22 -j ACCEPT\n    \n    [root@baobao ~]# iptables -A INPUT -i eth0 -s 192.168.10.0/24 -p tcp –dport 22 -j ACCEPT\n    \n    [root@baobao ~]# /etc/init.d/iptables save\n    \n    [root@baobao ~]# /etc/init.d/iptables restart\n\n注意不要开放ssh的登陆权限给Internet上面的所有用户或主机，只开放给适当的部分用户或主机即可，否则会很不安全","source":"_posts/linux—SSH1.md","raw":"---\ntitle: linux—SSH1\ndate: 2016-09-02\ntags:\n---\n一、远程连接简介\n\nl  远程连接服务器\n\n远程连接服务器通过文字或图形接口的方式来远程登陆系统，在远程的终端前面登陆linux主机并取得操作主机的接口shell，登陆后的操作就像在系统前面一样，这样可以进行系统管理的任务\n<!--more-->\nl  工作站\n\n工作站就是仅提供大量的运作能力给用户而不提供因特网服务的主机\n\nl  当前远程连接的登陆类型\n\n1、加密的远程连接\n\n主要是ssh，也是用到的最多最安全的，而且还可以使用rsync通过ssh协议来进行异地备份\n\n2、图形接口的远程连接\n\nXDMCP、VNC和XRDP，这些方式由于是传输图形所以速度慢，且安全性也不是很好\n\n二、远程连接之SSH\n\nSsh是secure shell protocol（安全的壳程序协议）的简写，可以通过数据包加密技术将传输的数据包加密后再传输到网络上，当前ssh有两个版本，其中version2加上了连接检测的机制，可以避免连接期间被插入恶意攻击码\n\nl  Ssh服务器提供的功能\n\n默认的ssh服务器提供两个服务器功能\n\n1、ssh服务\n\n类似telnet的远程连接，使用shell的服务器，可以用来管理服务器\n\n2、ftp服务\n\n类似ftp服务的sftp-server，可以用来远程上传和下载\n\nl  连接的加密技术\n\n当前常见的网络数据包加密技术主要是通过非对称秘钥系统来处理的，主要是通过两把不同的公钥（public key）和私钥（private key）来进行数据的加密与解密的，且在同一个方向上的连接中这两把钥匙是成对存在的。每台主机都应该有自己的秘钥（公钥和私钥），并且公钥用于加密而私钥用于解密\n\n1、公钥（public key）\n\n提供给远程主机进行数据加密的行为，所有客户端都能取得它进行数据加密\n\n2、私钥（private key）\n\n远程主机使用公钥加密的数据在本地就需要使用私钥进行解密了，其非常重要只能在自己的主机上\n\nl  Ssh服务器端与客户端的链接步骤\n\n1、服务器建立公钥文件\n\n系统安装完成时sshd会朱勇去计算出需要的公钥文件和自己需要的私钥文件，等下次再次启动sshd的时候该服务就会主动去找文件/etc/ssh/ssh_host*\n\n2、客户端主动链接\n\n需要使用客户端程序（如ssh）来连接\n\n3、服务器传送公钥文件给客户端\n\n服务器将将取得的公钥文件/etc/ssh/ssh_host*传送给客户端（由于公钥是给大家使用的，所以此时的传送是明文的）\n\n4、客户端记录并比对该公钥数据，然后计算出自己的公钥和私钥\n\n客户端在第一次连接该服务器后会将服务器的公钥数据记录到客户端的用户主目录下的~ /.ssh/known_hosts内，如果已经记录过该数据则客户端会去比对此次受到的公钥与之前的差异，若接受此次公钥数据那么会计算出客户端自己的公钥和私钥\n\n5、客户端将自己的公钥传送给服务器\n\n此时服务器端会有自己的私钥和客户端的公钥；而客户端会有服务器的公钥和自己的私钥，这时服务器与客户端的秘钥（公钥与私钥）是不一样的，所以才称之为非对称式秘钥系统\n\n6、服务器开始进行双向加解密\n\n1)   服务器传送数据到客户端\n\n将用户的公钥加密后进行发送，客户端接收后用自己的私钥解密\n\n2)   客户端传送数据到服务器\n\n将服务器的公钥加密后进行发送，服务器接受后用自己的私钥解密\n\nl  秘钥文件的建立\n\n1、服务器端启动ssh服务，以生成服务器端的公钥和私钥\n\n\n    [root@baobao ~]# /etc/init.d/sshd restart\n\n停止 sshd：                                                [确定]\n\n生成 SSH1 RSA 主机键：                                     [确定]\n\n生成 SSH2 RSA 主机键：                                     [确定]\n\n正在生成 SSH2 DSA 主机键：                                 [确定]\n\n正在启动 sshd：                                            [确定]\n\n2、客户端利用ssh连接服务器\n\n\n    [root@abao ~]# ssh 172.168.72.68\n\n    The authenticity of host ‘172.168.72.68 (172.168.72.68)’ can’tbe established.\n    \n    RSA key fingerprint is36:cf:9f:46:54:46:4b:b3:b0:48:4a:93:4d:14:81:56.\n    \n    Are you sure you want to continue connecting (yes/no)? yes\n    \n    Warning: Permanently added ‘172.168.72.68’ (RSA) to the list ofknown hosts.\n    \n    root@172.168.72.68’s password:\n    \n    Last login: Sun Sep 28 15:37:10 2014 from localhost\n    \n    [root@baobao ~]# exit\n    \n    logout\n    \n    Connection to 172.168.72.68 closed.\n\n3、删除客户端的秘钥文件\n\n    [root@abao ~]# rm /etc/ssh/ssh_host*\n    \n    rm：是否删除普通文件 “/etc/ssh/ssh_host_dsa_key”？y\n    \n    rm：是否删除普通文件 “/etc/ssh/ssh_host_dsa_key.pub”？y\n    \n    rm：是否删除普通文件 “/etc/ssh/ssh_host_key”？y\n    \n    rm：是否删除普通文件 “/etc/ssh/ssh_host_key.pub”？y\n    \n    rm：是否删除普通文件 “/etc/ssh/ssh_host_rsa_key”？y\n    \n    rm：是否删除普通文件 “/etc/ssh/ssh_host_rsa_key.pub”？y\n\n4、重新启动客户端的sshd服务以查看秘钥文件的建立过程\n\n    [root@abao ~]# /etc/init.d/sshd restart\n    \n    停止 sshd：[确定]\n    \n    生成 SSH1 RSA 主机键： [确定]\n    \n    生成 SSH2 RSA 主机键： [确定]\n    \n    正在生成 SSH2 DSA 主机键： [确定]\n    \n    正在启动 sshd：[确定]\n    \nl  Sshd服务的启动\n\n    [root@baobao ~]# /etc/init.d/sshd restart\n    \n    停止 sshd：[确定]\n    \n    正在启动 sshd：[确定]\n    \n    [root@baobao ~]# netstat -tlnp | grep ssh #注意ssh服务是tcp端口22\n    \n    tcp 0  0 0.0.0.0:22  0.0.0.0:*LISTEN 9262/sshd\n    \n    tcp 0  0:::22:::* LISTEN 9262/sshd\n\n在linux系统中默认就有ssh所需要的软件了，包括可以产生密码等协议的OpenSSL软件和OpenSSH软件，而且在当前的linux系统中都是默认启动ssh的。这个sshd可以同时提供shell与ftp，而且都是在tcp端口22\n\nl  Linux用户ssh客户端的连接程序\n\nLinux客户端默认情况下是可以正常使用ssh的而不必安装额外的软件，而且其默认是启动的\n\n1、 直接登录远程主机的指令ssh（可用作服务器管理）\n\nSsh命令格式为：ssh [-f][-o参数项目][-p非标准端口][账号@]IP地址[命令]\n\n1)   Ssh命令参数介绍\n\n-f：     需要配合后面的[命令]，不登陆远程主机直接发送一个命令过去而已\n\n-o：     主要的参数有：ConnectTimeout=秒数：连接等到的秒数，减少等待的时间\n\nStrictHostKeyChecking=yes/no/ask：默认是ask，如果想要public key主动加入known_host这里设置为no\n\n-p：     如果sshd服务启动在非标准的端口需使用该项目[命令]，不登陆远程主机直接发送一个命令过去，但与-f意义不太相同\n\n2)   ssh使用范例\n\nA：直接登录到远程主机\n\n    [root@abao ~]# ssh 172.168.72.68\n    \n    The authenticity of host ‘172.168.72.68 (172.168.72.68)’ can’tbe established.\n    \n    RSA key fingerprint is36:cf:9f:46:54:46:4b:b3:b0:48:4a:93:4d:14:81:56.   #远程服务器的公钥指纹码\n    \n    Are you sure you want to continue connecting (yes/no)? yes   #将上述指纹码写入服务器公钥记录文件~ /.ssh/known_hosts，等再次登录时就不会出现该指纹码提示了。一定要yes而不是y\n    \n    Warning: Permanently added ‘172.168.72.68’ (RSA) to the list ofknown hosts.\n    \n    root@172.168.72.68’s password:#远程主机的root密码\n    \n    Last login: Sun Sep 28 15:37:10 2014 from localhost\n    \n    [root@baobao ~]# exit #退出远程连接\n    \n    logout\n    \n    Connection to 172.168.72.68 closed.\n\n一般我们使用“ssh 账号 主机IP地址”的登录方式，如果不写账号的话那么会以本地计算机的当前账号来尝试登录远程主机\n\nB：再次登录远程主机\n\n    [root@abao ~]# ssh 172.168.72.68\n    \n    root@172.168.72.68’s password:\n    \n    Last login: Sun Sep 28 16:42:05 2014 from aca84448.ipt.aol.com\n\nC：使用账号axing登录\n\n    [root@baobao ~]# ssh axing@172.168.72.68\n    \n    The authenticity of host ‘172.168.72.68 (172.168.72.68)’ can’tbe established.\n    \n    RSA key fingerprint is 36:cf:9f:46:54:46:4b:b3:b0:48:4a:93:4d:14:81:56.\n    \n    Are you sure you want to continue connecting (yes/no)? yes\n    \n    Warning: Permanently added ‘172.168.72.68’ (RSA) to the list ofknown hosts.\n    \n    axing@172.168.72.68’s password:\n    \n    [axing@baobao ~]$   #远程登陆后身份变为axing\n    \nD：远程登陆执行命令后立刻离开\n\n    [root@abao ~]# ssh axing@172.168.72.68 find / -name passwd  #既后面直接加命令\n    \n    axing@172.168.72.68’s password:\n    \n卡在这里等待命令的执行完毕\n\nE：让远程主机自动运行命令而立刻回到本地端继续工作\n    \n    [root@abao ~]# ssh -faxing@172.168.72.68 shutdown -h now\n    \n    axing@172.168.72.68’s password:\n\nF：自动加上公钥记录而不再询问\n\n    [root@abao ~]# rm ~/.ssh/known_hosts\n    \n    rm：是否删除普通文件 “/root/.ssh/known_hosts”？y\n    \n    [root@abao ~]# ssh -o StrictHostKeyChecking=no root@172.168.72.68#不在要求输入yes或no了\n    \n    Warning: Permanently added ‘172.168.72.68’ (RSA) to the list ofknown hosts.\n    \n    root@172.168.72.68’s password:\n    \n    Last login: Mon Sep 29 14:00:28 2014 from aca84448.ipt.aol.com\n    \n2、服务器公钥记录文件~ /.ssh/known_hosts\n\n当远程登陆服务器时本机会主动将从服务器收到的公钥服务器公钥记录文件~ /.ssh/known_hosts进行比对，如果服务器的公钥文件还没有记录那么就会主动询问是否记录（登陆时候的yes或no行为）；如果收到的公钥已经记录那么会比对记录是否相同，如果相同则继续登陆，如果不同就会离开登陆而返回。但是如果是服务器重新安装那么服务器的公钥就会经常变化，这样的话我们就无法正常远程登陆了\n\nA：模拟服务器重新安装后ssh登陆\n\n    [root@baobao ~]# rm /etc/ssh/ssh_host*\n    \n    rm：是否删除普通文件 “/etc/ssh/ssh_host_dsa_key”？y\n    \n    rm：是否删除普通文件 “/etc/ssh/ssh_host_dsa_key.pub”？y\n    \n    rm：是否删除普通文件 “/etc/ssh/ssh_host_key”？y\n    \n    rm：是否删除普通文件 “/etc/ssh/ssh_host_key.pub”？y\n    \n    rm：是否删除普通文件 “/etc/ssh/ssh_host_rsa_key”？y\n    \n    rm：是否删除普通文件 “/etc/ssh/ssh_host_rsa_key.pub”？y\n    \n    [root@baobao ~]# /etc/init.d/sshd restart\n    \n    停止 sshd：[确定]\n    \n    生成 SSH1 RSA 主机键： [确定]\n    \n    生成 SSH2 RSA 主机键： [确定]\n    \n    正在生成 SSH2 DSA 主机键： [确定]\n    \n    正在启动 sshd：[确定]\n    \n    [root@baobao ~]# ssh 172.168.72.68\n    \n    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n    \n    @WARNING: REMOTE HOSTIDENTIFICATION HAS CHANGED! @\n    \n    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n    \n    IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\n    \n    Someone could be eavesdropping on you right now(man-in-the-middle attack)!\n    \n    It is also possible that the RSA host key has just been changed.\n    \n    The fingerprint for the RSA key sent by the remote host is\n    \n    17:7e:8e:e9:fd:df:1c:e5:c9:9d:cd:30:31:5e:a6:45.\n    \n    Please contact your system administrator.\n    \n    Add correct host key in /root/.ssh/known_hosts to get rid ofthis message.\n    \n    Offending key in /root/.ssh/known_hosts:2#有问题的数据行号\n    \n    RSA host key for 172.168.72.68 has changed and you haverequested strict checking.\n    \n    Host key verification failed.\n    \nB：上述现象解决方法\n    \n    [root@baobao ~]# vim /root/.ssh/known_hosts  #清空该文件\n    \n    [root@baobao ~]# ssh 172.168.72.68\n    \n    The authenticity of host ‘172.168.72.68 (172.168.72.68)’ can’tbe established.\n    \n    RSA key fingerprint is17:7e:8e:e9:fd:df:1c:e5:c9:9d:cd:30:31:5e:a6:45.\n    \n    Are you sure you want to continue connecting (yes/no)? yes#记录公钥\n    \n    Warning: Permanently added ‘172.168.72.68’ (RSA) to the list ofknown hosts.\n    \n    root@172.168.72.68’s password:\n    \n    Last login: Mon Sep 29 14:28:46 2014 from aca84448.ipt.aol.com\n\n3、模拟FTP的文件传输之SFTP\n\n如果想要从远程服务器下载或上传文件就不能使用ssh了，而必须使用sftp或scp，这两个指令也是使用ssh的端口22，只是模拟成ftp与复制的操作而已\n\n1)   SFTP使用的命令\n\nSftp使用的命令与ftp是一样的\n\nA：针对远程服务器的命令\n\n跟linux服务器命令相同\n\nB：针对本机的命令\n\n在基本命令前面加“l”即代表是针对本机的操作，例如sftp> lcd /tmp进入本机的该目录\n\nC：针对资料的上传或下载的命令\n\nput [本地目录或文件][远程]或put [本地目录或文件]（这样会存储到远程主机的目录下）\n\nget [远程目录或文件][本机]或get [远程目录或文件]（这样会存储到当前本机所在目录）\n\n2)   Sftp的使用范例\n\nA：sftp的登陆于退出\n\n    [root@baobao ~]# sftp 172.168.72.68\n    \n    Connecting to 172.168.72.68…\n    \n    root@172.168.72.68’s password:\n    \n    sftp>\n    \n    或\n    \n    [root@baobao ~]# sftp axing@172.168.72.68\n    \n    Connecting to 172.168.72.68…\n    \n    axing@172.168.72.68’s password:\n    \n    sftp> exit\n\nB：上传与下载\n\n    sftp> pwd#查看当前在服务器的目录\n    \n    Remote working directory: /home/axing\n    \n    sftp> lls /etc/hosts #查看本机是否有该文件\n    \n    /etc/hosts\n    \n    sftp> put /etc/hosts #上传该文件到远程服务器\n    \n    Uploading /etc/hosts to /home/axing/hosts#上传到服务器的默认目录\n    \n    /etc/hosts 100%  1580.2KB/s   00:00\n    \n    sftp> ls\n    \n    hosts\n    \n    sftp> ls –a  #查看服务器该目录下的隐藏文件\n    \n    .   ..  .bash_history   .bash_logout.bash_profile   .bashrc .emacs\n    \n    .gnome2.mozillahosts\n    \n    sftp> lcd /tmp#切换到本地的目录/tmp下\n    \n    sftp> get .bashrc #从服务器下载该文件\n    \n    Fetching /home/axing/.bashrc to .bashrc\n    \n    /home/axing/.bashrc   100%  124 0.1KB/s  00:00\n    \n    sftp> lls –a #确认是否下载成功\n    \n    ……………………………………………\n    \n    baoaj  .bashrc  guoal   guobe  guobx guocq  guodj  pulse-Fhzh5o9BSGRy\n    \n    sftp> exit\n\n4、文件异地直接复制SCP\n\n当已经知道服务器上的文件名时可以使用该命令，该命令的上传和下载使用格式如下：\n\n上传：scp [-pr] [-l 速率] file [账号@]主机：目录名（：后没有空格）\n\n下载：scp [-pr] [-l 速率] [账号@]主机：file 目录名（file后有空格）\n\n1)   命令参数介绍\n\n-p：     保留文件的原有权限\n\n-r：     复制整个目录\n\n-l：     传输速率\n\n2)   Scp使用范例\n\nA：上传本地文件到远程服务器\n\n`[root@baobao ~]# scp /etc/hosts* axing@172.168.72.68:~     ` #上传到服务器的用户主目录下\n\naxing@172.168.72.68’s password:\n\nhosts                100% 158     0.2KB/s   00:00\n\nhosts.allow          100% 370     0.4KB/s   00:00\n\nhosts.deny           100% 460     0.5KB/s   00:00\n\nB：从服务器下载文件到本地\n\n    [root@baobao ~]# scp axing@172.168.72.68:/etc/bashrc /tmp\n    \n    axing@172.168.72.68’s password:\n    \n    bashrc   100%2681 2.6KB/s   00:00\n    \nl  windows用户ssh客户端的连接程序\n\n默认的windows并没有ssh的客户端程序，所以需要下载第三方软件才行，常见的有pietty、psftp和filezilla\n\n1、直接连接的pietty（可用作服务器管理）\n\n下载后安装即可使用，不过由于编码的问题中文会显示乱码需要设置该软件才行option—more options—features（右第二个打钩打开键盘数字）—connection—-ssh（右2only选择版本）\n\noption—font（脚本gb2312调整字符集支持中文）\n\n2、psftp\n\n下载后安装并启动，输入open172.168.72.68后连接即可\n\n3、filezilla\n\n下载后安装运行即可，是普通的中文界面ftp软件\n\nl  windows用户远程登陆管理服务器工具xshell（当前最好用的工具）\n\n1、xshell界面\n\n它是windows下当前最好用的远程管理软件，只需要你下载后安装即可使用，一般还有中文版，非常好用，以下是链接后的画面\n\n    Connecting to 172.168.72.68:22…\n    \n    Connection established.\n    \n    To escape to local shell, press ‘Ctrl+Alt+]’.  #回到本地shell\n    \n    Last login: Tue Sep 30 08:55:23 2014 from aca80058.ipt.aol.com\n    \n    [root@baobao ~]# ls\n    \n    123baoae  cheng  last.list  lsrootaf   图片\n    \n    anaconda-ks.cfg  baoagguo.txt  lsrootaa regular_express.txt.1  下载\n    \n    baoaa baoah  homelsrootab   xinzi.txt  音乐\n    \n    baoab   baoai  homefile  lsrootac   公共的 桌面\n    \n    ………………………………………………………\n    \n    [root@baobao ~]#\n\n2、xshell中文乱码解决法案\n\nXshell是个非常不错的工具。但很多时候中文显示为乱码的问题，解决方法其实很简单的，即把xshell编码方式改成UTF-8即可：[文件]–>[打开]–>在打开的session中选择连接的那个然后右键点击[属性] -> [终端]，编码选择为：Unicode(UTF-8)，然后重新连接服务器即可\n\n3、ssh远程登陆日志（重要）\n\n    [root@baobao ~]# cat /var/log/secure\n    \n    thenticationAgent, locale zh_CN.UTF-8)\n    \n    Sep 30 08:55:23 baobao sshd[2916]: Accepted password for rootfrom 172.168.0.88 port 57853 ssh2\n    \n    Sep 30 08:55:23 baobao sshd[2916]: pam_unix(sshd:session):session opened for user root by (uid=0)\n    \n    Sep 30 09:21:21 baobao sshd[3331]: Accepted password for rootfrom 172.168.0.88 port 52386 ssh2\n    \n    Sep 30 09:21:21 baobao sshd[3331]: pam_unix(sshd:session):session opened for user root by (uid=0)\n    \n    Sep 30 09:21:55 baobao sshd[2916]: pam_unix(sshd:session):session closed for user root\n\nl  sshd服务器配置\n\nsshd服务器的详细配置都放在/etc/ssh/sshd_config配置文件里，只要是没有被注释的就是默认值\n\n        [root@baobao ~]# vim /etc/ssh/sshd_config\n    \n    ……………………………………………………\n    \n    #Port 22   #也可以设置多个端口只要添加一行然后重启即可（不建议）\n    \n    #ListenAddress 0.0.0.0 #默认监听所有网卡的接口，如果想指定后面直接写ip即可\n    \n    Protocol 2 #ssh的协议版本\n    \n    # HostKey for protocol version 1   #下面是不同协议版本的秘钥文件host key\n    \n    #HostKey /etc/ssh/ssh_host_key\n    \n    # HostKeys for protocol version 2\n    \n    #HostKey /etc/ssh/ssh_host_rsa_key\n    \n    #HostKey /etc/ssh/ssh_host_dsa_key\n    \n    SyslogFacility AUTHPRIV #ssh登陆记录，默认是/var/log/secure\n    \n    #LoginGraceTime 2m  #登陆超时设置\n    \n    #PermitRootLogin yes#是否允许root登陆，默认是允许的，建议设置为no\n    \n    #StrictModes yes#是否让sshd检查相关权限以免用户将某些权限设置错误\n    \n    PasswordAuthentication yes  #密码验证，当然需要了\n    \n    #PermitEmptyPasswords no#是否允许空密码登陆，当然是no了\n    \n    #IgnoreUserKnownHosts no#是否忽略用户主文件记录，当然是no了\n    \n    #IgnoreRhosts yes   #是否取消~/.ssh/.rhosts认证，当然yes了\n    \n    ChallengeResponseAuthentication no  #该认证不安全，设置为no即可\n    \n    UsePAM yes#最好使用该认证模块记录与管理，所以yes\n    \n    #PrintLastLog yes #显示上次登陆的信息\n    \n    #TCPKeepAlive yes #网络不稳定时为了连接不中断可以设置为no\n    \n    #UsePrivilegeSeparation yes   #使用权限较低的程序来给用户操作\n    \n    DenyUsers #拒绝登陆的用户\n    \n    DenyGroups#拒绝登陆的组\n\n基本上ssh的默认设置已经就很安全了，不过还是建议将root的登陆权限取消，并将ssh的版本设置为2，而且通常这个文件不需要修改，如果修改了需要重启sshd\n\nl  制作不用密码接口登陆的ssh用户\n\n将客户端产生的key复制到服务器中，以后客户端再次登录的时候由于两者在ssh要连接的信号传递中已经比对过key了，所以不再需要输入密码了\n\n1、步骤一，客户端建立两把钥匙\n\n    [root@abao ~]# useradd abao\n    \n    [root@abao ~]# passwd abao\n    \n    更改用户 abao 的密码 。\n    \n    新的 密码：\n    \n    重新输入新的 密码：\n    \n    passwd： 所有的身份验证令牌已经成功更新。\n    \n    服务器上也做上面相同的用户配置\n    \n    [root@abao ~]# su – abao\n    \n    [abao@abao ~]$ ssh-keygen#默认以RSA建立两把钥匙\n    \n    Generating public/private rsa key pair.\n    \n    Enter file in which to save the key (/home/abao/.ssh/id_rsa): 回车\n    \n    Created directory ‘/home/abao/.ssh’. #建立主目录\n    \n    Enter passphrase (empty for no passphrase): 回车\n    \n    Enter same passphrase again: 回车\n    \n    Your identification has been saved in /home/abao/.ssh/id_rsa.   #私钥文件\n    \n    Your public key has been saved in /home/abao/.ssh/id_rsa.pub.   #公钥文件\n    \n    The key fingerprint is:\n    \n    89:1e:87:c9:a8:68:69:df:bd:75:a4:df:54:37:70:f1 abao@abao\n    \n    The key’s randomart image is:\n    \n    +–[ RSA 2048]—-+\n    \n    |   . |\n    \n    |o|\n    \n    | . .E|\n    \n    | o + .o  |\n    \n    |. * S  .   o.|\n    \n    | … . o  o   . o|\n    \n    |.+.   .  o . .  |\n    \n    |o . . . . o o|\n    \n    |   . . o.  . .   |\n    \n    +—————–+\n    \n    [abao@abao ~]$ ls -ld ~/.ssh; ls -l ~/.ssh\n    \n    drwx——. 2 abao abao 4096 9月  30 11:56 /home/abao/.ssh\n    \n    总用量 8\n    \n    -rw——-. 1 abao abao1675 9月  30 11:56 id_rsa\n    \n    -rw-r–r–. 1 abao abao  391 9月  3011:56 id_rsa.pub\n\n默认情况下建立私钥后权限和文件名放置位置都是正确的。身份必须是abao，当执行ssh-keygen的时候才会在用户主目录下生成两把钥匙，需要注意的是~/.ssh/目录必有700的权限，而且私钥文件的权限必须是-rw——-且属于abao才行，否则在秘钥比对中会被误判为危险而无法成功的以公私钥成对文件的机制实现连接\n\n2、步骤二，将公钥文件数据上传到服务器\n\n    [root@baobao ~]# useradd abao  #先在ssh服务器端建立上传文件账户abao\n    [root@baobao ~]# passwd abao\n    更改用户 abao 的密码 。\n    新的 密码：\n    重新输入新的 密码：\n    passwd： 所有的身份验证令牌已经成功更新。\n    [abao@abao ~]$ scp ~/.ssh/id_rsa.pub abao@172.168.72.68:~\n    \n    abao@172.168.72.68’s password:\n    \n    id_rsa.pub100%  3910.4KB/s   00:00\n\n3、步骤三，蒋公钥放置到服务器端的正确目录与文件名\n\n1)   服务器上建立文件~/.ssh\n\n    [root@baobao ~]# su – abao\n    \n    [abao@baobao ~]$ ls -ld .ssh\n    \n    ls: 无法访问.ssh: 没有那个文件或目录\n    \n    [abao@baobao ~]$ mkdir .ssh; chmod 700 .ssh  #注意其权限必须是700\n    \n    [abao@baobao ~]$ ls -ld .ssh\n    \n    drwx——. 2 abao abao 4096 9月  3012:30 .ssh\n\n2)   将公钥文件内的数据使用cat转存到authorized_keys内\n\n    [abao@baobao ~]$ ls -l *pub\n    \n    -rw-r–r–. 1 abao abao 391 9月  3012:26 id_rsa.pub\n    \n    [abao@baobao ~]$ cat id_rsa.pub >> .ssh/authorized_keys\n    \n    [abao@baobao ~]$ chmod 644 .ssh/authorized_keys\n    \n    [abao@baobao ~]$ ls -l .ssh\n    \n    总用量 4\n    \n    -rw-r–r–. 1 abao abao 391 9月  3012:39 authorized_keys\n\n总结：客户端必须制作出两把钥匙，其中私钥必须放到~/.ssh内；而公钥必须上传到服务器端并且放置到用户主目录下的~/.ssh/authorized_keys，同时目录的权限必须是700,而文件权限必须是644\n\n4、步骤四，验证\n\n    [root@abao ~]# ssh abao@172.168.72.68\n    \n    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n    \n    @WARNING: REMOTE HOSTIDENTIFICATION HAS CHANGED! @\n    \n    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n    \n    IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\n    \n    Someone could be eavesdropping on you right now(man-in-the-middle attack)!\n    \n    It is also possible that the RSA host key has just been changed.\n    \n    The fingerprint for the RSA key sent by the remote host is\n    \n    17:7e:8e:e9:fd:df:1c:e5:c9:9d:cd:30:31:5e:a6:45.\n    \n    Please contact your system administrator.\n    \n    Add correct host key in /root/.ssh/known_hosts to get rid ofthis message.\n    \n    Offending key in /root/.ssh/known_hosts:1\n    \n    RSA host key for 172.168.72.68 has changed and you haverequested strict checking.\n    \n    Host key verification failed.\n    \n    [root@abao ~]##看不再需要密码了\n    \n    [root@abao ~]# ifconfig   #查看服务器IP地址\n    \n    eth0  Linkencap:Ethernet  HWaddr00:0C:29:59:D9:E6\n    \n    inet addr:172.168.68.72  Bcast:172.168.255.255  Mask:255.255.0.0\n    \n    inet6 addr:fe80::20c:29ff:fe59:d9e6/64 Scope:Link\n    \n    UP BROADCASTRUNNING MULTICAST  MTU:1500  Metric:1\n    \n    RXpackets:239668 errors:0 dropped:0 overruns:0 frame:0\n    \n    TX packets:855errors:0 dropped:0 overruns:0 carrier:0\n    \n    collisions:0txqueuelen:1000\n    \n    RXbytes:18091942 (17.2 MiB)  TX bytes:71093(69.4 KiB)\n\nl  Ssh的安全设置\n\nSshd所谓的安全其实指的是它的数据加密功能，而对于sshd本身这个服务来说是很不安全的，所以如果不是特别需要请尽量限制在小范围内的几个ip或主机名即可\n\n1、 服务器本身的设置强化/etc/ssh/sshd——config\n\n\n    [root@baobao ~]# vim /etc/ssh/sshd_config\n\n1)   禁止root账号使用sshd服务\n\n    PermitRootLogin no                         #去掉注释并修改为no\n\n2)   禁止nossh这个组的用户使用sshd服务\n\n    DenyGroups nosh\n    \n3)   禁止用户testssh使用sshd服务\n\n    DenyUsers testssh\n    \n    [root@abao ~]# /etc/init.d/sshd restart\n    \n    停止 sshd：[确定]\n    \n    正在启动 sshd：[确定]\n    \n    [root@abao ~]# cat /var/log/secure #验证上述用户不能登陆后查看其日志\n    \n2、TCP Wrapper的使用\n\n    [root@baobao ~]# vim /etc/host.allow  #只允许内网和本机可以远程登陆\n    \n    sshd: 127.0.0.1 192.168.1.0/255.255.255.0192.168.10.0/255.255.255.0\n    \n    [root@baobao ~]# vim /etc/host.deny\n    \n    sshd: all\n\n3、iptables数据包过滤防火墙\n\n    [root@baobao ~]# iptables -A INPUT -i eth0 -s 192.168.1.0/24 -p tcp –dport 22 -j ACCEPT\n    \n    [root@baobao ~]# iptables -A INPUT -i eth0 -s 192.168.10.0/24 -p tcp –dport 22 -j ACCEPT\n    \n    [root@baobao ~]# /etc/init.d/iptables save\n    \n    [root@baobao ~]# /etc/init.d/iptables restart\n\n注意不要开放ssh的登陆权限给Internet上面的所有用户或主机，只开放给适当的部分用户或主机即可，否则会很不安全","slug":"linux—SSH1","published":1,"updated":"2017-03-01T05:59:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizqklz7s0008lbpvfstqfo89","content":"<p>一、远程连接简介</p>\n<p>l  远程连接服务器</p>\n<p>远程连接服务器通过文字或图形接口的方式来远程登陆系统，在远程的终端前面登陆linux主机并取得操作主机的接口shell，登陆后的操作就像在系统前面一样，这样可以进行系统管理的任务<br><a id=\"more\"></a><br>l  工作站</p>\n<p>工作站就是仅提供大量的运作能力给用户而不提供因特网服务的主机</p>\n<p>l  当前远程连接的登陆类型</p>\n<p>1、加密的远程连接</p>\n<p>主要是ssh，也是用到的最多最安全的，而且还可以使用rsync通过ssh协议来进行异地备份</p>\n<p>2、图形接口的远程连接</p>\n<p>XDMCP、VNC和XRDP，这些方式由于是传输图形所以速度慢，且安全性也不是很好</p>\n<p>二、远程连接之SSH</p>\n<p>Ssh是secure shell protocol（安全的壳程序协议）的简写，可以通过数据包加密技术将传输的数据包加密后再传输到网络上，当前ssh有两个版本，其中version2加上了连接检测的机制，可以避免连接期间被插入恶意攻击码</p>\n<p>l  Ssh服务器提供的功能</p>\n<p>默认的ssh服务器提供两个服务器功能</p>\n<p>1、ssh服务</p>\n<p>类似telnet的远程连接，使用shell的服务器，可以用来管理服务器</p>\n<p>2、ftp服务</p>\n<p>类似ftp服务的sftp-server，可以用来远程上传和下载</p>\n<p>l  连接的加密技术</p>\n<p>当前常见的网络数据包加密技术主要是通过非对称秘钥系统来处理的，主要是通过两把不同的公钥（public key）和私钥（private key）来进行数据的加密与解密的，且在同一个方向上的连接中这两把钥匙是成对存在的。每台主机都应该有自己的秘钥（公钥和私钥），并且公钥用于加密而私钥用于解密</p>\n<p>1、公钥（public key）</p>\n<p>提供给远程主机进行数据加密的行为，所有客户端都能取得它进行数据加密</p>\n<p>2、私钥（private key）</p>\n<p>远程主机使用公钥加密的数据在本地就需要使用私钥进行解密了，其非常重要只能在自己的主机上</p>\n<p>l  Ssh服务器端与客户端的链接步骤</p>\n<p>1、服务器建立公钥文件</p>\n<p>系统安装完成时sshd会朱勇去计算出需要的公钥文件和自己需要的私钥文件，等下次再次启动sshd的时候该服务就会主动去找文件/etc/ssh/ssh_host*</p>\n<p>2、客户端主动链接</p>\n<p>需要使用客户端程序（如ssh）来连接</p>\n<p>3、服务器传送公钥文件给客户端</p>\n<p>服务器将将取得的公钥文件/etc/ssh/ssh_host*传送给客户端（由于公钥是给大家使用的，所以此时的传送是明文的）</p>\n<p>4、客户端记录并比对该公钥数据，然后计算出自己的公钥和私钥</p>\n<p>客户端在第一次连接该服务器后会将服务器的公钥数据记录到客户端的用户主目录下的~ /.ssh/known_hosts内，如果已经记录过该数据则客户端会去比对此次受到的公钥与之前的差异，若接受此次公钥数据那么会计算出客户端自己的公钥和私钥</p>\n<p>5、客户端将自己的公钥传送给服务器</p>\n<p>此时服务器端会有自己的私钥和客户端的公钥；而客户端会有服务器的公钥和自己的私钥，这时服务器与客户端的秘钥（公钥与私钥）是不一样的，所以才称之为非对称式秘钥系统</p>\n<p>6、服务器开始进行双向加解密</p>\n<p>1)   服务器传送数据到客户端</p>\n<p>将用户的公钥加密后进行发送，客户端接收后用自己的私钥解密</p>\n<p>2)   客户端传送数据到服务器</p>\n<p>将服务器的公钥加密后进行发送，服务器接受后用自己的私钥解密</p>\n<p>l  秘钥文件的建立</p>\n<p>1、服务器端启动ssh服务，以生成服务器端的公钥和私钥</p>\n<pre><code>[root@baobao ~]# /etc/init.d/sshd restart\n</code></pre><p>停止 sshd：                                                [确定]</p>\n<p>生成 SSH1 RSA 主机键：                                     [确定]</p>\n<p>生成 SSH2 RSA 主机键：                                     [确定]</p>\n<p>正在生成 SSH2 DSA 主机键：                                 [确定]</p>\n<p>正在启动 sshd：                                            [确定]</p>\n<p>2、客户端利用ssh连接服务器</p>\n<pre><code>[root@abao ~]# ssh 172.168.72.68\n\nThe authenticity of host ‘172.168.72.68 (172.168.72.68)’ can’tbe established.\n\nRSA key fingerprint is36:cf:9f:46:54:46:4b:b3:b0:48:4a:93:4d:14:81:56.\n\nAre you sure you want to continue connecting (yes/no)? yes\n\nWarning: Permanently added ‘172.168.72.68’ (RSA) to the list ofknown hosts.\n\nroot@172.168.72.68’s password:\n\nLast login: Sun Sep 28 15:37:10 2014 from localhost\n\n[root@baobao ~]# exit\n\nlogout\n\nConnection to 172.168.72.68 closed.\n</code></pre><p>3、删除客户端的秘钥文件</p>\n<pre><code>[root@abao ~]# rm /etc/ssh/ssh_host*\n\nrm：是否删除普通文件 “/etc/ssh/ssh_host_dsa_key”？y\n\nrm：是否删除普通文件 “/etc/ssh/ssh_host_dsa_key.pub”？y\n\nrm：是否删除普通文件 “/etc/ssh/ssh_host_key”？y\n\nrm：是否删除普通文件 “/etc/ssh/ssh_host_key.pub”？y\n\nrm：是否删除普通文件 “/etc/ssh/ssh_host_rsa_key”？y\n\nrm：是否删除普通文件 “/etc/ssh/ssh_host_rsa_key.pub”？y\n</code></pre><p>4、重新启动客户端的sshd服务以查看秘钥文件的建立过程</p>\n<pre><code>[root@abao ~]# /etc/init.d/sshd restart\n\n停止 sshd：[确定]\n\n生成 SSH1 RSA 主机键： [确定]\n\n生成 SSH2 RSA 主机键： [确定]\n\n正在生成 SSH2 DSA 主机键： [确定]\n\n正在启动 sshd：[确定]\n</code></pre><p>l  Sshd服务的启动</p>\n<pre><code>[root@baobao ~]# /etc/init.d/sshd restart\n\n停止 sshd：[确定]\n\n正在启动 sshd：[确定]\n\n[root@baobao ~]# netstat -tlnp | grep ssh #注意ssh服务是tcp端口22\n\ntcp 0  0 0.0.0.0:22  0.0.0.0:*LISTEN 9262/sshd\n\ntcp 0  0:::22:::* LISTEN 9262/sshd\n</code></pre><p>在linux系统中默认就有ssh所需要的软件了，包括可以产生密码等协议的OpenSSL软件和OpenSSH软件，而且在当前的linux系统中都是默认启动ssh的。这个sshd可以同时提供shell与ftp，而且都是在tcp端口22</p>\n<p>l  Linux用户ssh客户端的连接程序</p>\n<p>Linux客户端默认情况下是可以正常使用ssh的而不必安装额外的软件，而且其默认是启动的</p>\n<p>1、 直接登录远程主机的指令ssh（可用作服务器管理）</p>\n<p>Ssh命令格式为：ssh [-f][-o参数项目][-p非标准端口][账号@]IP地址[命令]</p>\n<p>1)   Ssh命令参数介绍</p>\n<p>-f：     需要配合后面的[命令]，不登陆远程主机直接发送一个命令过去而已</p>\n<p>-o：     主要的参数有：ConnectTimeout=秒数：连接等到的秒数，减少等待的时间</p>\n<p>StrictHostKeyChecking=yes/no/ask：默认是ask，如果想要public key主动加入known_host这里设置为no</p>\n<p>-p：     如果sshd服务启动在非标准的端口需使用该项目[命令]，不登陆远程主机直接发送一个命令过去，但与-f意义不太相同</p>\n<p>2)   ssh使用范例</p>\n<p>A：直接登录到远程主机</p>\n<pre><code>[root@abao ~]# ssh 172.168.72.68\n\nThe authenticity of host ‘172.168.72.68 (172.168.72.68)’ can’tbe established.\n\nRSA key fingerprint is36:cf:9f:46:54:46:4b:b3:b0:48:4a:93:4d:14:81:56.   #远程服务器的公钥指纹码\n\nAre you sure you want to continue connecting (yes/no)? yes   #将上述指纹码写入服务器公钥记录文件~ /.ssh/known_hosts，等再次登录时就不会出现该指纹码提示了。一定要yes而不是y\n\nWarning: Permanently added ‘172.168.72.68’ (RSA) to the list ofknown hosts.\n\nroot@172.168.72.68’s password:#远程主机的root密码\n\nLast login: Sun Sep 28 15:37:10 2014 from localhost\n\n[root@baobao ~]# exit #退出远程连接\n\nlogout\n\nConnection to 172.168.72.68 closed.\n</code></pre><p>一般我们使用“ssh 账号 主机IP地址”的登录方式，如果不写账号的话那么会以本地计算机的当前账号来尝试登录远程主机</p>\n<p>B：再次登录远程主机</p>\n<pre><code>[root@abao ~]# ssh 172.168.72.68\n\nroot@172.168.72.68’s password:\n\nLast login: Sun Sep 28 16:42:05 2014 from aca84448.ipt.aol.com\n</code></pre><p>C：使用账号axing登录</p>\n<pre><code>[root@baobao ~]# ssh axing@172.168.72.68\n\nThe authenticity of host ‘172.168.72.68 (172.168.72.68)’ can’tbe established.\n\nRSA key fingerprint is 36:cf:9f:46:54:46:4b:b3:b0:48:4a:93:4d:14:81:56.\n\nAre you sure you want to continue connecting (yes/no)? yes\n\nWarning: Permanently added ‘172.168.72.68’ (RSA) to the list ofknown hosts.\n\naxing@172.168.72.68’s password:\n\n[axing@baobao ~]$   #远程登陆后身份变为axing\n</code></pre><p>D：远程登陆执行命令后立刻离开</p>\n<pre><code>[root@abao ~]# ssh axing@172.168.72.68 find / -name passwd  #既后面直接加命令\n\naxing@172.168.72.68’s password:\n</code></pre><p>卡在这里等待命令的执行完毕</p>\n<p>E：让远程主机自动运行命令而立刻回到本地端继续工作</p>\n<pre><code>[root@abao ~]# ssh -faxing@172.168.72.68 shutdown -h now\n\naxing@172.168.72.68’s password:\n</code></pre><p>F：自动加上公钥记录而不再询问</p>\n<pre><code>[root@abao ~]# rm ~/.ssh/known_hosts\n\nrm：是否删除普通文件 “/root/.ssh/known_hosts”？y\n\n[root@abao ~]# ssh -o StrictHostKeyChecking=no root@172.168.72.68#不在要求输入yes或no了\n\nWarning: Permanently added ‘172.168.72.68’ (RSA) to the list ofknown hosts.\n\nroot@172.168.72.68’s password:\n\nLast login: Mon Sep 29 14:00:28 2014 from aca84448.ipt.aol.com\n</code></pre><p>2、服务器公钥记录文件~ /.ssh/known_hosts</p>\n<p>当远程登陆服务器时本机会主动将从服务器收到的公钥服务器公钥记录文件~ /.ssh/known_hosts进行比对，如果服务器的公钥文件还没有记录那么就会主动询问是否记录（登陆时候的yes或no行为）；如果收到的公钥已经记录那么会比对记录是否相同，如果相同则继续登陆，如果不同就会离开登陆而返回。但是如果是服务器重新安装那么服务器的公钥就会经常变化，这样的话我们就无法正常远程登陆了</p>\n<p>A：模拟服务器重新安装后ssh登陆</p>\n<pre><code>[root@baobao ~]# rm /etc/ssh/ssh_host*\n\nrm：是否删除普通文件 “/etc/ssh/ssh_host_dsa_key”？y\n\nrm：是否删除普通文件 “/etc/ssh/ssh_host_dsa_key.pub”？y\n\nrm：是否删除普通文件 “/etc/ssh/ssh_host_key”？y\n\nrm：是否删除普通文件 “/etc/ssh/ssh_host_key.pub”？y\n\nrm：是否删除普通文件 “/etc/ssh/ssh_host_rsa_key”？y\n\nrm：是否删除普通文件 “/etc/ssh/ssh_host_rsa_key.pub”？y\n\n[root@baobao ~]# /etc/init.d/sshd restart\n\n停止 sshd：[确定]\n\n生成 SSH1 RSA 主机键： [确定]\n\n生成 SSH2 RSA 主机键： [确定]\n\n正在生成 SSH2 DSA 主机键： [确定]\n\n正在启动 sshd：[确定]\n\n[root@baobao ~]# ssh 172.168.72.68\n\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\n@WARNING: REMOTE HOSTIDENTIFICATION HAS CHANGED! @\n\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\n\nSomeone could be eavesdropping on you right now(man-in-the-middle attack)!\n\nIt is also possible that the RSA host key has just been changed.\n\nThe fingerprint for the RSA key sent by the remote host is\n\n17:7e:8e:e9:fd:df:1c:e5:c9:9d:cd:30:31:5e:a6:45.\n\nPlease contact your system administrator.\n\nAdd correct host key in /root/.ssh/known_hosts to get rid ofthis message.\n\nOffending key in /root/.ssh/known_hosts:2#有问题的数据行号\n\nRSA host key for 172.168.72.68 has changed and you haverequested strict checking.\n\nHost key verification failed.\n</code></pre><p>B：上述现象解决方法</p>\n<pre><code>[root@baobao ~]# vim /root/.ssh/known_hosts  #清空该文件\n\n[root@baobao ~]# ssh 172.168.72.68\n\nThe authenticity of host ‘172.168.72.68 (172.168.72.68)’ can’tbe established.\n\nRSA key fingerprint is17:7e:8e:e9:fd:df:1c:e5:c9:9d:cd:30:31:5e:a6:45.\n\nAre you sure you want to continue connecting (yes/no)? yes#记录公钥\n\nWarning: Permanently added ‘172.168.72.68’ (RSA) to the list ofknown hosts.\n\nroot@172.168.72.68’s password:\n\nLast login: Mon Sep 29 14:28:46 2014 from aca84448.ipt.aol.com\n</code></pre><p>3、模拟FTP的文件传输之SFTP</p>\n<p>如果想要从远程服务器下载或上传文件就不能使用ssh了，而必须使用sftp或scp，这两个指令也是使用ssh的端口22，只是模拟成ftp与复制的操作而已</p>\n<p>1)   SFTP使用的命令</p>\n<p>Sftp使用的命令与ftp是一样的</p>\n<p>A：针对远程服务器的命令</p>\n<p>跟linux服务器命令相同</p>\n<p>B：针对本机的命令</p>\n<p>在基本命令前面加“l”即代表是针对本机的操作，例如sftp&gt; lcd /tmp进入本机的该目录</p>\n<p>C：针对资料的上传或下载的命令</p>\n<p>put [本地目录或文件][远程]或put [本地目录或文件]（这样会存储到远程主机的目录下）</p>\n<p>get [远程目录或文件][本机]或get [远程目录或文件]（这样会存储到当前本机所在目录）</p>\n<p>2)   Sftp的使用范例</p>\n<p>A：sftp的登陆于退出</p>\n<pre><code>[root@baobao ~]# sftp 172.168.72.68\n\nConnecting to 172.168.72.68…\n\nroot@172.168.72.68’s password:\n\nsftp&gt;\n\n或\n\n[root@baobao ~]# sftp axing@172.168.72.68\n\nConnecting to 172.168.72.68…\n\naxing@172.168.72.68’s password:\n\nsftp&gt; exit\n</code></pre><p>B：上传与下载</p>\n<pre><code>sftp&gt; pwd#查看当前在服务器的目录\n\nRemote working directory: /home/axing\n\nsftp&gt; lls /etc/hosts #查看本机是否有该文件\n\n/etc/hosts\n\nsftp&gt; put /etc/hosts #上传该文件到远程服务器\n\nUploading /etc/hosts to /home/axing/hosts#上传到服务器的默认目录\n\n/etc/hosts 100%  1580.2KB/s   00:00\n\nsftp&gt; ls\n\nhosts\n\nsftp&gt; ls –a  #查看服务器该目录下的隐藏文件\n\n.   ..  .bash_history   .bash_logout.bash_profile   .bashrc .emacs\n\n.gnome2.mozillahosts\n\nsftp&gt; lcd /tmp#切换到本地的目录/tmp下\n\nsftp&gt; get .bashrc #从服务器下载该文件\n\nFetching /home/axing/.bashrc to .bashrc\n\n/home/axing/.bashrc   100%  124 0.1KB/s  00:00\n\nsftp&gt; lls –a #确认是否下载成功\n\n……………………………………………\n\nbaoaj  .bashrc  guoal   guobe  guobx guocq  guodj  pulse-Fhzh5o9BSGRy\n\nsftp&gt; exit\n</code></pre><p>4、文件异地直接复制SCP</p>\n<p>当已经知道服务器上的文件名时可以使用该命令，该命令的上传和下载使用格式如下：</p>\n<p>上传：scp [-pr] [-l 速率] file [账号@]主机：目录名（：后没有空格）</p>\n<p>下载：scp [-pr] [-l 速率] [账号@]主机：file 目录名（file后有空格）</p>\n<p>1)   命令参数介绍</p>\n<p>-p：     保留文件的原有权限</p>\n<p>-r：     复制整个目录</p>\n<p>-l：     传输速率</p>\n<p>2)   Scp使用范例</p>\n<p>A：上传本地文件到远程服务器</p>\n<p><code>[root@baobao ~]# scp /etc/hosts* axing@172.168.72.68:~</code> #上传到服务器的用户主目录下</p>\n<p>axing@172.168.72.68’s password:</p>\n<p>hosts                100% 158     0.2KB/s   00:00</p>\n<p>hosts.allow          100% 370     0.4KB/s   00:00</p>\n<p>hosts.deny           100% 460     0.5KB/s   00:00</p>\n<p>B：从服务器下载文件到本地</p>\n<pre><code>[root@baobao ~]# scp axing@172.168.72.68:/etc/bashrc /tmp\n\naxing@172.168.72.68’s password:\n\nbashrc   100%2681 2.6KB/s   00:00\n</code></pre><p>l  windows用户ssh客户端的连接程序</p>\n<p>默认的windows并没有ssh的客户端程序，所以需要下载第三方软件才行，常见的有pietty、psftp和filezilla</p>\n<p>1、直接连接的pietty（可用作服务器管理）</p>\n<p>下载后安装即可使用，不过由于编码的问题中文会显示乱码需要设置该软件才行option—more options—features（右第二个打钩打开键盘数字）—connection—-ssh（右2only选择版本）</p>\n<p>option—font（脚本gb2312调整字符集支持中文）</p>\n<p>2、psftp</p>\n<p>下载后安装并启动，输入open172.168.72.68后连接即可</p>\n<p>3、filezilla</p>\n<p>下载后安装运行即可，是普通的中文界面ftp软件</p>\n<p>l  windows用户远程登陆管理服务器工具xshell（当前最好用的工具）</p>\n<p>1、xshell界面</p>\n<p>它是windows下当前最好用的远程管理软件，只需要你下载后安装即可使用，一般还有中文版，非常好用，以下是链接后的画面</p>\n<pre><code>Connecting to 172.168.72.68:22…\n\nConnection established.\n\nTo escape to local shell, press ‘Ctrl+Alt+]’.  #回到本地shell\n\nLast login: Tue Sep 30 08:55:23 2014 from aca80058.ipt.aol.com\n\n[root@baobao ~]# ls\n\n123baoae  cheng  last.list  lsrootaf   图片\n\nanaconda-ks.cfg  baoagguo.txt  lsrootaa regular_express.txt.1  下载\n\nbaoaa baoah  homelsrootab   xinzi.txt  音乐\n\nbaoab   baoai  homefile  lsrootac   公共的 桌面\n\n………………………………………………………\n\n[root@baobao ~]#\n</code></pre><p>2、xshell中文乱码解决法案</p>\n<p>Xshell是个非常不错的工具。但很多时候中文显示为乱码的问题，解决方法其实很简单的，即把xshell编码方式改成UTF-8即可：[文件]–&gt;[打开]–&gt;在打开的session中选择连接的那个然后右键点击[属性] -&gt; [终端]，编码选择为：Unicode(UTF-8)，然后重新连接服务器即可</p>\n<p>3、ssh远程登陆日志（重要）</p>\n<pre><code>[root@baobao ~]# cat /var/log/secure\n\nthenticationAgent, locale zh_CN.UTF-8)\n\nSep 30 08:55:23 baobao sshd[2916]: Accepted password for rootfrom 172.168.0.88 port 57853 ssh2\n\nSep 30 08:55:23 baobao sshd[2916]: pam_unix(sshd:session):session opened for user root by (uid=0)\n\nSep 30 09:21:21 baobao sshd[3331]: Accepted password for rootfrom 172.168.0.88 port 52386 ssh2\n\nSep 30 09:21:21 baobao sshd[3331]: pam_unix(sshd:session):session opened for user root by (uid=0)\n\nSep 30 09:21:55 baobao sshd[2916]: pam_unix(sshd:session):session closed for user root\n</code></pre><p>l  sshd服务器配置</p>\n<p>sshd服务器的详细配置都放在/etc/ssh/sshd_config配置文件里，只要是没有被注释的就是默认值</p>\n<pre><code>    [root@baobao ~]# vim /etc/ssh/sshd_config\n\n……………………………………………………\n\n#Port 22   #也可以设置多个端口只要添加一行然后重启即可（不建议）\n\n#ListenAddress 0.0.0.0 #默认监听所有网卡的接口，如果想指定后面直接写ip即可\n\nProtocol 2 #ssh的协议版本\n\n# HostKey for protocol version 1   #下面是不同协议版本的秘钥文件host key\n\n#HostKey /etc/ssh/ssh_host_key\n\n# HostKeys for protocol version 2\n\n#HostKey /etc/ssh/ssh_host_rsa_key\n\n#HostKey /etc/ssh/ssh_host_dsa_key\n\nSyslogFacility AUTHPRIV #ssh登陆记录，默认是/var/log/secure\n\n#LoginGraceTime 2m  #登陆超时设置\n\n#PermitRootLogin yes#是否允许root登陆，默认是允许的，建议设置为no\n\n#StrictModes yes#是否让sshd检查相关权限以免用户将某些权限设置错误\n\nPasswordAuthentication yes  #密码验证，当然需要了\n\n#PermitEmptyPasswords no#是否允许空密码登陆，当然是no了\n\n#IgnoreUserKnownHosts no#是否忽略用户主文件记录，当然是no了\n\n#IgnoreRhosts yes   #是否取消~/.ssh/.rhosts认证，当然yes了\n\nChallengeResponseAuthentication no  #该认证不安全，设置为no即可\n\nUsePAM yes#最好使用该认证模块记录与管理，所以yes\n\n#PrintLastLog yes #显示上次登陆的信息\n\n#TCPKeepAlive yes #网络不稳定时为了连接不中断可以设置为no\n\n#UsePrivilegeSeparation yes   #使用权限较低的程序来给用户操作\n\nDenyUsers #拒绝登陆的用户\n\nDenyGroups#拒绝登陆的组\n</code></pre><p>基本上ssh的默认设置已经就很安全了，不过还是建议将root的登陆权限取消，并将ssh的版本设置为2，而且通常这个文件不需要修改，如果修改了需要重启sshd</p>\n<p>l  制作不用密码接口登陆的ssh用户</p>\n<p>将客户端产生的key复制到服务器中，以后客户端再次登录的时候由于两者在ssh要连接的信号传递中已经比对过key了，所以不再需要输入密码了</p>\n<p>1、步骤一，客户端建立两把钥匙</p>\n<pre><code>[root@abao ~]# useradd abao\n\n[root@abao ~]# passwd abao\n\n更改用户 abao 的密码 。\n\n新的 密码：\n\n重新输入新的 密码：\n\npasswd： 所有的身份验证令牌已经成功更新。\n\n服务器上也做上面相同的用户配置\n\n[root@abao ~]# su – abao\n\n[abao@abao ~]$ ssh-keygen#默认以RSA建立两把钥匙\n\nGenerating public/private rsa key pair.\n\nEnter file in which to save the key (/home/abao/.ssh/id_rsa): 回车\n\nCreated directory ‘/home/abao/.ssh’. #建立主目录\n\nEnter passphrase (empty for no passphrase): 回车\n\nEnter same passphrase again: 回车\n\nYour identification has been saved in /home/abao/.ssh/id_rsa.   #私钥文件\n\nYour public key has been saved in /home/abao/.ssh/id_rsa.pub.   #公钥文件\n\nThe key fingerprint is:\n\n89:1e:87:c9:a8:68:69:df:bd:75:a4:df:54:37:70:f1 abao@abao\n\nThe key’s randomart image is:\n\n+–[ RSA 2048]—-+\n\n|   . |\n\n|o|\n\n| . .E|\n\n| o + .o  |\n\n|. * S  .   o.|\n\n| … . o  o   . o|\n\n|.+.   .  o . .  |\n\n|o . . . . o o|\n\n|   . . o.  . .   |\n\n+—————–+\n\n[abao@abao ~]$ ls -ld ~/.ssh; ls -l ~/.ssh\n\ndrwx——. 2 abao abao 4096 9月  30 11:56 /home/abao/.ssh\n\n总用量 8\n\n-rw——-. 1 abao abao1675 9月  30 11:56 id_rsa\n\n-rw-r–r–. 1 abao abao  391 9月  3011:56 id_rsa.pub\n</code></pre><p>默认情况下建立私钥后权限和文件名放置位置都是正确的。身份必须是abao，当执行ssh-keygen的时候才会在用户主目录下生成两把钥匙，需要注意的是~/.ssh/目录必有700的权限，而且私钥文件的权限必须是-rw——-且属于abao才行，否则在秘钥比对中会被误判为危险而无法成功的以公私钥成对文件的机制实现连接</p>\n<p>2、步骤二，将公钥文件数据上传到服务器</p>\n<pre><code>[root@baobao ~]# useradd abao  #先在ssh服务器端建立上传文件账户abao\n[root@baobao ~]# passwd abao\n更改用户 abao 的密码 。\n新的 密码：\n重新输入新的 密码：\npasswd： 所有的身份验证令牌已经成功更新。\n[abao@abao ~]$ scp ~/.ssh/id_rsa.pub abao@172.168.72.68:~\n\nabao@172.168.72.68’s password:\n\nid_rsa.pub100%  3910.4KB/s   00:00\n</code></pre><p>3、步骤三，蒋公钥放置到服务器端的正确目录与文件名</p>\n<p>1)   服务器上建立文件~/.ssh</p>\n<pre><code>[root@baobao ~]# su – abao\n\n[abao@baobao ~]$ ls -ld .ssh\n\nls: 无法访问.ssh: 没有那个文件或目录\n\n[abao@baobao ~]$ mkdir .ssh; chmod 700 .ssh  #注意其权限必须是700\n\n[abao@baobao ~]$ ls -ld .ssh\n\ndrwx——. 2 abao abao 4096 9月  3012:30 .ssh\n</code></pre><p>2)   将公钥文件内的数据使用cat转存到authorized_keys内</p>\n<pre><code>[abao@baobao ~]$ ls -l *pub\n\n-rw-r–r–. 1 abao abao 391 9月  3012:26 id_rsa.pub\n\n[abao@baobao ~]$ cat id_rsa.pub &gt;&gt; .ssh/authorized_keys\n\n[abao@baobao ~]$ chmod 644 .ssh/authorized_keys\n\n[abao@baobao ~]$ ls -l .ssh\n\n总用量 4\n\n-rw-r–r–. 1 abao abao 391 9月  3012:39 authorized_keys\n</code></pre><p>总结：客户端必须制作出两把钥匙，其中私钥必须放到~/.ssh内；而公钥必须上传到服务器端并且放置到用户主目录下的~/.ssh/authorized_keys，同时目录的权限必须是700,而文件权限必须是644</p>\n<p>4、步骤四，验证</p>\n<pre><code>[root@abao ~]# ssh abao@172.168.72.68\n\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\n@WARNING: REMOTE HOSTIDENTIFICATION HAS CHANGED! @\n\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\n\nSomeone could be eavesdropping on you right now(man-in-the-middle attack)!\n\nIt is also possible that the RSA host key has just been changed.\n\nThe fingerprint for the RSA key sent by the remote host is\n\n17:7e:8e:e9:fd:df:1c:e5:c9:9d:cd:30:31:5e:a6:45.\n\nPlease contact your system administrator.\n\nAdd correct host key in /root/.ssh/known_hosts to get rid ofthis message.\n\nOffending key in /root/.ssh/known_hosts:1\n\nRSA host key for 172.168.72.68 has changed and you haverequested strict checking.\n\nHost key verification failed.\n\n[root@abao ~]##看不再需要密码了\n\n[root@abao ~]# ifconfig   #查看服务器IP地址\n\neth0  Linkencap:Ethernet  HWaddr00:0C:29:59:D9:E6\n\ninet addr:172.168.68.72  Bcast:172.168.255.255  Mask:255.255.0.0\n\ninet6 addr:fe80::20c:29ff:fe59:d9e6/64 Scope:Link\n\nUP BROADCASTRUNNING MULTICAST  MTU:1500  Metric:1\n\nRXpackets:239668 errors:0 dropped:0 overruns:0 frame:0\n\nTX packets:855errors:0 dropped:0 overruns:0 carrier:0\n\ncollisions:0txqueuelen:1000\n\nRXbytes:18091942 (17.2 MiB)  TX bytes:71093(69.4 KiB)\n</code></pre><p>l  Ssh的安全设置</p>\n<p>Sshd所谓的安全其实指的是它的数据加密功能，而对于sshd本身这个服务来说是很不安全的，所以如果不是特别需要请尽量限制在小范围内的几个ip或主机名即可</p>\n<p>1、 服务器本身的设置强化/etc/ssh/sshd——config</p>\n<pre><code>[root@baobao ~]# vim /etc/ssh/sshd_config\n</code></pre><p>1)   禁止root账号使用sshd服务</p>\n<pre><code>PermitRootLogin no                         #去掉注释并修改为no\n</code></pre><p>2)   禁止nossh这个组的用户使用sshd服务</p>\n<pre><code>DenyGroups nosh\n</code></pre><p>3)   禁止用户testssh使用sshd服务</p>\n<pre><code>DenyUsers testssh\n\n[root@abao ~]# /etc/init.d/sshd restart\n\n停止 sshd：[确定]\n\n正在启动 sshd：[确定]\n\n[root@abao ~]# cat /var/log/secure #验证上述用户不能登陆后查看其日志\n</code></pre><p>2、TCP Wrapper的使用</p>\n<pre><code>[root@baobao ~]# vim /etc/host.allow  #只允许内网和本机可以远程登陆\n\nsshd: 127.0.0.1 192.168.1.0/255.255.255.0192.168.10.0/255.255.255.0\n\n[root@baobao ~]# vim /etc/host.deny\n\nsshd: all\n</code></pre><p>3、iptables数据包过滤防火墙</p>\n<pre><code>[root@baobao ~]# iptables -A INPUT -i eth0 -s 192.168.1.0/24 -p tcp –dport 22 -j ACCEPT\n\n[root@baobao ~]# iptables -A INPUT -i eth0 -s 192.168.10.0/24 -p tcp –dport 22 -j ACCEPT\n\n[root@baobao ~]# /etc/init.d/iptables save\n\n[root@baobao ~]# /etc/init.d/iptables restart\n</code></pre><p>注意不要开放ssh的登陆权限给Internet上面的所有用户或主机，只开放给适当的部分用户或主机即可，否则会很不安全</p>\n","excerpt":"<p>一、远程连接简介</p>\n<p>l  远程连接服务器</p>\n<p>远程连接服务器通过文字或图形接口的方式来远程登陆系统，在远程的终端前面登陆linux主机并取得操作主机的接口shell，登陆后的操作就像在系统前面一样，这样可以进行系统管理的任务<br>","more":"<br>l  工作站</p>\n<p>工作站就是仅提供大量的运作能力给用户而不提供因特网服务的主机</p>\n<p>l  当前远程连接的登陆类型</p>\n<p>1、加密的远程连接</p>\n<p>主要是ssh，也是用到的最多最安全的，而且还可以使用rsync通过ssh协议来进行异地备份</p>\n<p>2、图形接口的远程连接</p>\n<p>XDMCP、VNC和XRDP，这些方式由于是传输图形所以速度慢，且安全性也不是很好</p>\n<p>二、远程连接之SSH</p>\n<p>Ssh是secure shell protocol（安全的壳程序协议）的简写，可以通过数据包加密技术将传输的数据包加密后再传输到网络上，当前ssh有两个版本，其中version2加上了连接检测的机制，可以避免连接期间被插入恶意攻击码</p>\n<p>l  Ssh服务器提供的功能</p>\n<p>默认的ssh服务器提供两个服务器功能</p>\n<p>1、ssh服务</p>\n<p>类似telnet的远程连接，使用shell的服务器，可以用来管理服务器</p>\n<p>2、ftp服务</p>\n<p>类似ftp服务的sftp-server，可以用来远程上传和下载</p>\n<p>l  连接的加密技术</p>\n<p>当前常见的网络数据包加密技术主要是通过非对称秘钥系统来处理的，主要是通过两把不同的公钥（public key）和私钥（private key）来进行数据的加密与解密的，且在同一个方向上的连接中这两把钥匙是成对存在的。每台主机都应该有自己的秘钥（公钥和私钥），并且公钥用于加密而私钥用于解密</p>\n<p>1、公钥（public key）</p>\n<p>提供给远程主机进行数据加密的行为，所有客户端都能取得它进行数据加密</p>\n<p>2、私钥（private key）</p>\n<p>远程主机使用公钥加密的数据在本地就需要使用私钥进行解密了，其非常重要只能在自己的主机上</p>\n<p>l  Ssh服务器端与客户端的链接步骤</p>\n<p>1、服务器建立公钥文件</p>\n<p>系统安装完成时sshd会朱勇去计算出需要的公钥文件和自己需要的私钥文件，等下次再次启动sshd的时候该服务就会主动去找文件/etc/ssh/ssh_host*</p>\n<p>2、客户端主动链接</p>\n<p>需要使用客户端程序（如ssh）来连接</p>\n<p>3、服务器传送公钥文件给客户端</p>\n<p>服务器将将取得的公钥文件/etc/ssh/ssh_host*传送给客户端（由于公钥是给大家使用的，所以此时的传送是明文的）</p>\n<p>4、客户端记录并比对该公钥数据，然后计算出自己的公钥和私钥</p>\n<p>客户端在第一次连接该服务器后会将服务器的公钥数据记录到客户端的用户主目录下的~ /.ssh/known_hosts内，如果已经记录过该数据则客户端会去比对此次受到的公钥与之前的差异，若接受此次公钥数据那么会计算出客户端自己的公钥和私钥</p>\n<p>5、客户端将自己的公钥传送给服务器</p>\n<p>此时服务器端会有自己的私钥和客户端的公钥；而客户端会有服务器的公钥和自己的私钥，这时服务器与客户端的秘钥（公钥与私钥）是不一样的，所以才称之为非对称式秘钥系统</p>\n<p>6、服务器开始进行双向加解密</p>\n<p>1)   服务器传送数据到客户端</p>\n<p>将用户的公钥加密后进行发送，客户端接收后用自己的私钥解密</p>\n<p>2)   客户端传送数据到服务器</p>\n<p>将服务器的公钥加密后进行发送，服务器接受后用自己的私钥解密</p>\n<p>l  秘钥文件的建立</p>\n<p>1、服务器端启动ssh服务，以生成服务器端的公钥和私钥</p>\n<pre><code>[root@baobao ~]# /etc/init.d/sshd restart\n</code></pre><p>停止 sshd：                                                [确定]</p>\n<p>生成 SSH1 RSA 主机键：                                     [确定]</p>\n<p>生成 SSH2 RSA 主机键：                                     [确定]</p>\n<p>正在生成 SSH2 DSA 主机键：                                 [确定]</p>\n<p>正在启动 sshd：                                            [确定]</p>\n<p>2、客户端利用ssh连接服务器</p>\n<pre><code>[root@abao ~]# ssh 172.168.72.68\n\nThe authenticity of host ‘172.168.72.68 (172.168.72.68)’ can’tbe established.\n\nRSA key fingerprint is36:cf:9f:46:54:46:4b:b3:b0:48:4a:93:4d:14:81:56.\n\nAre you sure you want to continue connecting (yes/no)? yes\n\nWarning: Permanently added ‘172.168.72.68’ (RSA) to the list ofknown hosts.\n\nroot@172.168.72.68’s password:\n\nLast login: Sun Sep 28 15:37:10 2014 from localhost\n\n[root@baobao ~]# exit\n\nlogout\n\nConnection to 172.168.72.68 closed.\n</code></pre><p>3、删除客户端的秘钥文件</p>\n<pre><code>[root@abao ~]# rm /etc/ssh/ssh_host*\n\nrm：是否删除普通文件 “/etc/ssh/ssh_host_dsa_key”？y\n\nrm：是否删除普通文件 “/etc/ssh/ssh_host_dsa_key.pub”？y\n\nrm：是否删除普通文件 “/etc/ssh/ssh_host_key”？y\n\nrm：是否删除普通文件 “/etc/ssh/ssh_host_key.pub”？y\n\nrm：是否删除普通文件 “/etc/ssh/ssh_host_rsa_key”？y\n\nrm：是否删除普通文件 “/etc/ssh/ssh_host_rsa_key.pub”？y\n</code></pre><p>4、重新启动客户端的sshd服务以查看秘钥文件的建立过程</p>\n<pre><code>[root@abao ~]# /etc/init.d/sshd restart\n\n停止 sshd：[确定]\n\n生成 SSH1 RSA 主机键： [确定]\n\n生成 SSH2 RSA 主机键： [确定]\n\n正在生成 SSH2 DSA 主机键： [确定]\n\n正在启动 sshd：[确定]\n</code></pre><p>l  Sshd服务的启动</p>\n<pre><code>[root@baobao ~]# /etc/init.d/sshd restart\n\n停止 sshd：[确定]\n\n正在启动 sshd：[确定]\n\n[root@baobao ~]# netstat -tlnp | grep ssh #注意ssh服务是tcp端口22\n\ntcp 0  0 0.0.0.0:22  0.0.0.0:*LISTEN 9262/sshd\n\ntcp 0  0:::22:::* LISTEN 9262/sshd\n</code></pre><p>在linux系统中默认就有ssh所需要的软件了，包括可以产生密码等协议的OpenSSL软件和OpenSSH软件，而且在当前的linux系统中都是默认启动ssh的。这个sshd可以同时提供shell与ftp，而且都是在tcp端口22</p>\n<p>l  Linux用户ssh客户端的连接程序</p>\n<p>Linux客户端默认情况下是可以正常使用ssh的而不必安装额外的软件，而且其默认是启动的</p>\n<p>1、 直接登录远程主机的指令ssh（可用作服务器管理）</p>\n<p>Ssh命令格式为：ssh [-f][-o参数项目][-p非标准端口][账号@]IP地址[命令]</p>\n<p>1)   Ssh命令参数介绍</p>\n<p>-f：     需要配合后面的[命令]，不登陆远程主机直接发送一个命令过去而已</p>\n<p>-o：     主要的参数有：ConnectTimeout=秒数：连接等到的秒数，减少等待的时间</p>\n<p>StrictHostKeyChecking=yes/no/ask：默认是ask，如果想要public key主动加入known_host这里设置为no</p>\n<p>-p：     如果sshd服务启动在非标准的端口需使用该项目[命令]，不登陆远程主机直接发送一个命令过去，但与-f意义不太相同</p>\n<p>2)   ssh使用范例</p>\n<p>A：直接登录到远程主机</p>\n<pre><code>[root@abao ~]# ssh 172.168.72.68\n\nThe authenticity of host ‘172.168.72.68 (172.168.72.68)’ can’tbe established.\n\nRSA key fingerprint is36:cf:9f:46:54:46:4b:b3:b0:48:4a:93:4d:14:81:56.   #远程服务器的公钥指纹码\n\nAre you sure you want to continue connecting (yes/no)? yes   #将上述指纹码写入服务器公钥记录文件~ /.ssh/known_hosts，等再次登录时就不会出现该指纹码提示了。一定要yes而不是y\n\nWarning: Permanently added ‘172.168.72.68’ (RSA) to the list ofknown hosts.\n\nroot@172.168.72.68’s password:#远程主机的root密码\n\nLast login: Sun Sep 28 15:37:10 2014 from localhost\n\n[root@baobao ~]# exit #退出远程连接\n\nlogout\n\nConnection to 172.168.72.68 closed.\n</code></pre><p>一般我们使用“ssh 账号 主机IP地址”的登录方式，如果不写账号的话那么会以本地计算机的当前账号来尝试登录远程主机</p>\n<p>B：再次登录远程主机</p>\n<pre><code>[root@abao ~]# ssh 172.168.72.68\n\nroot@172.168.72.68’s password:\n\nLast login: Sun Sep 28 16:42:05 2014 from aca84448.ipt.aol.com\n</code></pre><p>C：使用账号axing登录</p>\n<pre><code>[root@baobao ~]# ssh axing@172.168.72.68\n\nThe authenticity of host ‘172.168.72.68 (172.168.72.68)’ can’tbe established.\n\nRSA key fingerprint is 36:cf:9f:46:54:46:4b:b3:b0:48:4a:93:4d:14:81:56.\n\nAre you sure you want to continue connecting (yes/no)? yes\n\nWarning: Permanently added ‘172.168.72.68’ (RSA) to the list ofknown hosts.\n\naxing@172.168.72.68’s password:\n\n[axing@baobao ~]$   #远程登陆后身份变为axing\n</code></pre><p>D：远程登陆执行命令后立刻离开</p>\n<pre><code>[root@abao ~]# ssh axing@172.168.72.68 find / -name passwd  #既后面直接加命令\n\naxing@172.168.72.68’s password:\n</code></pre><p>卡在这里等待命令的执行完毕</p>\n<p>E：让远程主机自动运行命令而立刻回到本地端继续工作</p>\n<pre><code>[root@abao ~]# ssh -faxing@172.168.72.68 shutdown -h now\n\naxing@172.168.72.68’s password:\n</code></pre><p>F：自动加上公钥记录而不再询问</p>\n<pre><code>[root@abao ~]# rm ~/.ssh/known_hosts\n\nrm：是否删除普通文件 “/root/.ssh/known_hosts”？y\n\n[root@abao ~]# ssh -o StrictHostKeyChecking=no root@172.168.72.68#不在要求输入yes或no了\n\nWarning: Permanently added ‘172.168.72.68’ (RSA) to the list ofknown hosts.\n\nroot@172.168.72.68’s password:\n\nLast login: Mon Sep 29 14:00:28 2014 from aca84448.ipt.aol.com\n</code></pre><p>2、服务器公钥记录文件~ /.ssh/known_hosts</p>\n<p>当远程登陆服务器时本机会主动将从服务器收到的公钥服务器公钥记录文件~ /.ssh/known_hosts进行比对，如果服务器的公钥文件还没有记录那么就会主动询问是否记录（登陆时候的yes或no行为）；如果收到的公钥已经记录那么会比对记录是否相同，如果相同则继续登陆，如果不同就会离开登陆而返回。但是如果是服务器重新安装那么服务器的公钥就会经常变化，这样的话我们就无法正常远程登陆了</p>\n<p>A：模拟服务器重新安装后ssh登陆</p>\n<pre><code>[root@baobao ~]# rm /etc/ssh/ssh_host*\n\nrm：是否删除普通文件 “/etc/ssh/ssh_host_dsa_key”？y\n\nrm：是否删除普通文件 “/etc/ssh/ssh_host_dsa_key.pub”？y\n\nrm：是否删除普通文件 “/etc/ssh/ssh_host_key”？y\n\nrm：是否删除普通文件 “/etc/ssh/ssh_host_key.pub”？y\n\nrm：是否删除普通文件 “/etc/ssh/ssh_host_rsa_key”？y\n\nrm：是否删除普通文件 “/etc/ssh/ssh_host_rsa_key.pub”？y\n\n[root@baobao ~]# /etc/init.d/sshd restart\n\n停止 sshd：[确定]\n\n生成 SSH1 RSA 主机键： [确定]\n\n生成 SSH2 RSA 主机键： [确定]\n\n正在生成 SSH2 DSA 主机键： [确定]\n\n正在启动 sshd：[确定]\n\n[root@baobao ~]# ssh 172.168.72.68\n\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\n@WARNING: REMOTE HOSTIDENTIFICATION HAS CHANGED! @\n\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\n\nSomeone could be eavesdropping on you right now(man-in-the-middle attack)!\n\nIt is also possible that the RSA host key has just been changed.\n\nThe fingerprint for the RSA key sent by the remote host is\n\n17:7e:8e:e9:fd:df:1c:e5:c9:9d:cd:30:31:5e:a6:45.\n\nPlease contact your system administrator.\n\nAdd correct host key in /root/.ssh/known_hosts to get rid ofthis message.\n\nOffending key in /root/.ssh/known_hosts:2#有问题的数据行号\n\nRSA host key for 172.168.72.68 has changed and you haverequested strict checking.\n\nHost key verification failed.\n</code></pre><p>B：上述现象解决方法</p>\n<pre><code>[root@baobao ~]# vim /root/.ssh/known_hosts  #清空该文件\n\n[root@baobao ~]# ssh 172.168.72.68\n\nThe authenticity of host ‘172.168.72.68 (172.168.72.68)’ can’tbe established.\n\nRSA key fingerprint is17:7e:8e:e9:fd:df:1c:e5:c9:9d:cd:30:31:5e:a6:45.\n\nAre you sure you want to continue connecting (yes/no)? yes#记录公钥\n\nWarning: Permanently added ‘172.168.72.68’ (RSA) to the list ofknown hosts.\n\nroot@172.168.72.68’s password:\n\nLast login: Mon Sep 29 14:28:46 2014 from aca84448.ipt.aol.com\n</code></pre><p>3、模拟FTP的文件传输之SFTP</p>\n<p>如果想要从远程服务器下载或上传文件就不能使用ssh了，而必须使用sftp或scp，这两个指令也是使用ssh的端口22，只是模拟成ftp与复制的操作而已</p>\n<p>1)   SFTP使用的命令</p>\n<p>Sftp使用的命令与ftp是一样的</p>\n<p>A：针对远程服务器的命令</p>\n<p>跟linux服务器命令相同</p>\n<p>B：针对本机的命令</p>\n<p>在基本命令前面加“l”即代表是针对本机的操作，例如sftp&gt; lcd /tmp进入本机的该目录</p>\n<p>C：针对资料的上传或下载的命令</p>\n<p>put [本地目录或文件][远程]或put [本地目录或文件]（这样会存储到远程主机的目录下）</p>\n<p>get [远程目录或文件][本机]或get [远程目录或文件]（这样会存储到当前本机所在目录）</p>\n<p>2)   Sftp的使用范例</p>\n<p>A：sftp的登陆于退出</p>\n<pre><code>[root@baobao ~]# sftp 172.168.72.68\n\nConnecting to 172.168.72.68…\n\nroot@172.168.72.68’s password:\n\nsftp&gt;\n\n或\n\n[root@baobao ~]# sftp axing@172.168.72.68\n\nConnecting to 172.168.72.68…\n\naxing@172.168.72.68’s password:\n\nsftp&gt; exit\n</code></pre><p>B：上传与下载</p>\n<pre><code>sftp&gt; pwd#查看当前在服务器的目录\n\nRemote working directory: /home/axing\n\nsftp&gt; lls /etc/hosts #查看本机是否有该文件\n\n/etc/hosts\n\nsftp&gt; put /etc/hosts #上传该文件到远程服务器\n\nUploading /etc/hosts to /home/axing/hosts#上传到服务器的默认目录\n\n/etc/hosts 100%  1580.2KB/s   00:00\n\nsftp&gt; ls\n\nhosts\n\nsftp&gt; ls –a  #查看服务器该目录下的隐藏文件\n\n.   ..  .bash_history   .bash_logout.bash_profile   .bashrc .emacs\n\n.gnome2.mozillahosts\n\nsftp&gt; lcd /tmp#切换到本地的目录/tmp下\n\nsftp&gt; get .bashrc #从服务器下载该文件\n\nFetching /home/axing/.bashrc to .bashrc\n\n/home/axing/.bashrc   100%  124 0.1KB/s  00:00\n\nsftp&gt; lls –a #确认是否下载成功\n\n……………………………………………\n\nbaoaj  .bashrc  guoal   guobe  guobx guocq  guodj  pulse-Fhzh5o9BSGRy\n\nsftp&gt; exit\n</code></pre><p>4、文件异地直接复制SCP</p>\n<p>当已经知道服务器上的文件名时可以使用该命令，该命令的上传和下载使用格式如下：</p>\n<p>上传：scp [-pr] [-l 速率] file [账号@]主机：目录名（：后没有空格）</p>\n<p>下载：scp [-pr] [-l 速率] [账号@]主机：file 目录名（file后有空格）</p>\n<p>1)   命令参数介绍</p>\n<p>-p：     保留文件的原有权限</p>\n<p>-r：     复制整个目录</p>\n<p>-l：     传输速率</p>\n<p>2)   Scp使用范例</p>\n<p>A：上传本地文件到远程服务器</p>\n<p><code>[root@baobao ~]# scp /etc/hosts* axing@172.168.72.68:~</code> #上传到服务器的用户主目录下</p>\n<p>axing@172.168.72.68’s password:</p>\n<p>hosts                100% 158     0.2KB/s   00:00</p>\n<p>hosts.allow          100% 370     0.4KB/s   00:00</p>\n<p>hosts.deny           100% 460     0.5KB/s   00:00</p>\n<p>B：从服务器下载文件到本地</p>\n<pre><code>[root@baobao ~]# scp axing@172.168.72.68:/etc/bashrc /tmp\n\naxing@172.168.72.68’s password:\n\nbashrc   100%2681 2.6KB/s   00:00\n</code></pre><p>l  windows用户ssh客户端的连接程序</p>\n<p>默认的windows并没有ssh的客户端程序，所以需要下载第三方软件才行，常见的有pietty、psftp和filezilla</p>\n<p>1、直接连接的pietty（可用作服务器管理）</p>\n<p>下载后安装即可使用，不过由于编码的问题中文会显示乱码需要设置该软件才行option—more options—features（右第二个打钩打开键盘数字）—connection—-ssh（右2only选择版本）</p>\n<p>option—font（脚本gb2312调整字符集支持中文）</p>\n<p>2、psftp</p>\n<p>下载后安装并启动，输入open172.168.72.68后连接即可</p>\n<p>3、filezilla</p>\n<p>下载后安装运行即可，是普通的中文界面ftp软件</p>\n<p>l  windows用户远程登陆管理服务器工具xshell（当前最好用的工具）</p>\n<p>1、xshell界面</p>\n<p>它是windows下当前最好用的远程管理软件，只需要你下载后安装即可使用，一般还有中文版，非常好用，以下是链接后的画面</p>\n<pre><code>Connecting to 172.168.72.68:22…\n\nConnection established.\n\nTo escape to local shell, press ‘Ctrl+Alt+]’.  #回到本地shell\n\nLast login: Tue Sep 30 08:55:23 2014 from aca80058.ipt.aol.com\n\n[root@baobao ~]# ls\n\n123baoae  cheng  last.list  lsrootaf   图片\n\nanaconda-ks.cfg  baoagguo.txt  lsrootaa regular_express.txt.1  下载\n\nbaoaa baoah  homelsrootab   xinzi.txt  音乐\n\nbaoab   baoai  homefile  lsrootac   公共的 桌面\n\n………………………………………………………\n\n[root@baobao ~]#\n</code></pre><p>2、xshell中文乱码解决法案</p>\n<p>Xshell是个非常不错的工具。但很多时候中文显示为乱码的问题，解决方法其实很简单的，即把xshell编码方式改成UTF-8即可：[文件]–&gt;[打开]–&gt;在打开的session中选择连接的那个然后右键点击[属性] -&gt; [终端]，编码选择为：Unicode(UTF-8)，然后重新连接服务器即可</p>\n<p>3、ssh远程登陆日志（重要）</p>\n<pre><code>[root@baobao ~]# cat /var/log/secure\n\nthenticationAgent, locale zh_CN.UTF-8)\n\nSep 30 08:55:23 baobao sshd[2916]: Accepted password for rootfrom 172.168.0.88 port 57853 ssh2\n\nSep 30 08:55:23 baobao sshd[2916]: pam_unix(sshd:session):session opened for user root by (uid=0)\n\nSep 30 09:21:21 baobao sshd[3331]: Accepted password for rootfrom 172.168.0.88 port 52386 ssh2\n\nSep 30 09:21:21 baobao sshd[3331]: pam_unix(sshd:session):session opened for user root by (uid=0)\n\nSep 30 09:21:55 baobao sshd[2916]: pam_unix(sshd:session):session closed for user root\n</code></pre><p>l  sshd服务器配置</p>\n<p>sshd服务器的详细配置都放在/etc/ssh/sshd_config配置文件里，只要是没有被注释的就是默认值</p>\n<pre><code>    [root@baobao ~]# vim /etc/ssh/sshd_config\n\n……………………………………………………\n\n#Port 22   #也可以设置多个端口只要添加一行然后重启即可（不建议）\n\n#ListenAddress 0.0.0.0 #默认监听所有网卡的接口，如果想指定后面直接写ip即可\n\nProtocol 2 #ssh的协议版本\n\n# HostKey for protocol version 1   #下面是不同协议版本的秘钥文件host key\n\n#HostKey /etc/ssh/ssh_host_key\n\n# HostKeys for protocol version 2\n\n#HostKey /etc/ssh/ssh_host_rsa_key\n\n#HostKey /etc/ssh/ssh_host_dsa_key\n\nSyslogFacility AUTHPRIV #ssh登陆记录，默认是/var/log/secure\n\n#LoginGraceTime 2m  #登陆超时设置\n\n#PermitRootLogin yes#是否允许root登陆，默认是允许的，建议设置为no\n\n#StrictModes yes#是否让sshd检查相关权限以免用户将某些权限设置错误\n\nPasswordAuthentication yes  #密码验证，当然需要了\n\n#PermitEmptyPasswords no#是否允许空密码登陆，当然是no了\n\n#IgnoreUserKnownHosts no#是否忽略用户主文件记录，当然是no了\n\n#IgnoreRhosts yes   #是否取消~/.ssh/.rhosts认证，当然yes了\n\nChallengeResponseAuthentication no  #该认证不安全，设置为no即可\n\nUsePAM yes#最好使用该认证模块记录与管理，所以yes\n\n#PrintLastLog yes #显示上次登陆的信息\n\n#TCPKeepAlive yes #网络不稳定时为了连接不中断可以设置为no\n\n#UsePrivilegeSeparation yes   #使用权限较低的程序来给用户操作\n\nDenyUsers #拒绝登陆的用户\n\nDenyGroups#拒绝登陆的组\n</code></pre><p>基本上ssh的默认设置已经就很安全了，不过还是建议将root的登陆权限取消，并将ssh的版本设置为2，而且通常这个文件不需要修改，如果修改了需要重启sshd</p>\n<p>l  制作不用密码接口登陆的ssh用户</p>\n<p>将客户端产生的key复制到服务器中，以后客户端再次登录的时候由于两者在ssh要连接的信号传递中已经比对过key了，所以不再需要输入密码了</p>\n<p>1、步骤一，客户端建立两把钥匙</p>\n<pre><code>[root@abao ~]# useradd abao\n\n[root@abao ~]# passwd abao\n\n更改用户 abao 的密码 。\n\n新的 密码：\n\n重新输入新的 密码：\n\npasswd： 所有的身份验证令牌已经成功更新。\n\n服务器上也做上面相同的用户配置\n\n[root@abao ~]# su – abao\n\n[abao@abao ~]$ ssh-keygen#默认以RSA建立两把钥匙\n\nGenerating public/private rsa key pair.\n\nEnter file in which to save the key (/home/abao/.ssh/id_rsa): 回车\n\nCreated directory ‘/home/abao/.ssh’. #建立主目录\n\nEnter passphrase (empty for no passphrase): 回车\n\nEnter same passphrase again: 回车\n\nYour identification has been saved in /home/abao/.ssh/id_rsa.   #私钥文件\n\nYour public key has been saved in /home/abao/.ssh/id_rsa.pub.   #公钥文件\n\nThe key fingerprint is:\n\n89:1e:87:c9:a8:68:69:df:bd:75:a4:df:54:37:70:f1 abao@abao\n\nThe key’s randomart image is:\n\n+–[ RSA 2048]—-+\n\n|   . |\n\n|o|\n\n| . .E|\n\n| o + .o  |\n\n|. * S  .   o.|\n\n| … . o  o   . o|\n\n|.+.   .  o . .  |\n\n|o . . . . o o|\n\n|   . . o.  . .   |\n\n+—————–+\n\n[abao@abao ~]$ ls -ld ~/.ssh; ls -l ~/.ssh\n\ndrwx——. 2 abao abao 4096 9月  30 11:56 /home/abao/.ssh\n\n总用量 8\n\n-rw——-. 1 abao abao1675 9月  30 11:56 id_rsa\n\n-rw-r–r–. 1 abao abao  391 9月  3011:56 id_rsa.pub\n</code></pre><p>默认情况下建立私钥后权限和文件名放置位置都是正确的。身份必须是abao，当执行ssh-keygen的时候才会在用户主目录下生成两把钥匙，需要注意的是~/.ssh/目录必有700的权限，而且私钥文件的权限必须是-rw——-且属于abao才行，否则在秘钥比对中会被误判为危险而无法成功的以公私钥成对文件的机制实现连接</p>\n<p>2、步骤二，将公钥文件数据上传到服务器</p>\n<pre><code>[root@baobao ~]# useradd abao  #先在ssh服务器端建立上传文件账户abao\n[root@baobao ~]# passwd abao\n更改用户 abao 的密码 。\n新的 密码：\n重新输入新的 密码：\npasswd： 所有的身份验证令牌已经成功更新。\n[abao@abao ~]$ scp ~/.ssh/id_rsa.pub abao@172.168.72.68:~\n\nabao@172.168.72.68’s password:\n\nid_rsa.pub100%  3910.4KB/s   00:00\n</code></pre><p>3、步骤三，蒋公钥放置到服务器端的正确目录与文件名</p>\n<p>1)   服务器上建立文件~/.ssh</p>\n<pre><code>[root@baobao ~]# su – abao\n\n[abao@baobao ~]$ ls -ld .ssh\n\nls: 无法访问.ssh: 没有那个文件或目录\n\n[abao@baobao ~]$ mkdir .ssh; chmod 700 .ssh  #注意其权限必须是700\n\n[abao@baobao ~]$ ls -ld .ssh\n\ndrwx——. 2 abao abao 4096 9月  3012:30 .ssh\n</code></pre><p>2)   将公钥文件内的数据使用cat转存到authorized_keys内</p>\n<pre><code>[abao@baobao ~]$ ls -l *pub\n\n-rw-r–r–. 1 abao abao 391 9月  3012:26 id_rsa.pub\n\n[abao@baobao ~]$ cat id_rsa.pub &gt;&gt; .ssh/authorized_keys\n\n[abao@baobao ~]$ chmod 644 .ssh/authorized_keys\n\n[abao@baobao ~]$ ls -l .ssh\n\n总用量 4\n\n-rw-r–r–. 1 abao abao 391 9月  3012:39 authorized_keys\n</code></pre><p>总结：客户端必须制作出两把钥匙，其中私钥必须放到~/.ssh内；而公钥必须上传到服务器端并且放置到用户主目录下的~/.ssh/authorized_keys，同时目录的权限必须是700,而文件权限必须是644</p>\n<p>4、步骤四，验证</p>\n<pre><code>[root@abao ~]# ssh abao@172.168.72.68\n\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\n@WARNING: REMOTE HOSTIDENTIFICATION HAS CHANGED! @\n\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\n\nSomeone could be eavesdropping on you right now(man-in-the-middle attack)!\n\nIt is also possible that the RSA host key has just been changed.\n\nThe fingerprint for the RSA key sent by the remote host is\n\n17:7e:8e:e9:fd:df:1c:e5:c9:9d:cd:30:31:5e:a6:45.\n\nPlease contact your system administrator.\n\nAdd correct host key in /root/.ssh/known_hosts to get rid ofthis message.\n\nOffending key in /root/.ssh/known_hosts:1\n\nRSA host key for 172.168.72.68 has changed and you haverequested strict checking.\n\nHost key verification failed.\n\n[root@abao ~]##看不再需要密码了\n\n[root@abao ~]# ifconfig   #查看服务器IP地址\n\neth0  Linkencap:Ethernet  HWaddr00:0C:29:59:D9:E6\n\ninet addr:172.168.68.72  Bcast:172.168.255.255  Mask:255.255.0.0\n\ninet6 addr:fe80::20c:29ff:fe59:d9e6/64 Scope:Link\n\nUP BROADCASTRUNNING MULTICAST  MTU:1500  Metric:1\n\nRXpackets:239668 errors:0 dropped:0 overruns:0 frame:0\n\nTX packets:855errors:0 dropped:0 overruns:0 carrier:0\n\ncollisions:0txqueuelen:1000\n\nRXbytes:18091942 (17.2 MiB)  TX bytes:71093(69.4 KiB)\n</code></pre><p>l  Ssh的安全设置</p>\n<p>Sshd所谓的安全其实指的是它的数据加密功能，而对于sshd本身这个服务来说是很不安全的，所以如果不是特别需要请尽量限制在小范围内的几个ip或主机名即可</p>\n<p>1、 服务器本身的设置强化/etc/ssh/sshd——config</p>\n<pre><code>[root@baobao ~]# vim /etc/ssh/sshd_config\n</code></pre><p>1)   禁止root账号使用sshd服务</p>\n<pre><code>PermitRootLogin no                         #去掉注释并修改为no\n</code></pre><p>2)   禁止nossh这个组的用户使用sshd服务</p>\n<pre><code>DenyGroups nosh\n</code></pre><p>3)   禁止用户testssh使用sshd服务</p>\n<pre><code>DenyUsers testssh\n\n[root@abao ~]# /etc/init.d/sshd restart\n\n停止 sshd：[确定]\n\n正在启动 sshd：[确定]\n\n[root@abao ~]# cat /var/log/secure #验证上述用户不能登陆后查看其日志\n</code></pre><p>2、TCP Wrapper的使用</p>\n<pre><code>[root@baobao ~]# vim /etc/host.allow  #只允许内网和本机可以远程登陆\n\nsshd: 127.0.0.1 192.168.1.0/255.255.255.0192.168.10.0/255.255.255.0\n\n[root@baobao ~]# vim /etc/host.deny\n\nsshd: all\n</code></pre><p>3、iptables数据包过滤防火墙</p>\n<pre><code>[root@baobao ~]# iptables -A INPUT -i eth0 -s 192.168.1.0/24 -p tcp –dport 22 -j ACCEPT\n\n[root@baobao ~]# iptables -A INPUT -i eth0 -s 192.168.10.0/24 -p tcp –dport 22 -j ACCEPT\n\n[root@baobao ~]# /etc/init.d/iptables save\n\n[root@baobao ~]# /etc/init.d/iptables restart\n</code></pre><p>注意不要开放ssh的登陆权限给Internet上面的所有用户或主机，只开放给适当的部分用户或主机即可，否则会很不安全</p>"},{"title":"linux—SSH（二）Rsync备份","date":"2016-09-02T04:00:00.000Z","_content":"一、Rsync软件介绍\n\nrsync从字面上的意思就是remote sync （远程同步）的意思，是类unix系统下的远程数据镜像备份工具，可以镜像保存整个目录树和文件系统，并保持原来文件的权限、时间、软硬链接等，此外它还支持匿名传输；Rsync不仅可以远程同步数据（类似于scp）还可以本地同步数据（类似于cp），但不同于cp或scp的是rsync不像cp/scp一样会覆盖以前的数据，Rsync使用所谓的“Rsync演算法”，这个算法在第一次连通完成时，会把整份文件传输一次，下一次就只传送二个文件之间不同的部份，因此速度相当快\n<!--more-->\n二、Rsync的传输方式（或工作模式）\n\nl  在本机直接运行拷贝本地文件（不使用冒号）\n\n命令格式为：rsync[OPTION]… SRC DEST。如下\n\n    [root@abao~]# rsync -av /etc /tmp\n    \nl  通过rsh或ssh的信道在server/client之间进行传输数据（使用一个冒号）\n\n需要登录到服务器上执行任务，并且需要输入账号的密码\n\n1、 将本地机器的内容拷贝到远程机器（目标路径中使用一个冒号）\n\n命令格式为：rsync[OPTION]… SRC [USER@]HOST:DEST。如下\n\n\n    [root@abao~]# rsync -av -e ssh /tmp axing@172.168.72.68:~\n\n2、 将远程机器的内容拷贝到本地机器（源路径中使用一个冒号）\n\n命令格式为：rsync[OPTION]… [USER@]HOST:SRC DEST。如下\n\n\n    [root@abao~]# rsync -av -e ssh axing@172.168.72.68:~ /tmp\n\nl  直接通过rsync的服务来传输（此时服务器端需要启动873端口，并且使用两个冒号）\n\n这种方式在远程主机上建立一个rsync的服务器，在服务器上配置好rsync的各种应用，然后本机作为rsync的一个客户端去连接远程的rsync服务器\n\n1、 从远程rsync服务器中拷贝文件到本地机（源路径中使用一个冒号）\n\n命令格式为：rsync[OPTION]… [USER@]HOST::模块名 本地位置。如下\n\n\n    [root@abao~]# rsync -av axing@172.168.72.68:：back /databack\n\n2、从本地机器拷贝文件到远程rsync服务器中（目标路径中使用一个冒号）\n\n命令格式为：rsync[OPTION]… SRC [USER@]HOST::DEST。如下\n\n    [root@abao~]# rsync -av /databack axing@172.168.72.68:：back\n    \n以上3中传输方式的差异在于有没有冒号“：”，本地端传输不需要冒号，通过rsh或ssh传输时需要一个冒号，而通过rsync传输时需要两个冒号\n\n三、Rsync的语法\n\n    -v： 查看模式可以列出很多信息包括文件名\n    \n    -r： 递归复制，可以针对目录来复制\n    \n    -u： 仅更新，如果目标文件比较新那么则保留新文件不会覆盖\n    \n    -l： 复制链接文件的属性\n    \n    -p： 连同属性一起复制\n    \n    -g： 保存源文件的属组\n    \n    -o： 保存源文件的属主\n    \n    -D： 保存源文件的设备属性\n    \n    -t： 保存原文件的时间参数\n    \n    -z： 在传输时加上压缩\n    \n    -e： 使用的协议，例如使用ssh通道就是-e ssh\n    \n    -a： 相当于-rlptgoD，是最常用的参数\n    \n    -L： 把SRC中软连接的目标文件给拷贝到DST.\n    \n    –delete：如果在DST增加文件了，而SRC当中没有这些文件，同步时会删除新增的文件\n    \n    –exclude=filename：  指定排除不需要传输的文件，等号后面跟文件名（如*.txt）\n    \n    –progress：  可以看到同步的过程状态，比如文件数量、文件传输速度等\n\n四、在本机直接运行拷贝本地文件实例\n\n    [root@abao ~]# rsync -av /etc/tmp#首次本地备份\n    \n    …………………………………………………………………\n    \n    sent 33899909 bytes  received 35626 bytes  5220851.54 bytes/sec\n    \n    total size is 33759697  speedup is 0.99\n    \n    [root@abao ~]# ll -d /tmp/etc/etc#两文件相同\n    \n    drwxr-xr-x. 126 root root12288 10月 10 08:23 /etc\n    \n    drwxr-xr-x. 126 root root12288 10月 10 08:23 /tmp/etc\n    \n    [root@abao ~]# rsync -av /etc/tmp#再次备份时只备份差异文件\n    \n    sending incremental file list\n    \n    sent 77528 bytes  received 293 bytes  155642.00 bytes/sec\n    \n    total size is 33759697  speedup is 433.81\n\n五、通过rsh或ssh的信道在server/client之间进行传输数据实例\n\n    [root@abao ~]# /etc/init.d/sshd restart\n    \n    停止 sshd：[确定]\n    \n    正在启动 sshd：[确定]\n    \nl  将本地机器的内容拷贝到远程机器\n\n    [root@abao ~]# rsync -av -e ssh /tmp admin@172.168.72.68:~\n    \n    admin@172.168.72.68’s password:   #需要输入账户密码\n    \n    …………………………………………………………………………\n    \n    sent 238637037 bytes received 60045 bytes  3819153.31bytes/sec\n    \n    total size is 238396030 speedup is 1.00\n\nl  将远程机器的内容拷贝到本地机器\n\n    [root@abao ~]# rsync -av -e ssh axing@172.168.72.68:~ /tmp\n    \n    axing@172.168.72.68’s password:   #需要输入账户密码\n    \n    receiving incremental file list\n    \n    axing/\n    \n    axing/.ICEauthority\n    \n    …………………………………………………………………\n    \n    sent 1732 bytes  received758924 bytes  80069.05 bytes/sec\n    \n    total size is 751474 speedup is 0.99\n    \n    [root@abao ~]# ll -d /tmp/axing\n    \n    drwx——. 27 500 500 4096 10月 10 08:23 /tmp/axing\n\nl  利用crontab通过ssh进行免密码异地备份脚本（常用）\n\n我们可以针对用户admin制作一个免密码登陆的ssh秘钥，这样以后异地备份系统就可以使用crontab自动备份了，前提是先根据下面（六、直接通过rsync的服务来传输实例）安装并设置好rsync\n\n1、ssh服务器端和客户端账户建立\n\n    [root@baobao ~]# mkdir /home/back; touch /home/back/wo#创建要备份的文件\n    \n    [root@baobao ~]# chmod -R 755 /home/back/\n    \n    [root@baobao ~]# useradd admin#先在ssh服务器端ssh账号\n    \n    [root@baobao ~]# passwd admin\n    \n    更改用户 admin 的密码 。\n    \n    新的 密码：\n    \n    重新输入新的 密码：\n    \n    passwd： 所有的身份验证令牌已经成功更新。\n    \n    [root@abao ~]# useradd admin  #客户端上建立ssh账号\n    \n    [root@abao ~]# passwd admin\n    \n    更改用户 admin 的密码 。\n    \n    新的 密码：\n    \n    重新输入新的 密码：\n    \n    passwd： 所有的身份验证令牌已经成功更新。\n\n2、客户端建立两把钥匙\n\n    [root@abao ~]# su – admin\n    \n    [admin@abao ~]$ ssh-keygen\n    \n    Generating public/private rsa key pair.\n    \n    Enter file in which to save the key (/home/admin/.ssh/id_rsa):\n    \n    Created directory ‘/home/admin/.ssh’.\n    \n    Enter passphrase (empty for no passphrase):\n    \n    Enter same passphrase again:\n    \n    Your identification has been saved in /home/admin/.ssh/id_rsa.\n    \n    Your public key has been saved in /home/admin/.ssh/id_rsa.pub.\n    \n    The key fingerprint is:\n    \n    61:01:c2:9b:26:00:0a:01:c9:a0:58:7e:38:f9:85:6c admin@abao\n    \n    The key’s randomart image is:\n    \n    +–[ RSA 2048]—-+\n    \n    |@o… …|\n    \n    |B+ +.o   .   |\n    \n    |+.= Eo. o|\n    \n    |  .=+. . .   |\n    \n    |   o.   S   |\n    \n    | |\n    \n    | |\n    \n    | |\n    \n    | |\n    \n    +—————–+\n    \n    [admin@abao ~]$ ls -ld ~/.ssh; ls -l ~/.ssh\n    \n    drwx——. 2 admin admin 4096 10月 10 09:21 /home/admin/.ssh\n    \n    总用量 8\n    \n    -rw——-. 1 admin admin 1675 10月 10 09:21 id_rsa\n    \n    -rw-r–r–. 1 admin admin 392 10月 10 09:21 id_rsa.pub\n\n3、将公钥文件数据上传到服务器\n\n    [admin@abao ~]$ scp ~/.ssh/id_rsa.pub admin@172.168.72.68:~#客户端上传公钥文件\n    \n    admin@172.168.72.68’s password:\n    \n    id_rsa.pub100%  3920.4KB/s   00:00\n\n4、将公钥放置到服务器端的正确目录与文件名（服务器上操作）\n\n    [root@baobao ~]# su – admin\n    \n    [admin@baobao ~]$ ls -ld .ssh\n    \n    ls: 无法访问.ssh: 没有那个文件或目录\n    \n    [admin@baobao ~]$ mkdir .ssh; chmod 700 .ssh #服务器上建立文件~/.ssh\n    \n    [admin@baobao ~]$ ls -ld .ssh\n    \n    drwx—— 2 admin admin 4096 10月 10 09:36 .ssh\n    \n    [admin@baobao ~]$ ls -l *pub\n    \n    -rw-r–r– 1 admin admin 392 10月 10 09:27 id_rsa.pub\n    \n    [admin@baobao ~]$ cat id_rsa.pub >> .ssh/authorized_keys\n    \n    [admin@baobao ~]$ chmod 644 .ssh/authorized_keys\n    \n    [admin@baobao ~]$ ls -l .ssh\n    \n    总用量 4\n    \n    -rw-r–r– 1 admin admin 392 10月 10 09:38 authorized_keys\n\n5、在客户端建立异地备份脚本\n\n    [root@abao ~]# mkdir /backups\n    \n    [root@abao ~]# chmod -R 755 /backups/\n    \n    [root@abao ~]# su – admin\n    \n    [admin@abao ~]$ mkdir ~/bin; vim ~/bin/backup.sh\n    \n    #!/bin/bash\n    \n    localdir=/backups\n    \n    remotedir=/home/back/\n    \n    remoteip=”172.168.72.68″\n    \n    [ -d ${localdir} ] || mkdir ${localdir}   #-d是判断是否有这个目录；符号“||”是逻辑或意思，左边为假时执行右边命令；小括号一般用作执行命令，而自定义变量一般用大括号括起来\n    \n    for dir in ${remotedir}\n    \n    do\n    \n    rsync -av -essh admin@${remoteip}:${dir} ${localdir}\n    \n    done\n    \n    [admin@abao ~]$ chmod 755 ~/bin/backup.sh\n    \n    [admin@abao ~]$ ls -ld /home/admin/bin/backup.sh\n    \n    -rwxrwxr-x. 1 admin admin 224 10月 11 08:49 /home/admin/bin/backup.sh\n    \n    [admin@abao ~]$ ~/bin/backup.sh   #执行脚本\n    \n    receiving incremental filelist\n    \n    sent 11 bytes  received 43 bytes  5.68 bytes/sec\n    \n    total size is 1010  speedup is 18.70\n    \n6、制作crontab计划任务\n\n    [root@abao ~]# crontab –e #每天的凌晨02:00异地备份服务器上的/etc /root /home目录到本地的/backups/下\n    0 2 * * * /home/admin/bin/backup.sh\n\n六、直接通过rsync的服务来传输实例\n\nl  创建用户账号和rsync配置文件\n\n    [root@baobao ~]# useraddadmin   #创建链接用户\n    \n    [root@baobao ~]# passwd admin\n    \n    更改用户 admin 的密码。\n    \n    新的 密码：\n    \n    重新输入新的 密码：\n    \n    passwd： 所有的身份验证令牌已经成功更新。\n    \n    [root@baobao ~]# mkdir /home/back   #创建要进行备份的目录或文件\n    \n    [root@baobao ~]# touch/home/back/guo\n    \n    [root@baobao ~]# vim/home/back/guo\n    \n    [root@baobao ~]# chmod -R 755/home/back/#设定要备份的目录或文件权限\n    \n    [root@baobao ~]# yum -yinstall xinetd\n    \n    [root@baobao ~]# yum -yinstall rsync#安装rsync\n    \n    [root@baobao ~]# yum -yinstall rsync#客户端也安装rsync\n    \n    [root@baobao ~]# touch/etc/rsyncd.conf  #默认该文件是没有的\n    \n    [root@baobao ~]# chmod 600/etc/rsyncd.conf  #修改配置文件权限\n\nl  Rsync服务器端配置文件设置\n\n配置文件时即时生效的，不用重启服务\n\n1、/etc/rsyncd.conf配置\n\n1)  全局参数配置\n\n    [root@baobao ~]# manrsyncd.conf   #查看说明文档看下面部分参数是yes/no还是true/false\n    \n    [root@baobao ~]# vim/etc/rsyncd.conf\n    \n    uid=root  #运行RSYNC守护进程的用户\n    \n    gid=root  #运行RSYNC守护进程的组\n    \n    use chroot=false  #不使用chroot\n    \n    max connections=8 #最大连接数是4\n    \n    pid file=/var/run/rsyncd.pid  #pid文件默认存放位置\n    \n    lock file=/var/run/rsync.lock #锁文件默认存放位置（锁住rsync正在操作的文件不让其他的程序对其进行写操作）\n    \n    log file=/var/log/rsyncd.log  #日志文件默认存放位置\n    \n    strict modes=true #是否检查口令文件的权限\n    port=873  #默认端口873\n    \n2)  模块参数配置(多台客户端需要设置多个模块)\n\n    [backup]   #认证的模块名，在client端需要指定\n    \n    path=/etc  #需要做备份的目录\n    \n    comment=This is backup #这个模块的注释信息\n    \n    list=true  #当用户查询该服务器上的可用模块时，该模块是被列出（true）还是被隐藏（false）\n    \n    max connections=6  #客户端最大连接数(默认0没限制)，模块里可以不设置\n    ignore errors  #可以忽略一些无关的IO错误\n    read only=false#“yes”只读客户端不能上传；“no”客户端可以上传\n    write only=false   #“yes”客户端不能下载；“no”客户端可以下载\n    \n    uid=root   #指定该模块传输文件时守护进程应该具有的uid\n    gid=root   #指定该模块传输文件时守护进程应该具有的gid\n    hosts allow=172.168.0.0/16 #允许连接的主机（“*”充许任何主机连接），多个主机用“，”分开；多个网段用空格隔开\n    hosts deny=192.168.10.0/32 #禁止连接的主机或网段\n    \n    auth users=admin   #登陆系统使用的用户名（系统必须存在的用户），没有默认为匿名\n    secrets file= /etc/rsyncd.secrets #登陆用户的密码文件（需要自己生成）\n\n2、rsync server启动文件配置\n\n    [root@baobao ~]# vim /etc/xinetd.d/rsync#只修改disable = no即可\n    \n    # default: off\n    \n    # description: The rsyncserver is a good addition to an ftp server, as it \\\n    \n    #   allows crc checksumming etc.\n    \n    service rsync\n    \n    {\n    \n    disable = no\n    \n    flags   = IPv6\n    \n    socket_type = stream\n    \n    wait= no\n    \n    user= root\n    \n    server  = /usr/bin/rsync\n    \n    server_args = –daemon\n    \n    log_on_failure  += USERID\n    \n    }\n    \n    [root@baobao ~]# chkconfigrsync on\n    \nl  创建密码文件、欢迎信息\n\n1、生成rsync密码文件并设置该文件相应权限\n    [root@baobao ~]# touch /etc/rsyncd.secrets\n    \n    [root@baobao ~]# vim /etc/rsyncd.secrets\n    \n    admin:guobaobao!1314#格式为“账号：密码”且一行一个\n    [root@baobao ~]# chown root.root /etc/rsyncd.secrets\n    \n    [root@baobao ~]# chmod 600 /etc/rsyncd.secrets\n    \n    因为rsyncd.secrets存储了rsync服务的用户名和密码，所以要将rsyncd.secrets设置为root拥有, 且权限为600\n\n2、配置欢迎信息rsyncd.motd（可有可无）\n    [root@baobao ~]# vim /etc/rsyncd.motd   #rsyncd.motd记录了rsync服务的欢迎信息\n    \n    Welcome to use the rsyncservices!\n    [root@baobao ~]# service xinetd restart\n    \n    停止 xinetd：  [确定]\n    \n    正在启动 xinetd：  [确定]\n    \nl  Rsync的启动与开机启动\n\n1、Rsync服务端启动\n\n1)  载入配置\n\n    [root@baobao ~]# rsync –daemon–config=/etc/rsyncd.conf   #载入配置并启动\n    \n    或\n    \n    [root@baobao ~]# /etc/rc.d/init.d/xinetdreload\n    \n    重新载入配置： [确定]\n\n2)  重启rsync\n\n    [root@baobao ~]# /usr/bin/rsync –daemon\n    \n    failed to create pid file/var/run/rsyncd.pid: File exists\n    \n    或\n    \n    [root@baobao ~]# /etc/rc.d/init.d/xinetdrestart#重新启动\n    \n    停止 xinetd：  [确定]\n    \n    正在启动 xinetd：  [确定]\n\n3)  检查rsync是否启动\n\n    [root@baobao ~]# netstat -lnp | grep 873#由超级进程启动\n    \n    tcp   0  0 0.0.0.0:8730.0.0.0:*LISTEN  3133/rsync\n    \n    tcp   0  0 :::873 :::*LISTEN 3133/rsync\n    \n    或\n    \n    [root@baobao ~]# netstat -a |grep rsync\n    \n    tcp0  0*:rsync *:* LISTEN\n    \n    或\n    \n    [root@baobao ~]# lsof -i:873 #端口没有被占用\n    \n    COMMAND  PID USER  FD   TYPE DEVICE SIZE/OFF NODENAME\n    \n    rsync   3133 root   4u  IPv4  22973 0t0  TCP *:rsync (LISTEN)\n    \n    rsync   3133 root   5u  IPv6  22974 0t0  TCP *:rsync (LISTEN)\n\n4)  查看rsync日志\n\n    [root@baobao ~]# cat /var/log/rsyncd.log #查看rsync日志\n    \n    2014/10/14 15:29:13 [35681] rsyncdversion 3.0.6 starting, listening on port 873\n    \n2、将rsync加入开机启动\n\n    [root@baobao ~]# echo”/usr/bin/rsync –daemon –config=/etc/rsyncd.conf”>>/etc/rc.local\n    \n    [root@baobao ~]# cat/etc/rc.local\n    \n    #!/bin/sh\n    \n    #\n    \n    # This script will beexecuted *after* all the other init scripts.\n    \n    # You can put your owninitialization stuff in here if you don’t\n    \n    # want to do the full Sys Vstyle init stuff.\n    \n    touch /var/lock/subsys/local\n    \n    /usr/bin/rsync –daemon–config=/etc/rsyncd.conf\n\nl  Rsync服务器端配置防火墙\n\n1、防火墙设置\n\n    [root@baobao ~]# iptables -F\n    \n    [root@baobao ~]# iptables -X\n    \n    [root@baobao ~]# iptables -Z\n    \n    [root@baobao ~]# iptables -AINPUT -i eth0 -s 172.168.0.0/16 -p tcp –dport 22 -j ACCEPT\n    \n    [root@baobao ~]# iptables -L\n    \n    Chain INPUT (policy ACCEPT)\n    \n    target prot opt source   destination\n    \n    ACCEPT tcp —  ACA80000.ipt.aol.com/16  anywheretcp dpt:ssh\n    \n    Chain FORWARD (policy ACCEPT)\n    \n    target prot opt source   destination\n    \n    Chain OUTPUT (policy ACCEPT)\n    \n    target prot opt source   destination\n    \n    [root@baobao ~]#/etc/init.d/iptables save\n    \n    iptables：将防火墙规则保存到 /etc/sysconfig/iptables： [确定]\n    \n    [root@baobao ~]#/etc/init.d/iptables restart\n    \n    iptables：清除防火墙规则：[确定]\n    \n    iptables：将链设置为政策 ACCEPT：filter[确定]\n    \n    iptables：正在卸载模块：  [确定]\n    \n    iptables：应用防火墙规则：[确定]\n\n2、selinux设置\n\n\n    [root@baobao ~]# setenforce 0\n\nl  客户端测试\n\n    [root@abao ~]# rsync -avadmin@172.168.72.68::backup /backups/\n    \n    Password:\n    \n    receiving incremental filelist\n    \n    created directory /backups\n    \n    ./\n    \n    guo\n    \n    sent 79 bytes  received 1162 bytes  275.78 bytes/sec\n    \n    total size is 1010  speedup is 0.81\n\n可以看到这里还是需要输入密码，这样同样也不能写入脚本中自动执行\n\nl  常见问题处理\n\n1、错误一\n\n@ERROR: chroot failed\n\nrsync error: error startingclient-server protocol (code 5) at main.c(1522) [receiver=3.0.3]\n\n原因：服务器端的目录不存在或无权限\n\n2、错误二\n\n@ERROR: auth failed on moduletee\n\nrsync error: error startingclient-server protocol (code 5) at main.c(1522) [receiver=3.0.3]\n\n原因：服务器端该模块（tee）需要验证用户名密码，但客户端没有提供正确的用户名密码，认证失败。\n\n3、错误三\n\n@ERROR: Unknown module‘tee_nonexists’\n\nrsync error: error startingclient-server protocol (code 5) at main.c(1522) [receiver=3.0.3]\n\n原因：服务器不存在指定模块\n\n4、错误四\n\npassword file must not beother-accessible\n\ncontinuing without passwordfile\n\nPassword:\n\n原因：这是因为rsyncd.pwdrsyncd.secrets的权限不对，应该设置为600\n\n5、错误五\n\nrsync: failed to connect to218.107.243.2: No route to host (113)\n\nrsync error: error in socketIO (code 10) at clientserver.c(104) [receiver=2.6.9]\n\n原因：对方没开机、防火墙阻挡、通过的网络上有防火墙阻挡，都有可能\n\n6、错误六\n\nrsync error: error startingclient-server protocol (code 5) at main.c(1524) [Receiver=3.0.7]\n\n原因：/etc/rsyncd.conf配置文件内容有错误\n\n7、错误七\n\nrsync: chown “”failed: Invalid argument (22)\n\n原因：权限无法复制，去掉同步权限的参数即可(这种情况多见于Linux向Windows的时候)\n\n8、错误八\n\n@ERROR: daemon security issue– contact admin\nrsync error: error starting client-server protocol (code 5) at main.c(1530)[sender=3.0.6]\n\n原因：同步的目录里面有软连接文件，需要服务器端的/etc/rsyncd.conf打开use chroot = yes掠过软连接文件。\n\nl  建立不需输入密码的链接\n\n这样就可以将其写入脚本和任务计划自动运行了\n\n1、第一种方案：指定密码文件\n\n    [root@abao ~]# touch/etc/pass#客户端上建立密码文件\n    \n    [root@abao ~]# vim /etc/pass #将账户“admin”密码写入\n    \n    [root@abao ~]# cat /etc/pass\n    \n    guobaobao！1314\n    \n    [root@abao ~]# chmod 600/etc/pass\n    \n    [root@abao ~]# rsync -avadmin@172.168.72.68::backup /backups/\n    \n    Password:\n    \n    @ERROR: auth failed on modulebackup\n    \n    rsync error: error startingclient-server protocol (code 5) at main.c(1503) [receiver=3.0.6]\n    \n    [root@abao ~]#\n    \n    [root@abao ~]# rsync -avadmin@172.168.72.68::backup /backups/ –password-file=/etc/pass #注意黑体部分指定密码文件\n    \n    receiving incremental filelist\n    \n    sent 57 bytes  received 106 bytes  326.00 bytes/sec\n    \n    total size is 1010  speedup is 6.20\n    \n2、第二种方案：在rsync服务器端不指定用户\n\n    [root@baobao ~]# vim/etc/rsyncd.conf   #服务器端配置文件注释掉下面认证两行\n    \n    #auth users=admin\n    \n    #secretsfile=/etc/rsyncd.secrets\n    \n    [root@abao ~]# rsync -avadmin@172.168.72.68::backup /backups/\n    \n    receiving incremental filelist\n    \n    sent 28 bytes  received 65 bytes  37.20 bytes/sec\n    \n    total size is 1010  speedup is 10.86\n    \n    或\n    \n    [root@abao ~]# rsync -av172.168.72.68::backup /backups/#不加账户默认是root\n    \n    receiving incremental filelist\n    \n    sent 28 bytes  received 65 bytes  186.00 bytes/sec\n    \n    total size is 1010  speedup is 10.86","source":"_posts/linux—SSH（二）Rsync备份.md","raw":"---\ntitle: linux—SSH（二）Rsync备份\ndate: 2016-09-02\ntags:\n---\n一、Rsync软件介绍\n\nrsync从字面上的意思就是remote sync （远程同步）的意思，是类unix系统下的远程数据镜像备份工具，可以镜像保存整个目录树和文件系统，并保持原来文件的权限、时间、软硬链接等，此外它还支持匿名传输；Rsync不仅可以远程同步数据（类似于scp）还可以本地同步数据（类似于cp），但不同于cp或scp的是rsync不像cp/scp一样会覆盖以前的数据，Rsync使用所谓的“Rsync演算法”，这个算法在第一次连通完成时，会把整份文件传输一次，下一次就只传送二个文件之间不同的部份，因此速度相当快\n<!--more-->\n二、Rsync的传输方式（或工作模式）\n\nl  在本机直接运行拷贝本地文件（不使用冒号）\n\n命令格式为：rsync[OPTION]… SRC DEST。如下\n\n    [root@abao~]# rsync -av /etc /tmp\n    \nl  通过rsh或ssh的信道在server/client之间进行传输数据（使用一个冒号）\n\n需要登录到服务器上执行任务，并且需要输入账号的密码\n\n1、 将本地机器的内容拷贝到远程机器（目标路径中使用一个冒号）\n\n命令格式为：rsync[OPTION]… SRC [USER@]HOST:DEST。如下\n\n\n    [root@abao~]# rsync -av -e ssh /tmp axing@172.168.72.68:~\n\n2、 将远程机器的内容拷贝到本地机器（源路径中使用一个冒号）\n\n命令格式为：rsync[OPTION]… [USER@]HOST:SRC DEST。如下\n\n\n    [root@abao~]# rsync -av -e ssh axing@172.168.72.68:~ /tmp\n\nl  直接通过rsync的服务来传输（此时服务器端需要启动873端口，并且使用两个冒号）\n\n这种方式在远程主机上建立一个rsync的服务器，在服务器上配置好rsync的各种应用，然后本机作为rsync的一个客户端去连接远程的rsync服务器\n\n1、 从远程rsync服务器中拷贝文件到本地机（源路径中使用一个冒号）\n\n命令格式为：rsync[OPTION]… [USER@]HOST::模块名 本地位置。如下\n\n\n    [root@abao~]# rsync -av axing@172.168.72.68:：back /databack\n\n2、从本地机器拷贝文件到远程rsync服务器中（目标路径中使用一个冒号）\n\n命令格式为：rsync[OPTION]… SRC [USER@]HOST::DEST。如下\n\n    [root@abao~]# rsync -av /databack axing@172.168.72.68:：back\n    \n以上3中传输方式的差异在于有没有冒号“：”，本地端传输不需要冒号，通过rsh或ssh传输时需要一个冒号，而通过rsync传输时需要两个冒号\n\n三、Rsync的语法\n\n    -v： 查看模式可以列出很多信息包括文件名\n    \n    -r： 递归复制，可以针对目录来复制\n    \n    -u： 仅更新，如果目标文件比较新那么则保留新文件不会覆盖\n    \n    -l： 复制链接文件的属性\n    \n    -p： 连同属性一起复制\n    \n    -g： 保存源文件的属组\n    \n    -o： 保存源文件的属主\n    \n    -D： 保存源文件的设备属性\n    \n    -t： 保存原文件的时间参数\n    \n    -z： 在传输时加上压缩\n    \n    -e： 使用的协议，例如使用ssh通道就是-e ssh\n    \n    -a： 相当于-rlptgoD，是最常用的参数\n    \n    -L： 把SRC中软连接的目标文件给拷贝到DST.\n    \n    –delete：如果在DST增加文件了，而SRC当中没有这些文件，同步时会删除新增的文件\n    \n    –exclude=filename：  指定排除不需要传输的文件，等号后面跟文件名（如*.txt）\n    \n    –progress：  可以看到同步的过程状态，比如文件数量、文件传输速度等\n\n四、在本机直接运行拷贝本地文件实例\n\n    [root@abao ~]# rsync -av /etc/tmp#首次本地备份\n    \n    …………………………………………………………………\n    \n    sent 33899909 bytes  received 35626 bytes  5220851.54 bytes/sec\n    \n    total size is 33759697  speedup is 0.99\n    \n    [root@abao ~]# ll -d /tmp/etc/etc#两文件相同\n    \n    drwxr-xr-x. 126 root root12288 10月 10 08:23 /etc\n    \n    drwxr-xr-x. 126 root root12288 10月 10 08:23 /tmp/etc\n    \n    [root@abao ~]# rsync -av /etc/tmp#再次备份时只备份差异文件\n    \n    sending incremental file list\n    \n    sent 77528 bytes  received 293 bytes  155642.00 bytes/sec\n    \n    total size is 33759697  speedup is 433.81\n\n五、通过rsh或ssh的信道在server/client之间进行传输数据实例\n\n    [root@abao ~]# /etc/init.d/sshd restart\n    \n    停止 sshd：[确定]\n    \n    正在启动 sshd：[确定]\n    \nl  将本地机器的内容拷贝到远程机器\n\n    [root@abao ~]# rsync -av -e ssh /tmp admin@172.168.72.68:~\n    \n    admin@172.168.72.68’s password:   #需要输入账户密码\n    \n    …………………………………………………………………………\n    \n    sent 238637037 bytes received 60045 bytes  3819153.31bytes/sec\n    \n    total size is 238396030 speedup is 1.00\n\nl  将远程机器的内容拷贝到本地机器\n\n    [root@abao ~]# rsync -av -e ssh axing@172.168.72.68:~ /tmp\n    \n    axing@172.168.72.68’s password:   #需要输入账户密码\n    \n    receiving incremental file list\n    \n    axing/\n    \n    axing/.ICEauthority\n    \n    …………………………………………………………………\n    \n    sent 1732 bytes  received758924 bytes  80069.05 bytes/sec\n    \n    total size is 751474 speedup is 0.99\n    \n    [root@abao ~]# ll -d /tmp/axing\n    \n    drwx——. 27 500 500 4096 10月 10 08:23 /tmp/axing\n\nl  利用crontab通过ssh进行免密码异地备份脚本（常用）\n\n我们可以针对用户admin制作一个免密码登陆的ssh秘钥，这样以后异地备份系统就可以使用crontab自动备份了，前提是先根据下面（六、直接通过rsync的服务来传输实例）安装并设置好rsync\n\n1、ssh服务器端和客户端账户建立\n\n    [root@baobao ~]# mkdir /home/back; touch /home/back/wo#创建要备份的文件\n    \n    [root@baobao ~]# chmod -R 755 /home/back/\n    \n    [root@baobao ~]# useradd admin#先在ssh服务器端ssh账号\n    \n    [root@baobao ~]# passwd admin\n    \n    更改用户 admin 的密码 。\n    \n    新的 密码：\n    \n    重新输入新的 密码：\n    \n    passwd： 所有的身份验证令牌已经成功更新。\n    \n    [root@abao ~]# useradd admin  #客户端上建立ssh账号\n    \n    [root@abao ~]# passwd admin\n    \n    更改用户 admin 的密码 。\n    \n    新的 密码：\n    \n    重新输入新的 密码：\n    \n    passwd： 所有的身份验证令牌已经成功更新。\n\n2、客户端建立两把钥匙\n\n    [root@abao ~]# su – admin\n    \n    [admin@abao ~]$ ssh-keygen\n    \n    Generating public/private rsa key pair.\n    \n    Enter file in which to save the key (/home/admin/.ssh/id_rsa):\n    \n    Created directory ‘/home/admin/.ssh’.\n    \n    Enter passphrase (empty for no passphrase):\n    \n    Enter same passphrase again:\n    \n    Your identification has been saved in /home/admin/.ssh/id_rsa.\n    \n    Your public key has been saved in /home/admin/.ssh/id_rsa.pub.\n    \n    The key fingerprint is:\n    \n    61:01:c2:9b:26:00:0a:01:c9:a0:58:7e:38:f9:85:6c admin@abao\n    \n    The key’s randomart image is:\n    \n    +–[ RSA 2048]—-+\n    \n    |@o… …|\n    \n    |B+ +.o   .   |\n    \n    |+.= Eo. o|\n    \n    |  .=+. . .   |\n    \n    |   o.   S   |\n    \n    | |\n    \n    | |\n    \n    | |\n    \n    | |\n    \n    +—————–+\n    \n    [admin@abao ~]$ ls -ld ~/.ssh; ls -l ~/.ssh\n    \n    drwx——. 2 admin admin 4096 10月 10 09:21 /home/admin/.ssh\n    \n    总用量 8\n    \n    -rw——-. 1 admin admin 1675 10月 10 09:21 id_rsa\n    \n    -rw-r–r–. 1 admin admin 392 10月 10 09:21 id_rsa.pub\n\n3、将公钥文件数据上传到服务器\n\n    [admin@abao ~]$ scp ~/.ssh/id_rsa.pub admin@172.168.72.68:~#客户端上传公钥文件\n    \n    admin@172.168.72.68’s password:\n    \n    id_rsa.pub100%  3920.4KB/s   00:00\n\n4、将公钥放置到服务器端的正确目录与文件名（服务器上操作）\n\n    [root@baobao ~]# su – admin\n    \n    [admin@baobao ~]$ ls -ld .ssh\n    \n    ls: 无法访问.ssh: 没有那个文件或目录\n    \n    [admin@baobao ~]$ mkdir .ssh; chmod 700 .ssh #服务器上建立文件~/.ssh\n    \n    [admin@baobao ~]$ ls -ld .ssh\n    \n    drwx—— 2 admin admin 4096 10月 10 09:36 .ssh\n    \n    [admin@baobao ~]$ ls -l *pub\n    \n    -rw-r–r– 1 admin admin 392 10月 10 09:27 id_rsa.pub\n    \n    [admin@baobao ~]$ cat id_rsa.pub >> .ssh/authorized_keys\n    \n    [admin@baobao ~]$ chmod 644 .ssh/authorized_keys\n    \n    [admin@baobao ~]$ ls -l .ssh\n    \n    总用量 4\n    \n    -rw-r–r– 1 admin admin 392 10月 10 09:38 authorized_keys\n\n5、在客户端建立异地备份脚本\n\n    [root@abao ~]# mkdir /backups\n    \n    [root@abao ~]# chmod -R 755 /backups/\n    \n    [root@abao ~]# su – admin\n    \n    [admin@abao ~]$ mkdir ~/bin; vim ~/bin/backup.sh\n    \n    #!/bin/bash\n    \n    localdir=/backups\n    \n    remotedir=/home/back/\n    \n    remoteip=”172.168.72.68″\n    \n    [ -d ${localdir} ] || mkdir ${localdir}   #-d是判断是否有这个目录；符号“||”是逻辑或意思，左边为假时执行右边命令；小括号一般用作执行命令，而自定义变量一般用大括号括起来\n    \n    for dir in ${remotedir}\n    \n    do\n    \n    rsync -av -essh admin@${remoteip}:${dir} ${localdir}\n    \n    done\n    \n    [admin@abao ~]$ chmod 755 ~/bin/backup.sh\n    \n    [admin@abao ~]$ ls -ld /home/admin/bin/backup.sh\n    \n    -rwxrwxr-x. 1 admin admin 224 10月 11 08:49 /home/admin/bin/backup.sh\n    \n    [admin@abao ~]$ ~/bin/backup.sh   #执行脚本\n    \n    receiving incremental filelist\n    \n    sent 11 bytes  received 43 bytes  5.68 bytes/sec\n    \n    total size is 1010  speedup is 18.70\n    \n6、制作crontab计划任务\n\n    [root@abao ~]# crontab –e #每天的凌晨02:00异地备份服务器上的/etc /root /home目录到本地的/backups/下\n    0 2 * * * /home/admin/bin/backup.sh\n\n六、直接通过rsync的服务来传输实例\n\nl  创建用户账号和rsync配置文件\n\n    [root@baobao ~]# useraddadmin   #创建链接用户\n    \n    [root@baobao ~]# passwd admin\n    \n    更改用户 admin 的密码。\n    \n    新的 密码：\n    \n    重新输入新的 密码：\n    \n    passwd： 所有的身份验证令牌已经成功更新。\n    \n    [root@baobao ~]# mkdir /home/back   #创建要进行备份的目录或文件\n    \n    [root@baobao ~]# touch/home/back/guo\n    \n    [root@baobao ~]# vim/home/back/guo\n    \n    [root@baobao ~]# chmod -R 755/home/back/#设定要备份的目录或文件权限\n    \n    [root@baobao ~]# yum -yinstall xinetd\n    \n    [root@baobao ~]# yum -yinstall rsync#安装rsync\n    \n    [root@baobao ~]# yum -yinstall rsync#客户端也安装rsync\n    \n    [root@baobao ~]# touch/etc/rsyncd.conf  #默认该文件是没有的\n    \n    [root@baobao ~]# chmod 600/etc/rsyncd.conf  #修改配置文件权限\n\nl  Rsync服务器端配置文件设置\n\n配置文件时即时生效的，不用重启服务\n\n1、/etc/rsyncd.conf配置\n\n1)  全局参数配置\n\n    [root@baobao ~]# manrsyncd.conf   #查看说明文档看下面部分参数是yes/no还是true/false\n    \n    [root@baobao ~]# vim/etc/rsyncd.conf\n    \n    uid=root  #运行RSYNC守护进程的用户\n    \n    gid=root  #运行RSYNC守护进程的组\n    \n    use chroot=false  #不使用chroot\n    \n    max connections=8 #最大连接数是4\n    \n    pid file=/var/run/rsyncd.pid  #pid文件默认存放位置\n    \n    lock file=/var/run/rsync.lock #锁文件默认存放位置（锁住rsync正在操作的文件不让其他的程序对其进行写操作）\n    \n    log file=/var/log/rsyncd.log  #日志文件默认存放位置\n    \n    strict modes=true #是否检查口令文件的权限\n    port=873  #默认端口873\n    \n2)  模块参数配置(多台客户端需要设置多个模块)\n\n    [backup]   #认证的模块名，在client端需要指定\n    \n    path=/etc  #需要做备份的目录\n    \n    comment=This is backup #这个模块的注释信息\n    \n    list=true  #当用户查询该服务器上的可用模块时，该模块是被列出（true）还是被隐藏（false）\n    \n    max connections=6  #客户端最大连接数(默认0没限制)，模块里可以不设置\n    ignore errors  #可以忽略一些无关的IO错误\n    read only=false#“yes”只读客户端不能上传；“no”客户端可以上传\n    write only=false   #“yes”客户端不能下载；“no”客户端可以下载\n    \n    uid=root   #指定该模块传输文件时守护进程应该具有的uid\n    gid=root   #指定该模块传输文件时守护进程应该具有的gid\n    hosts allow=172.168.0.0/16 #允许连接的主机（“*”充许任何主机连接），多个主机用“，”分开；多个网段用空格隔开\n    hosts deny=192.168.10.0/32 #禁止连接的主机或网段\n    \n    auth users=admin   #登陆系统使用的用户名（系统必须存在的用户），没有默认为匿名\n    secrets file= /etc/rsyncd.secrets #登陆用户的密码文件（需要自己生成）\n\n2、rsync server启动文件配置\n\n    [root@baobao ~]# vim /etc/xinetd.d/rsync#只修改disable = no即可\n    \n    # default: off\n    \n    # description: The rsyncserver is a good addition to an ftp server, as it \\\n    \n    #   allows crc checksumming etc.\n    \n    service rsync\n    \n    {\n    \n    disable = no\n    \n    flags   = IPv6\n    \n    socket_type = stream\n    \n    wait= no\n    \n    user= root\n    \n    server  = /usr/bin/rsync\n    \n    server_args = –daemon\n    \n    log_on_failure  += USERID\n    \n    }\n    \n    [root@baobao ~]# chkconfigrsync on\n    \nl  创建密码文件、欢迎信息\n\n1、生成rsync密码文件并设置该文件相应权限\n    [root@baobao ~]# touch /etc/rsyncd.secrets\n    \n    [root@baobao ~]# vim /etc/rsyncd.secrets\n    \n    admin:guobaobao!1314#格式为“账号：密码”且一行一个\n    [root@baobao ~]# chown root.root /etc/rsyncd.secrets\n    \n    [root@baobao ~]# chmod 600 /etc/rsyncd.secrets\n    \n    因为rsyncd.secrets存储了rsync服务的用户名和密码，所以要将rsyncd.secrets设置为root拥有, 且权限为600\n\n2、配置欢迎信息rsyncd.motd（可有可无）\n    [root@baobao ~]# vim /etc/rsyncd.motd   #rsyncd.motd记录了rsync服务的欢迎信息\n    \n    Welcome to use the rsyncservices!\n    [root@baobao ~]# service xinetd restart\n    \n    停止 xinetd：  [确定]\n    \n    正在启动 xinetd：  [确定]\n    \nl  Rsync的启动与开机启动\n\n1、Rsync服务端启动\n\n1)  载入配置\n\n    [root@baobao ~]# rsync –daemon–config=/etc/rsyncd.conf   #载入配置并启动\n    \n    或\n    \n    [root@baobao ~]# /etc/rc.d/init.d/xinetdreload\n    \n    重新载入配置： [确定]\n\n2)  重启rsync\n\n    [root@baobao ~]# /usr/bin/rsync –daemon\n    \n    failed to create pid file/var/run/rsyncd.pid: File exists\n    \n    或\n    \n    [root@baobao ~]# /etc/rc.d/init.d/xinetdrestart#重新启动\n    \n    停止 xinetd：  [确定]\n    \n    正在启动 xinetd：  [确定]\n\n3)  检查rsync是否启动\n\n    [root@baobao ~]# netstat -lnp | grep 873#由超级进程启动\n    \n    tcp   0  0 0.0.0.0:8730.0.0.0:*LISTEN  3133/rsync\n    \n    tcp   0  0 :::873 :::*LISTEN 3133/rsync\n    \n    或\n    \n    [root@baobao ~]# netstat -a |grep rsync\n    \n    tcp0  0*:rsync *:* LISTEN\n    \n    或\n    \n    [root@baobao ~]# lsof -i:873 #端口没有被占用\n    \n    COMMAND  PID USER  FD   TYPE DEVICE SIZE/OFF NODENAME\n    \n    rsync   3133 root   4u  IPv4  22973 0t0  TCP *:rsync (LISTEN)\n    \n    rsync   3133 root   5u  IPv6  22974 0t0  TCP *:rsync (LISTEN)\n\n4)  查看rsync日志\n\n    [root@baobao ~]# cat /var/log/rsyncd.log #查看rsync日志\n    \n    2014/10/14 15:29:13 [35681] rsyncdversion 3.0.6 starting, listening on port 873\n    \n2、将rsync加入开机启动\n\n    [root@baobao ~]# echo”/usr/bin/rsync –daemon –config=/etc/rsyncd.conf”>>/etc/rc.local\n    \n    [root@baobao ~]# cat/etc/rc.local\n    \n    #!/bin/sh\n    \n    #\n    \n    # This script will beexecuted *after* all the other init scripts.\n    \n    # You can put your owninitialization stuff in here if you don’t\n    \n    # want to do the full Sys Vstyle init stuff.\n    \n    touch /var/lock/subsys/local\n    \n    /usr/bin/rsync –daemon–config=/etc/rsyncd.conf\n\nl  Rsync服务器端配置防火墙\n\n1、防火墙设置\n\n    [root@baobao ~]# iptables -F\n    \n    [root@baobao ~]# iptables -X\n    \n    [root@baobao ~]# iptables -Z\n    \n    [root@baobao ~]# iptables -AINPUT -i eth0 -s 172.168.0.0/16 -p tcp –dport 22 -j ACCEPT\n    \n    [root@baobao ~]# iptables -L\n    \n    Chain INPUT (policy ACCEPT)\n    \n    target prot opt source   destination\n    \n    ACCEPT tcp —  ACA80000.ipt.aol.com/16  anywheretcp dpt:ssh\n    \n    Chain FORWARD (policy ACCEPT)\n    \n    target prot opt source   destination\n    \n    Chain OUTPUT (policy ACCEPT)\n    \n    target prot opt source   destination\n    \n    [root@baobao ~]#/etc/init.d/iptables save\n    \n    iptables：将防火墙规则保存到 /etc/sysconfig/iptables： [确定]\n    \n    [root@baobao ~]#/etc/init.d/iptables restart\n    \n    iptables：清除防火墙规则：[确定]\n    \n    iptables：将链设置为政策 ACCEPT：filter[确定]\n    \n    iptables：正在卸载模块：  [确定]\n    \n    iptables：应用防火墙规则：[确定]\n\n2、selinux设置\n\n\n    [root@baobao ~]# setenforce 0\n\nl  客户端测试\n\n    [root@abao ~]# rsync -avadmin@172.168.72.68::backup /backups/\n    \n    Password:\n    \n    receiving incremental filelist\n    \n    created directory /backups\n    \n    ./\n    \n    guo\n    \n    sent 79 bytes  received 1162 bytes  275.78 bytes/sec\n    \n    total size is 1010  speedup is 0.81\n\n可以看到这里还是需要输入密码，这样同样也不能写入脚本中自动执行\n\nl  常见问题处理\n\n1、错误一\n\n@ERROR: chroot failed\n\nrsync error: error startingclient-server protocol (code 5) at main.c(1522) [receiver=3.0.3]\n\n原因：服务器端的目录不存在或无权限\n\n2、错误二\n\n@ERROR: auth failed on moduletee\n\nrsync error: error startingclient-server protocol (code 5) at main.c(1522) [receiver=3.0.3]\n\n原因：服务器端该模块（tee）需要验证用户名密码，但客户端没有提供正确的用户名密码，认证失败。\n\n3、错误三\n\n@ERROR: Unknown module‘tee_nonexists’\n\nrsync error: error startingclient-server protocol (code 5) at main.c(1522) [receiver=3.0.3]\n\n原因：服务器不存在指定模块\n\n4、错误四\n\npassword file must not beother-accessible\n\ncontinuing without passwordfile\n\nPassword:\n\n原因：这是因为rsyncd.pwdrsyncd.secrets的权限不对，应该设置为600\n\n5、错误五\n\nrsync: failed to connect to218.107.243.2: No route to host (113)\n\nrsync error: error in socketIO (code 10) at clientserver.c(104) [receiver=2.6.9]\n\n原因：对方没开机、防火墙阻挡、通过的网络上有防火墙阻挡，都有可能\n\n6、错误六\n\nrsync error: error startingclient-server protocol (code 5) at main.c(1524) [Receiver=3.0.7]\n\n原因：/etc/rsyncd.conf配置文件内容有错误\n\n7、错误七\n\nrsync: chown “”failed: Invalid argument (22)\n\n原因：权限无法复制，去掉同步权限的参数即可(这种情况多见于Linux向Windows的时候)\n\n8、错误八\n\n@ERROR: daemon security issue– contact admin\nrsync error: error starting client-server protocol (code 5) at main.c(1530)[sender=3.0.6]\n\n原因：同步的目录里面有软连接文件，需要服务器端的/etc/rsyncd.conf打开use chroot = yes掠过软连接文件。\n\nl  建立不需输入密码的链接\n\n这样就可以将其写入脚本和任务计划自动运行了\n\n1、第一种方案：指定密码文件\n\n    [root@abao ~]# touch/etc/pass#客户端上建立密码文件\n    \n    [root@abao ~]# vim /etc/pass #将账户“admin”密码写入\n    \n    [root@abao ~]# cat /etc/pass\n    \n    guobaobao！1314\n    \n    [root@abao ~]# chmod 600/etc/pass\n    \n    [root@abao ~]# rsync -avadmin@172.168.72.68::backup /backups/\n    \n    Password:\n    \n    @ERROR: auth failed on modulebackup\n    \n    rsync error: error startingclient-server protocol (code 5) at main.c(1503) [receiver=3.0.6]\n    \n    [root@abao ~]#\n    \n    [root@abao ~]# rsync -avadmin@172.168.72.68::backup /backups/ –password-file=/etc/pass #注意黑体部分指定密码文件\n    \n    receiving incremental filelist\n    \n    sent 57 bytes  received 106 bytes  326.00 bytes/sec\n    \n    total size is 1010  speedup is 6.20\n    \n2、第二种方案：在rsync服务器端不指定用户\n\n    [root@baobao ~]# vim/etc/rsyncd.conf   #服务器端配置文件注释掉下面认证两行\n    \n    #auth users=admin\n    \n    #secretsfile=/etc/rsyncd.secrets\n    \n    [root@abao ~]# rsync -avadmin@172.168.72.68::backup /backups/\n    \n    receiving incremental filelist\n    \n    sent 28 bytes  received 65 bytes  37.20 bytes/sec\n    \n    total size is 1010  speedup is 10.86\n    \n    或\n    \n    [root@abao ~]# rsync -av172.168.72.68::backup /backups/#不加账户默认是root\n    \n    receiving incremental filelist\n    \n    sent 28 bytes  received 65 bytes  186.00 bytes/sec\n    \n    total size is 1010  speedup is 10.86","slug":"linux—SSH（二）Rsync备份","published":1,"updated":"2017-03-01T05:59:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizqklz7v0009lbpvksfsn1xp","content":"<p>一、Rsync软件介绍</p>\n<p>rsync从字面上的意思就是remote sync （远程同步）的意思，是类unix系统下的远程数据镜像备份工具，可以镜像保存整个目录树和文件系统，并保持原来文件的权限、时间、软硬链接等，此外它还支持匿名传输；Rsync不仅可以远程同步数据（类似于scp）还可以本地同步数据（类似于cp），但不同于cp或scp的是rsync不像cp/scp一样会覆盖以前的数据，Rsync使用所谓的“Rsync演算法”，这个算法在第一次连通完成时，会把整份文件传输一次，下一次就只传送二个文件之间不同的部份，因此速度相当快<br><a id=\"more\"></a><br>二、Rsync的传输方式（或工作模式）</p>\n<p>l  在本机直接运行拷贝本地文件（不使用冒号）</p>\n<p>命令格式为：rsync[OPTION]… SRC DEST。如下</p>\n<pre><code>[root@abao~]# rsync -av /etc /tmp\n</code></pre><p>l  通过rsh或ssh的信道在server/client之间进行传输数据（使用一个冒号）</p>\n<p>需要登录到服务器上执行任务，并且需要输入账号的密码</p>\n<p>1、 将本地机器的内容拷贝到远程机器（目标路径中使用一个冒号）</p>\n<p>命令格式为：rsync[OPTION]… SRC [USER@]HOST:DEST。如下</p>\n<pre><code>[root@abao~]# rsync -av -e ssh /tmp axing@172.168.72.68:~\n</code></pre><p>2、 将远程机器的内容拷贝到本地机器（源路径中使用一个冒号）</p>\n<p>命令格式为：rsync[OPTION]… [USER@]HOST:SRC DEST。如下</p>\n<pre><code>[root@abao~]# rsync -av -e ssh axing@172.168.72.68:~ /tmp\n</code></pre><p>l  直接通过rsync的服务来传输（此时服务器端需要启动873端口，并且使用两个冒号）</p>\n<p>这种方式在远程主机上建立一个rsync的服务器，在服务器上配置好rsync的各种应用，然后本机作为rsync的一个客户端去连接远程的rsync服务器</p>\n<p>1、 从远程rsync服务器中拷贝文件到本地机（源路径中使用一个冒号）</p>\n<p>命令格式为：rsync[OPTION]… [USER@]HOST::模块名 本地位置。如下</p>\n<pre><code>[root@abao~]# rsync -av axing@172.168.72.68:：back /databack\n</code></pre><p>2、从本地机器拷贝文件到远程rsync服务器中（目标路径中使用一个冒号）</p>\n<p>命令格式为：rsync[OPTION]… SRC [USER@]HOST::DEST。如下</p>\n<pre><code>[root@abao~]# rsync -av /databack axing@172.168.72.68:：back\n</code></pre><p>以上3中传输方式的差异在于有没有冒号“：”，本地端传输不需要冒号，通过rsh或ssh传输时需要一个冒号，而通过rsync传输时需要两个冒号</p>\n<p>三、Rsync的语法</p>\n<pre><code>-v： 查看模式可以列出很多信息包括文件名\n\n-r： 递归复制，可以针对目录来复制\n\n-u： 仅更新，如果目标文件比较新那么则保留新文件不会覆盖\n\n-l： 复制链接文件的属性\n\n-p： 连同属性一起复制\n\n-g： 保存源文件的属组\n\n-o： 保存源文件的属主\n\n-D： 保存源文件的设备属性\n\n-t： 保存原文件的时间参数\n\n-z： 在传输时加上压缩\n\n-e： 使用的协议，例如使用ssh通道就是-e ssh\n\n-a： 相当于-rlptgoD，是最常用的参数\n\n-L： 把SRC中软连接的目标文件给拷贝到DST.\n\n–delete：如果在DST增加文件了，而SRC当中没有这些文件，同步时会删除新增的文件\n\n–exclude=filename：  指定排除不需要传输的文件，等号后面跟文件名（如*.txt）\n\n–progress：  可以看到同步的过程状态，比如文件数量、文件传输速度等\n</code></pre><p>四、在本机直接运行拷贝本地文件实例</p>\n<pre><code>[root@abao ~]# rsync -av /etc/tmp#首次本地备份\n\n…………………………………………………………………\n\nsent 33899909 bytes  received 35626 bytes  5220851.54 bytes/sec\n\ntotal size is 33759697  speedup is 0.99\n\n[root@abao ~]# ll -d /tmp/etc/etc#两文件相同\n\ndrwxr-xr-x. 126 root root12288 10月 10 08:23 /etc\n\ndrwxr-xr-x. 126 root root12288 10月 10 08:23 /tmp/etc\n\n[root@abao ~]# rsync -av /etc/tmp#再次备份时只备份差异文件\n\nsending incremental file list\n\nsent 77528 bytes  received 293 bytes  155642.00 bytes/sec\n\ntotal size is 33759697  speedup is 433.81\n</code></pre><p>五、通过rsh或ssh的信道在server/client之间进行传输数据实例</p>\n<pre><code>[root@abao ~]# /etc/init.d/sshd restart\n\n停止 sshd：[确定]\n\n正在启动 sshd：[确定]\n</code></pre><p>l  将本地机器的内容拷贝到远程机器</p>\n<pre><code>[root@abao ~]# rsync -av -e ssh /tmp admin@172.168.72.68:~\n\nadmin@172.168.72.68’s password:   #需要输入账户密码\n\n…………………………………………………………………………\n\nsent 238637037 bytes received 60045 bytes  3819153.31bytes/sec\n\ntotal size is 238396030 speedup is 1.00\n</code></pre><p>l  将远程机器的内容拷贝到本地机器</p>\n<pre><code>[root@abao ~]# rsync -av -e ssh axing@172.168.72.68:~ /tmp\n\naxing@172.168.72.68’s password:   #需要输入账户密码\n\nreceiving incremental file list\n\naxing/\n\naxing/.ICEauthority\n\n…………………………………………………………………\n\nsent 1732 bytes  received758924 bytes  80069.05 bytes/sec\n\ntotal size is 751474 speedup is 0.99\n\n[root@abao ~]# ll -d /tmp/axing\n\ndrwx——. 27 500 500 4096 10月 10 08:23 /tmp/axing\n</code></pre><p>l  利用crontab通过ssh进行免密码异地备份脚本（常用）</p>\n<p>我们可以针对用户admin制作一个免密码登陆的ssh秘钥，这样以后异地备份系统就可以使用crontab自动备份了，前提是先根据下面（六、直接通过rsync的服务来传输实例）安装并设置好rsync</p>\n<p>1、ssh服务器端和客户端账户建立</p>\n<pre><code>[root@baobao ~]# mkdir /home/back; touch /home/back/wo#创建要备份的文件\n\n[root@baobao ~]# chmod -R 755 /home/back/\n\n[root@baobao ~]# useradd admin#先在ssh服务器端ssh账号\n\n[root@baobao ~]# passwd admin\n\n更改用户 admin 的密码 。\n\n新的 密码：\n\n重新输入新的 密码：\n\npasswd： 所有的身份验证令牌已经成功更新。\n\n[root@abao ~]# useradd admin  #客户端上建立ssh账号\n\n[root@abao ~]# passwd admin\n\n更改用户 admin 的密码 。\n\n新的 密码：\n\n重新输入新的 密码：\n\npasswd： 所有的身份验证令牌已经成功更新。\n</code></pre><p>2、客户端建立两把钥匙</p>\n<pre><code>[root@abao ~]# su – admin\n\n[admin@abao ~]$ ssh-keygen\n\nGenerating public/private rsa key pair.\n\nEnter file in which to save the key (/home/admin/.ssh/id_rsa):\n\nCreated directory ‘/home/admin/.ssh’.\n\nEnter passphrase (empty for no passphrase):\n\nEnter same passphrase again:\n\nYour identification has been saved in /home/admin/.ssh/id_rsa.\n\nYour public key has been saved in /home/admin/.ssh/id_rsa.pub.\n\nThe key fingerprint is:\n\n61:01:c2:9b:26:00:0a:01:c9:a0:58:7e:38:f9:85:6c admin@abao\n\nThe key’s randomart image is:\n\n+–[ RSA 2048]—-+\n\n|@o… …|\n\n|B+ +.o   .   |\n\n|+.= Eo. o|\n\n|  .=+. . .   |\n\n|   o.   S   |\n\n| |\n\n| |\n\n| |\n\n| |\n\n+—————–+\n\n[admin@abao ~]$ ls -ld ~/.ssh; ls -l ~/.ssh\n\ndrwx——. 2 admin admin 4096 10月 10 09:21 /home/admin/.ssh\n\n总用量 8\n\n-rw——-. 1 admin admin 1675 10月 10 09:21 id_rsa\n\n-rw-r–r–. 1 admin admin 392 10月 10 09:21 id_rsa.pub\n</code></pre><p>3、将公钥文件数据上传到服务器</p>\n<pre><code>[admin@abao ~]$ scp ~/.ssh/id_rsa.pub admin@172.168.72.68:~#客户端上传公钥文件\n\nadmin@172.168.72.68’s password:\n\nid_rsa.pub100%  3920.4KB/s   00:00\n</code></pre><p>4、将公钥放置到服务器端的正确目录与文件名（服务器上操作）</p>\n<pre><code>[root@baobao ~]# su – admin\n\n[admin@baobao ~]$ ls -ld .ssh\n\nls: 无法访问.ssh: 没有那个文件或目录\n\n[admin@baobao ~]$ mkdir .ssh; chmod 700 .ssh #服务器上建立文件~/.ssh\n\n[admin@baobao ~]$ ls -ld .ssh\n\ndrwx—— 2 admin admin 4096 10月 10 09:36 .ssh\n\n[admin@baobao ~]$ ls -l *pub\n\n-rw-r–r– 1 admin admin 392 10月 10 09:27 id_rsa.pub\n\n[admin@baobao ~]$ cat id_rsa.pub &gt;&gt; .ssh/authorized_keys\n\n[admin@baobao ~]$ chmod 644 .ssh/authorized_keys\n\n[admin@baobao ~]$ ls -l .ssh\n\n总用量 4\n\n-rw-r–r– 1 admin admin 392 10月 10 09:38 authorized_keys\n</code></pre><p>5、在客户端建立异地备份脚本</p>\n<pre><code>[root@abao ~]# mkdir /backups\n\n[root@abao ~]# chmod -R 755 /backups/\n\n[root@abao ~]# su – admin\n\n[admin@abao ~]$ mkdir ~/bin; vim ~/bin/backup.sh\n\n#!/bin/bash\n\nlocaldir=/backups\n\nremotedir=/home/back/\n\nremoteip=”172.168.72.68″\n\n[ -d ${localdir} ] || mkdir ${localdir}   #-d是判断是否有这个目录；符号“||”是逻辑或意思，左边为假时执行右边命令；小括号一般用作执行命令，而自定义变量一般用大括号括起来\n\nfor dir in ${remotedir}\n\ndo\n\nrsync -av -essh admin@${remoteip}:${dir} ${localdir}\n\ndone\n\n[admin@abao ~]$ chmod 755 ~/bin/backup.sh\n\n[admin@abao ~]$ ls -ld /home/admin/bin/backup.sh\n\n-rwxrwxr-x. 1 admin admin 224 10月 11 08:49 /home/admin/bin/backup.sh\n\n[admin@abao ~]$ ~/bin/backup.sh   #执行脚本\n\nreceiving incremental filelist\n\nsent 11 bytes  received 43 bytes  5.68 bytes/sec\n\ntotal size is 1010  speedup is 18.70\n</code></pre><p>6、制作crontab计划任务</p>\n<pre><code>[root@abao ~]# crontab –e #每天的凌晨02:00异地备份服务器上的/etc /root /home目录到本地的/backups/下\n0 2 * * * /home/admin/bin/backup.sh\n</code></pre><p>六、直接通过rsync的服务来传输实例</p>\n<p>l  创建用户账号和rsync配置文件</p>\n<pre><code>[root@baobao ~]# useraddadmin   #创建链接用户\n\n[root@baobao ~]# passwd admin\n\n更改用户 admin 的密码。\n\n新的 密码：\n\n重新输入新的 密码：\n\npasswd： 所有的身份验证令牌已经成功更新。\n\n[root@baobao ~]# mkdir /home/back   #创建要进行备份的目录或文件\n\n[root@baobao ~]# touch/home/back/guo\n\n[root@baobao ~]# vim/home/back/guo\n\n[root@baobao ~]# chmod -R 755/home/back/#设定要备份的目录或文件权限\n\n[root@baobao ~]# yum -yinstall xinetd\n\n[root@baobao ~]# yum -yinstall rsync#安装rsync\n\n[root@baobao ~]# yum -yinstall rsync#客户端也安装rsync\n\n[root@baobao ~]# touch/etc/rsyncd.conf  #默认该文件是没有的\n\n[root@baobao ~]# chmod 600/etc/rsyncd.conf  #修改配置文件权限\n</code></pre><p>l  Rsync服务器端配置文件设置</p>\n<p>配置文件时即时生效的，不用重启服务</p>\n<p>1、/etc/rsyncd.conf配置</p>\n<p>1)  全局参数配置</p>\n<pre><code>[root@baobao ~]# manrsyncd.conf   #查看说明文档看下面部分参数是yes/no还是true/false\n\n[root@baobao ~]# vim/etc/rsyncd.conf\n\nuid=root  #运行RSYNC守护进程的用户\n\ngid=root  #运行RSYNC守护进程的组\n\nuse chroot=false  #不使用chroot\n\nmax connections=8 #最大连接数是4\n\npid file=/var/run/rsyncd.pid  #pid文件默认存放位置\n\nlock file=/var/run/rsync.lock #锁文件默认存放位置（锁住rsync正在操作的文件不让其他的程序对其进行写操作）\n\nlog file=/var/log/rsyncd.log  #日志文件默认存放位置\n\nstrict modes=true #是否检查口令文件的权限\nport=873  #默认端口873\n</code></pre><p>2)  模块参数配置(多台客户端需要设置多个模块)</p>\n<pre><code>[backup]   #认证的模块名，在client端需要指定\n\npath=/etc  #需要做备份的目录\n\ncomment=This is backup #这个模块的注释信息\n\nlist=true  #当用户查询该服务器上的可用模块时，该模块是被列出（true）还是被隐藏（false）\n\nmax connections=6  #客户端最大连接数(默认0没限制)，模块里可以不设置\nignore errors  #可以忽略一些无关的IO错误\nread only=false#“yes”只读客户端不能上传；“no”客户端可以上传\nwrite only=false   #“yes”客户端不能下载；“no”客户端可以下载\n\nuid=root   #指定该模块传输文件时守护进程应该具有的uid\ngid=root   #指定该模块传输文件时守护进程应该具有的gid\nhosts allow=172.168.0.0/16 #允许连接的主机（“*”充许任何主机连接），多个主机用“，”分开；多个网段用空格隔开\nhosts deny=192.168.10.0/32 #禁止连接的主机或网段\n\nauth users=admin   #登陆系统使用的用户名（系统必须存在的用户），没有默认为匿名\nsecrets file= /etc/rsyncd.secrets #登陆用户的密码文件（需要自己生成）\n</code></pre><p>2、rsync server启动文件配置</p>\n<pre><code>[root@baobao ~]# vim /etc/xinetd.d/rsync#只修改disable = no即可\n\n# default: off\n\n# description: The rsyncserver is a good addition to an ftp server, as it \\\n\n#   allows crc checksumming etc.\n\nservice rsync\n\n{\n\ndisable = no\n\nflags   = IPv6\n\nsocket_type = stream\n\nwait= no\n\nuser= root\n\nserver  = /usr/bin/rsync\n\nserver_args = –daemon\n\nlog_on_failure  += USERID\n\n}\n\n[root@baobao ~]# chkconfigrsync on\n</code></pre><p>l  创建密码文件、欢迎信息</p>\n<p>1、生成rsync密码文件并设置该文件相应权限<br>    [root@baobao ~]# touch /etc/rsyncd.secrets</p>\n<pre><code>[root@baobao ~]# vim /etc/rsyncd.secrets\n\nadmin:guobaobao!1314#格式为“账号：密码”且一行一个\n[root@baobao ~]# chown root.root /etc/rsyncd.secrets\n\n[root@baobao ~]# chmod 600 /etc/rsyncd.secrets\n\n因为rsyncd.secrets存储了rsync服务的用户名和密码，所以要将rsyncd.secrets设置为root拥有, 且权限为600\n</code></pre><p>2、配置欢迎信息rsyncd.motd（可有可无）<br>    [root@baobao ~]# vim /etc/rsyncd.motd   #rsyncd.motd记录了rsync服务的欢迎信息</p>\n<pre><code>Welcome to use the rsyncservices!\n[root@baobao ~]# service xinetd restart\n\n停止 xinetd：  [确定]\n\n正在启动 xinetd：  [确定]\n</code></pre><p>l  Rsync的启动与开机启动</p>\n<p>1、Rsync服务端启动</p>\n<p>1)  载入配置</p>\n<pre><code>[root@baobao ~]# rsync –daemon–config=/etc/rsyncd.conf   #载入配置并启动\n\n或\n\n[root@baobao ~]# /etc/rc.d/init.d/xinetdreload\n\n重新载入配置： [确定]\n</code></pre><p>2)  重启rsync</p>\n<pre><code>[root@baobao ~]# /usr/bin/rsync –daemon\n\nfailed to create pid file/var/run/rsyncd.pid: File exists\n\n或\n\n[root@baobao ~]# /etc/rc.d/init.d/xinetdrestart#重新启动\n\n停止 xinetd：  [确定]\n\n正在启动 xinetd：  [确定]\n</code></pre><p>3)  检查rsync是否启动</p>\n<pre><code>[root@baobao ~]# netstat -lnp | grep 873#由超级进程启动\n\ntcp   0  0 0.0.0.0:8730.0.0.0:*LISTEN  3133/rsync\n\ntcp   0  0 :::873 :::*LISTEN 3133/rsync\n\n或\n\n[root@baobao ~]# netstat -a |grep rsync\n\ntcp0  0*:rsync *:* LISTEN\n\n或\n\n[root@baobao ~]# lsof -i:873 #端口没有被占用\n\nCOMMAND  PID USER  FD   TYPE DEVICE SIZE/OFF NODENAME\n\nrsync   3133 root   4u  IPv4  22973 0t0  TCP *:rsync (LISTEN)\n\nrsync   3133 root   5u  IPv6  22974 0t0  TCP *:rsync (LISTEN)\n</code></pre><p>4)  查看rsync日志</p>\n<pre><code>[root@baobao ~]# cat /var/log/rsyncd.log #查看rsync日志\n\n2014/10/14 15:29:13 [35681] rsyncdversion 3.0.6 starting, listening on port 873\n</code></pre><p>2、将rsync加入开机启动</p>\n<pre><code>[root@baobao ~]# echo”/usr/bin/rsync –daemon –config=/etc/rsyncd.conf”&gt;&gt;/etc/rc.local\n\n[root@baobao ~]# cat/etc/rc.local\n\n#!/bin/sh\n\n#\n\n# This script will beexecuted *after* all the other init scripts.\n\n# You can put your owninitialization stuff in here if you don’t\n\n# want to do the full Sys Vstyle init stuff.\n\ntouch /var/lock/subsys/local\n\n/usr/bin/rsync –daemon–config=/etc/rsyncd.conf\n</code></pre><p>l  Rsync服务器端配置防火墙</p>\n<p>1、防火墙设置</p>\n<pre><code>[root@baobao ~]# iptables -F\n\n[root@baobao ~]# iptables -X\n\n[root@baobao ~]# iptables -Z\n\n[root@baobao ~]# iptables -AINPUT -i eth0 -s 172.168.0.0/16 -p tcp –dport 22 -j ACCEPT\n\n[root@baobao ~]# iptables -L\n\nChain INPUT (policy ACCEPT)\n\ntarget prot opt source   destination\n\nACCEPT tcp —  ACA80000.ipt.aol.com/16  anywheretcp dpt:ssh\n\nChain FORWARD (policy ACCEPT)\n\ntarget prot opt source   destination\n\nChain OUTPUT (policy ACCEPT)\n\ntarget prot opt source   destination\n\n[root@baobao ~]#/etc/init.d/iptables save\n\niptables：将防火墙规则保存到 /etc/sysconfig/iptables： [确定]\n\n[root@baobao ~]#/etc/init.d/iptables restart\n\niptables：清除防火墙规则：[确定]\n\niptables：将链设置为政策 ACCEPT：filter[确定]\n\niptables：正在卸载模块：  [确定]\n\niptables：应用防火墙规则：[确定]\n</code></pre><p>2、selinux设置</p>\n<pre><code>[root@baobao ~]# setenforce 0\n</code></pre><p>l  客户端测试</p>\n<pre><code>[root@abao ~]# rsync -avadmin@172.168.72.68::backup /backups/\n\nPassword:\n\nreceiving incremental filelist\n\ncreated directory /backups\n\n./\n\nguo\n\nsent 79 bytes  received 1162 bytes  275.78 bytes/sec\n\ntotal size is 1010  speedup is 0.81\n</code></pre><p>可以看到这里还是需要输入密码，这样同样也不能写入脚本中自动执行</p>\n<p>l  常见问题处理</p>\n<p>1、错误一</p>\n<p>@ERROR: chroot failed</p>\n<p>rsync error: error startingclient-server protocol (code 5) at main.c(1522) [receiver=3.0.3]</p>\n<p>原因：服务器端的目录不存在或无权限</p>\n<p>2、错误二</p>\n<p>@ERROR: auth failed on moduletee</p>\n<p>rsync error: error startingclient-server protocol (code 5) at main.c(1522) [receiver=3.0.3]</p>\n<p>原因：服务器端该模块（tee）需要验证用户名密码，但客户端没有提供正确的用户名密码，认证失败。</p>\n<p>3、错误三</p>\n<p>@ERROR: Unknown module‘tee_nonexists’</p>\n<p>rsync error: error startingclient-server protocol (code 5) at main.c(1522) [receiver=3.0.3]</p>\n<p>原因：服务器不存在指定模块</p>\n<p>4、错误四</p>\n<p>password file must not beother-accessible</p>\n<p>continuing without passwordfile</p>\n<p>Password:</p>\n<p>原因：这是因为rsyncd.pwdrsyncd.secrets的权限不对，应该设置为600</p>\n<p>5、错误五</p>\n<p>rsync: failed to connect to218.107.243.2: No route to host (113)</p>\n<p>rsync error: error in socketIO (code 10) at clientserver.c(104) [receiver=2.6.9]</p>\n<p>原因：对方没开机、防火墙阻挡、通过的网络上有防火墙阻挡，都有可能</p>\n<p>6、错误六</p>\n<p>rsync error: error startingclient-server protocol (code 5) at main.c(1524) [Receiver=3.0.7]</p>\n<p>原因：/etc/rsyncd.conf配置文件内容有错误</p>\n<p>7、错误七</p>\n<p>rsync: chown “”failed: Invalid argument (22)</p>\n<p>原因：权限无法复制，去掉同步权限的参数即可(这种情况多见于Linux向Windows的时候)</p>\n<p>8、错误八</p>\n<p>@ERROR: daemon security issue– contact admin<br>rsync error: error starting client-server protocol (code 5) at main.c(1530)[sender=3.0.6]</p>\n<p>原因：同步的目录里面有软连接文件，需要服务器端的/etc/rsyncd.conf打开use chroot = yes掠过软连接文件。</p>\n<p>l  建立不需输入密码的链接</p>\n<p>这样就可以将其写入脚本和任务计划自动运行了</p>\n<p>1、第一种方案：指定密码文件</p>\n<pre><code>[root@abao ~]# touch/etc/pass#客户端上建立密码文件\n\n[root@abao ~]# vim /etc/pass #将账户“admin”密码写入\n\n[root@abao ~]# cat /etc/pass\n\nguobaobao！1314\n\n[root@abao ~]# chmod 600/etc/pass\n\n[root@abao ~]# rsync -avadmin@172.168.72.68::backup /backups/\n\nPassword:\n\n@ERROR: auth failed on modulebackup\n\nrsync error: error startingclient-server protocol (code 5) at main.c(1503) [receiver=3.0.6]\n\n[root@abao ~]#\n\n[root@abao ~]# rsync -avadmin@172.168.72.68::backup /backups/ –password-file=/etc/pass #注意黑体部分指定密码文件\n\nreceiving incremental filelist\n\nsent 57 bytes  received 106 bytes  326.00 bytes/sec\n\ntotal size is 1010  speedup is 6.20\n</code></pre><p>2、第二种方案：在rsync服务器端不指定用户</p>\n<pre><code>[root@baobao ~]# vim/etc/rsyncd.conf   #服务器端配置文件注释掉下面认证两行\n\n#auth users=admin\n\n#secretsfile=/etc/rsyncd.secrets\n\n[root@abao ~]# rsync -avadmin@172.168.72.68::backup /backups/\n\nreceiving incremental filelist\n\nsent 28 bytes  received 65 bytes  37.20 bytes/sec\n\ntotal size is 1010  speedup is 10.86\n\n或\n\n[root@abao ~]# rsync -av172.168.72.68::backup /backups/#不加账户默认是root\n\nreceiving incremental filelist\n\nsent 28 bytes  received 65 bytes  186.00 bytes/sec\n\ntotal size is 1010  speedup is 10.86\n</code></pre>","excerpt":"<p>一、Rsync软件介绍</p>\n<p>rsync从字面上的意思就是remote sync （远程同步）的意思，是类unix系统下的远程数据镜像备份工具，可以镜像保存整个目录树和文件系统，并保持原来文件的权限、时间、软硬链接等，此外它还支持匿名传输；Rsync不仅可以远程同步数据（类似于scp）还可以本地同步数据（类似于cp），但不同于cp或scp的是rsync不像cp/scp一样会覆盖以前的数据，Rsync使用所谓的“Rsync演算法”，这个算法在第一次连通完成时，会把整份文件传输一次，下一次就只传送二个文件之间不同的部份，因此速度相当快<br>","more":"<br>二、Rsync的传输方式（或工作模式）</p>\n<p>l  在本机直接运行拷贝本地文件（不使用冒号）</p>\n<p>命令格式为：rsync[OPTION]… SRC DEST。如下</p>\n<pre><code>[root@abao~]# rsync -av /etc /tmp\n</code></pre><p>l  通过rsh或ssh的信道在server/client之间进行传输数据（使用一个冒号）</p>\n<p>需要登录到服务器上执行任务，并且需要输入账号的密码</p>\n<p>1、 将本地机器的内容拷贝到远程机器（目标路径中使用一个冒号）</p>\n<p>命令格式为：rsync[OPTION]… SRC [USER@]HOST:DEST。如下</p>\n<pre><code>[root@abao~]# rsync -av -e ssh /tmp axing@172.168.72.68:~\n</code></pre><p>2、 将远程机器的内容拷贝到本地机器（源路径中使用一个冒号）</p>\n<p>命令格式为：rsync[OPTION]… [USER@]HOST:SRC DEST。如下</p>\n<pre><code>[root@abao~]# rsync -av -e ssh axing@172.168.72.68:~ /tmp\n</code></pre><p>l  直接通过rsync的服务来传输（此时服务器端需要启动873端口，并且使用两个冒号）</p>\n<p>这种方式在远程主机上建立一个rsync的服务器，在服务器上配置好rsync的各种应用，然后本机作为rsync的一个客户端去连接远程的rsync服务器</p>\n<p>1、 从远程rsync服务器中拷贝文件到本地机（源路径中使用一个冒号）</p>\n<p>命令格式为：rsync[OPTION]… [USER@]HOST::模块名 本地位置。如下</p>\n<pre><code>[root@abao~]# rsync -av axing@172.168.72.68:：back /databack\n</code></pre><p>2、从本地机器拷贝文件到远程rsync服务器中（目标路径中使用一个冒号）</p>\n<p>命令格式为：rsync[OPTION]… SRC [USER@]HOST::DEST。如下</p>\n<pre><code>[root@abao~]# rsync -av /databack axing@172.168.72.68:：back\n</code></pre><p>以上3中传输方式的差异在于有没有冒号“：”，本地端传输不需要冒号，通过rsh或ssh传输时需要一个冒号，而通过rsync传输时需要两个冒号</p>\n<p>三、Rsync的语法</p>\n<pre><code>-v： 查看模式可以列出很多信息包括文件名\n\n-r： 递归复制，可以针对目录来复制\n\n-u： 仅更新，如果目标文件比较新那么则保留新文件不会覆盖\n\n-l： 复制链接文件的属性\n\n-p： 连同属性一起复制\n\n-g： 保存源文件的属组\n\n-o： 保存源文件的属主\n\n-D： 保存源文件的设备属性\n\n-t： 保存原文件的时间参数\n\n-z： 在传输时加上压缩\n\n-e： 使用的协议，例如使用ssh通道就是-e ssh\n\n-a： 相当于-rlptgoD，是最常用的参数\n\n-L： 把SRC中软连接的目标文件给拷贝到DST.\n\n–delete：如果在DST增加文件了，而SRC当中没有这些文件，同步时会删除新增的文件\n\n–exclude=filename：  指定排除不需要传输的文件，等号后面跟文件名（如*.txt）\n\n–progress：  可以看到同步的过程状态，比如文件数量、文件传输速度等\n</code></pre><p>四、在本机直接运行拷贝本地文件实例</p>\n<pre><code>[root@abao ~]# rsync -av /etc/tmp#首次本地备份\n\n…………………………………………………………………\n\nsent 33899909 bytes  received 35626 bytes  5220851.54 bytes/sec\n\ntotal size is 33759697  speedup is 0.99\n\n[root@abao ~]# ll -d /tmp/etc/etc#两文件相同\n\ndrwxr-xr-x. 126 root root12288 10月 10 08:23 /etc\n\ndrwxr-xr-x. 126 root root12288 10月 10 08:23 /tmp/etc\n\n[root@abao ~]# rsync -av /etc/tmp#再次备份时只备份差异文件\n\nsending incremental file list\n\nsent 77528 bytes  received 293 bytes  155642.00 bytes/sec\n\ntotal size is 33759697  speedup is 433.81\n</code></pre><p>五、通过rsh或ssh的信道在server/client之间进行传输数据实例</p>\n<pre><code>[root@abao ~]# /etc/init.d/sshd restart\n\n停止 sshd：[确定]\n\n正在启动 sshd：[确定]\n</code></pre><p>l  将本地机器的内容拷贝到远程机器</p>\n<pre><code>[root@abao ~]# rsync -av -e ssh /tmp admin@172.168.72.68:~\n\nadmin@172.168.72.68’s password:   #需要输入账户密码\n\n…………………………………………………………………………\n\nsent 238637037 bytes received 60045 bytes  3819153.31bytes/sec\n\ntotal size is 238396030 speedup is 1.00\n</code></pre><p>l  将远程机器的内容拷贝到本地机器</p>\n<pre><code>[root@abao ~]# rsync -av -e ssh axing@172.168.72.68:~ /tmp\n\naxing@172.168.72.68’s password:   #需要输入账户密码\n\nreceiving incremental file list\n\naxing/\n\naxing/.ICEauthority\n\n…………………………………………………………………\n\nsent 1732 bytes  received758924 bytes  80069.05 bytes/sec\n\ntotal size is 751474 speedup is 0.99\n\n[root@abao ~]# ll -d /tmp/axing\n\ndrwx——. 27 500 500 4096 10月 10 08:23 /tmp/axing\n</code></pre><p>l  利用crontab通过ssh进行免密码异地备份脚本（常用）</p>\n<p>我们可以针对用户admin制作一个免密码登陆的ssh秘钥，这样以后异地备份系统就可以使用crontab自动备份了，前提是先根据下面（六、直接通过rsync的服务来传输实例）安装并设置好rsync</p>\n<p>1、ssh服务器端和客户端账户建立</p>\n<pre><code>[root@baobao ~]# mkdir /home/back; touch /home/back/wo#创建要备份的文件\n\n[root@baobao ~]# chmod -R 755 /home/back/\n\n[root@baobao ~]# useradd admin#先在ssh服务器端ssh账号\n\n[root@baobao ~]# passwd admin\n\n更改用户 admin 的密码 。\n\n新的 密码：\n\n重新输入新的 密码：\n\npasswd： 所有的身份验证令牌已经成功更新。\n\n[root@abao ~]# useradd admin  #客户端上建立ssh账号\n\n[root@abao ~]# passwd admin\n\n更改用户 admin 的密码 。\n\n新的 密码：\n\n重新输入新的 密码：\n\npasswd： 所有的身份验证令牌已经成功更新。\n</code></pre><p>2、客户端建立两把钥匙</p>\n<pre><code>[root@abao ~]# su – admin\n\n[admin@abao ~]$ ssh-keygen\n\nGenerating public/private rsa key pair.\n\nEnter file in which to save the key (/home/admin/.ssh/id_rsa):\n\nCreated directory ‘/home/admin/.ssh’.\n\nEnter passphrase (empty for no passphrase):\n\nEnter same passphrase again:\n\nYour identification has been saved in /home/admin/.ssh/id_rsa.\n\nYour public key has been saved in /home/admin/.ssh/id_rsa.pub.\n\nThe key fingerprint is:\n\n61:01:c2:9b:26:00:0a:01:c9:a0:58:7e:38:f9:85:6c admin@abao\n\nThe key’s randomart image is:\n\n+–[ RSA 2048]—-+\n\n|@o… …|\n\n|B+ +.o   .   |\n\n|+.= Eo. o|\n\n|  .=+. . .   |\n\n|   o.   S   |\n\n| |\n\n| |\n\n| |\n\n| |\n\n+—————–+\n\n[admin@abao ~]$ ls -ld ~/.ssh; ls -l ~/.ssh\n\ndrwx——. 2 admin admin 4096 10月 10 09:21 /home/admin/.ssh\n\n总用量 8\n\n-rw——-. 1 admin admin 1675 10月 10 09:21 id_rsa\n\n-rw-r–r–. 1 admin admin 392 10月 10 09:21 id_rsa.pub\n</code></pre><p>3、将公钥文件数据上传到服务器</p>\n<pre><code>[admin@abao ~]$ scp ~/.ssh/id_rsa.pub admin@172.168.72.68:~#客户端上传公钥文件\n\nadmin@172.168.72.68’s password:\n\nid_rsa.pub100%  3920.4KB/s   00:00\n</code></pre><p>4、将公钥放置到服务器端的正确目录与文件名（服务器上操作）</p>\n<pre><code>[root@baobao ~]# su – admin\n\n[admin@baobao ~]$ ls -ld .ssh\n\nls: 无法访问.ssh: 没有那个文件或目录\n\n[admin@baobao ~]$ mkdir .ssh; chmod 700 .ssh #服务器上建立文件~/.ssh\n\n[admin@baobao ~]$ ls -ld .ssh\n\ndrwx—— 2 admin admin 4096 10月 10 09:36 .ssh\n\n[admin@baobao ~]$ ls -l *pub\n\n-rw-r–r– 1 admin admin 392 10月 10 09:27 id_rsa.pub\n\n[admin@baobao ~]$ cat id_rsa.pub &gt;&gt; .ssh/authorized_keys\n\n[admin@baobao ~]$ chmod 644 .ssh/authorized_keys\n\n[admin@baobao ~]$ ls -l .ssh\n\n总用量 4\n\n-rw-r–r– 1 admin admin 392 10月 10 09:38 authorized_keys\n</code></pre><p>5、在客户端建立异地备份脚本</p>\n<pre><code>[root@abao ~]# mkdir /backups\n\n[root@abao ~]# chmod -R 755 /backups/\n\n[root@abao ~]# su – admin\n\n[admin@abao ~]$ mkdir ~/bin; vim ~/bin/backup.sh\n\n#!/bin/bash\n\nlocaldir=/backups\n\nremotedir=/home/back/\n\nremoteip=”172.168.72.68″\n\n[ -d ${localdir} ] || mkdir ${localdir}   #-d是判断是否有这个目录；符号“||”是逻辑或意思，左边为假时执行右边命令；小括号一般用作执行命令，而自定义变量一般用大括号括起来\n\nfor dir in ${remotedir}\n\ndo\n\nrsync -av -essh admin@${remoteip}:${dir} ${localdir}\n\ndone\n\n[admin@abao ~]$ chmod 755 ~/bin/backup.sh\n\n[admin@abao ~]$ ls -ld /home/admin/bin/backup.sh\n\n-rwxrwxr-x. 1 admin admin 224 10月 11 08:49 /home/admin/bin/backup.sh\n\n[admin@abao ~]$ ~/bin/backup.sh   #执行脚本\n\nreceiving incremental filelist\n\nsent 11 bytes  received 43 bytes  5.68 bytes/sec\n\ntotal size is 1010  speedup is 18.70\n</code></pre><p>6、制作crontab计划任务</p>\n<pre><code>[root@abao ~]# crontab –e #每天的凌晨02:00异地备份服务器上的/etc /root /home目录到本地的/backups/下\n0 2 * * * /home/admin/bin/backup.sh\n</code></pre><p>六、直接通过rsync的服务来传输实例</p>\n<p>l  创建用户账号和rsync配置文件</p>\n<pre><code>[root@baobao ~]# useraddadmin   #创建链接用户\n\n[root@baobao ~]# passwd admin\n\n更改用户 admin 的密码。\n\n新的 密码：\n\n重新输入新的 密码：\n\npasswd： 所有的身份验证令牌已经成功更新。\n\n[root@baobao ~]# mkdir /home/back   #创建要进行备份的目录或文件\n\n[root@baobao ~]# touch/home/back/guo\n\n[root@baobao ~]# vim/home/back/guo\n\n[root@baobao ~]# chmod -R 755/home/back/#设定要备份的目录或文件权限\n\n[root@baobao ~]# yum -yinstall xinetd\n\n[root@baobao ~]# yum -yinstall rsync#安装rsync\n\n[root@baobao ~]# yum -yinstall rsync#客户端也安装rsync\n\n[root@baobao ~]# touch/etc/rsyncd.conf  #默认该文件是没有的\n\n[root@baobao ~]# chmod 600/etc/rsyncd.conf  #修改配置文件权限\n</code></pre><p>l  Rsync服务器端配置文件设置</p>\n<p>配置文件时即时生效的，不用重启服务</p>\n<p>1、/etc/rsyncd.conf配置</p>\n<p>1)  全局参数配置</p>\n<pre><code>[root@baobao ~]# manrsyncd.conf   #查看说明文档看下面部分参数是yes/no还是true/false\n\n[root@baobao ~]# vim/etc/rsyncd.conf\n\nuid=root  #运行RSYNC守护进程的用户\n\ngid=root  #运行RSYNC守护进程的组\n\nuse chroot=false  #不使用chroot\n\nmax connections=8 #最大连接数是4\n\npid file=/var/run/rsyncd.pid  #pid文件默认存放位置\n\nlock file=/var/run/rsync.lock #锁文件默认存放位置（锁住rsync正在操作的文件不让其他的程序对其进行写操作）\n\nlog file=/var/log/rsyncd.log  #日志文件默认存放位置\n\nstrict modes=true #是否检查口令文件的权限\nport=873  #默认端口873\n</code></pre><p>2)  模块参数配置(多台客户端需要设置多个模块)</p>\n<pre><code>[backup]   #认证的模块名，在client端需要指定\n\npath=/etc  #需要做备份的目录\n\ncomment=This is backup #这个模块的注释信息\n\nlist=true  #当用户查询该服务器上的可用模块时，该模块是被列出（true）还是被隐藏（false）\n\nmax connections=6  #客户端最大连接数(默认0没限制)，模块里可以不设置\nignore errors  #可以忽略一些无关的IO错误\nread only=false#“yes”只读客户端不能上传；“no”客户端可以上传\nwrite only=false   #“yes”客户端不能下载；“no”客户端可以下载\n\nuid=root   #指定该模块传输文件时守护进程应该具有的uid\ngid=root   #指定该模块传输文件时守护进程应该具有的gid\nhosts allow=172.168.0.0/16 #允许连接的主机（“*”充许任何主机连接），多个主机用“，”分开；多个网段用空格隔开\nhosts deny=192.168.10.0/32 #禁止连接的主机或网段\n\nauth users=admin   #登陆系统使用的用户名（系统必须存在的用户），没有默认为匿名\nsecrets file= /etc/rsyncd.secrets #登陆用户的密码文件（需要自己生成）\n</code></pre><p>2、rsync server启动文件配置</p>\n<pre><code>[root@baobao ~]# vim /etc/xinetd.d/rsync#只修改disable = no即可\n\n# default: off\n\n# description: The rsyncserver is a good addition to an ftp server, as it \\\n\n#   allows crc checksumming etc.\n\nservice rsync\n\n{\n\ndisable = no\n\nflags   = IPv6\n\nsocket_type = stream\n\nwait= no\n\nuser= root\n\nserver  = /usr/bin/rsync\n\nserver_args = –daemon\n\nlog_on_failure  += USERID\n\n}\n\n[root@baobao ~]# chkconfigrsync on\n</code></pre><p>l  创建密码文件、欢迎信息</p>\n<p>1、生成rsync密码文件并设置该文件相应权限<br>    [root@baobao ~]# touch /etc/rsyncd.secrets</p>\n<pre><code>[root@baobao ~]# vim /etc/rsyncd.secrets\n\nadmin:guobaobao!1314#格式为“账号：密码”且一行一个\n[root@baobao ~]# chown root.root /etc/rsyncd.secrets\n\n[root@baobao ~]# chmod 600 /etc/rsyncd.secrets\n\n因为rsyncd.secrets存储了rsync服务的用户名和密码，所以要将rsyncd.secrets设置为root拥有, 且权限为600\n</code></pre><p>2、配置欢迎信息rsyncd.motd（可有可无）<br>    [root@baobao ~]# vim /etc/rsyncd.motd   #rsyncd.motd记录了rsync服务的欢迎信息</p>\n<pre><code>Welcome to use the rsyncservices!\n[root@baobao ~]# service xinetd restart\n\n停止 xinetd：  [确定]\n\n正在启动 xinetd：  [确定]\n</code></pre><p>l  Rsync的启动与开机启动</p>\n<p>1、Rsync服务端启动</p>\n<p>1)  载入配置</p>\n<pre><code>[root@baobao ~]# rsync –daemon–config=/etc/rsyncd.conf   #载入配置并启动\n\n或\n\n[root@baobao ~]# /etc/rc.d/init.d/xinetdreload\n\n重新载入配置： [确定]\n</code></pre><p>2)  重启rsync</p>\n<pre><code>[root@baobao ~]# /usr/bin/rsync –daemon\n\nfailed to create pid file/var/run/rsyncd.pid: File exists\n\n或\n\n[root@baobao ~]# /etc/rc.d/init.d/xinetdrestart#重新启动\n\n停止 xinetd：  [确定]\n\n正在启动 xinetd：  [确定]\n</code></pre><p>3)  检查rsync是否启动</p>\n<pre><code>[root@baobao ~]# netstat -lnp | grep 873#由超级进程启动\n\ntcp   0  0 0.0.0.0:8730.0.0.0:*LISTEN  3133/rsync\n\ntcp   0  0 :::873 :::*LISTEN 3133/rsync\n\n或\n\n[root@baobao ~]# netstat -a |grep rsync\n\ntcp0  0*:rsync *:* LISTEN\n\n或\n\n[root@baobao ~]# lsof -i:873 #端口没有被占用\n\nCOMMAND  PID USER  FD   TYPE DEVICE SIZE/OFF NODENAME\n\nrsync   3133 root   4u  IPv4  22973 0t0  TCP *:rsync (LISTEN)\n\nrsync   3133 root   5u  IPv6  22974 0t0  TCP *:rsync (LISTEN)\n</code></pre><p>4)  查看rsync日志</p>\n<pre><code>[root@baobao ~]# cat /var/log/rsyncd.log #查看rsync日志\n\n2014/10/14 15:29:13 [35681] rsyncdversion 3.0.6 starting, listening on port 873\n</code></pre><p>2、将rsync加入开机启动</p>\n<pre><code>[root@baobao ~]# echo”/usr/bin/rsync –daemon –config=/etc/rsyncd.conf”&gt;&gt;/etc/rc.local\n\n[root@baobao ~]# cat/etc/rc.local\n\n#!/bin/sh\n\n#\n\n# This script will beexecuted *after* all the other init scripts.\n\n# You can put your owninitialization stuff in here if you don’t\n\n# want to do the full Sys Vstyle init stuff.\n\ntouch /var/lock/subsys/local\n\n/usr/bin/rsync –daemon–config=/etc/rsyncd.conf\n</code></pre><p>l  Rsync服务器端配置防火墙</p>\n<p>1、防火墙设置</p>\n<pre><code>[root@baobao ~]# iptables -F\n\n[root@baobao ~]# iptables -X\n\n[root@baobao ~]# iptables -Z\n\n[root@baobao ~]# iptables -AINPUT -i eth0 -s 172.168.0.0/16 -p tcp –dport 22 -j ACCEPT\n\n[root@baobao ~]# iptables -L\n\nChain INPUT (policy ACCEPT)\n\ntarget prot opt source   destination\n\nACCEPT tcp —  ACA80000.ipt.aol.com/16  anywheretcp dpt:ssh\n\nChain FORWARD (policy ACCEPT)\n\ntarget prot opt source   destination\n\nChain OUTPUT (policy ACCEPT)\n\ntarget prot opt source   destination\n\n[root@baobao ~]#/etc/init.d/iptables save\n\niptables：将防火墙规则保存到 /etc/sysconfig/iptables： [确定]\n\n[root@baobao ~]#/etc/init.d/iptables restart\n\niptables：清除防火墙规则：[确定]\n\niptables：将链设置为政策 ACCEPT：filter[确定]\n\niptables：正在卸载模块：  [确定]\n\niptables：应用防火墙规则：[确定]\n</code></pre><p>2、selinux设置</p>\n<pre><code>[root@baobao ~]# setenforce 0\n</code></pre><p>l  客户端测试</p>\n<pre><code>[root@abao ~]# rsync -avadmin@172.168.72.68::backup /backups/\n\nPassword:\n\nreceiving incremental filelist\n\ncreated directory /backups\n\n./\n\nguo\n\nsent 79 bytes  received 1162 bytes  275.78 bytes/sec\n\ntotal size is 1010  speedup is 0.81\n</code></pre><p>可以看到这里还是需要输入密码，这样同样也不能写入脚本中自动执行</p>\n<p>l  常见问题处理</p>\n<p>1、错误一</p>\n<p>@ERROR: chroot failed</p>\n<p>rsync error: error startingclient-server protocol (code 5) at main.c(1522) [receiver=3.0.3]</p>\n<p>原因：服务器端的目录不存在或无权限</p>\n<p>2、错误二</p>\n<p>@ERROR: auth failed on moduletee</p>\n<p>rsync error: error startingclient-server protocol (code 5) at main.c(1522) [receiver=3.0.3]</p>\n<p>原因：服务器端该模块（tee）需要验证用户名密码，但客户端没有提供正确的用户名密码，认证失败。</p>\n<p>3、错误三</p>\n<p>@ERROR: Unknown module‘tee_nonexists’</p>\n<p>rsync error: error startingclient-server protocol (code 5) at main.c(1522) [receiver=3.0.3]</p>\n<p>原因：服务器不存在指定模块</p>\n<p>4、错误四</p>\n<p>password file must not beother-accessible</p>\n<p>continuing without passwordfile</p>\n<p>Password:</p>\n<p>原因：这是因为rsyncd.pwdrsyncd.secrets的权限不对，应该设置为600</p>\n<p>5、错误五</p>\n<p>rsync: failed to connect to218.107.243.2: No route to host (113)</p>\n<p>rsync error: error in socketIO (code 10) at clientserver.c(104) [receiver=2.6.9]</p>\n<p>原因：对方没开机、防火墙阻挡、通过的网络上有防火墙阻挡，都有可能</p>\n<p>6、错误六</p>\n<p>rsync error: error startingclient-server protocol (code 5) at main.c(1524) [Receiver=3.0.7]</p>\n<p>原因：/etc/rsyncd.conf配置文件内容有错误</p>\n<p>7、错误七</p>\n<p>rsync: chown “”failed: Invalid argument (22)</p>\n<p>原因：权限无法复制，去掉同步权限的参数即可(这种情况多见于Linux向Windows的时候)</p>\n<p>8、错误八</p>\n<p>@ERROR: daemon security issue– contact admin<br>rsync error: error starting client-server protocol (code 5) at main.c(1530)[sender=3.0.6]</p>\n<p>原因：同步的目录里面有软连接文件，需要服务器端的/etc/rsyncd.conf打开use chroot = yes掠过软连接文件。</p>\n<p>l  建立不需输入密码的链接</p>\n<p>这样就可以将其写入脚本和任务计划自动运行了</p>\n<p>1、第一种方案：指定密码文件</p>\n<pre><code>[root@abao ~]# touch/etc/pass#客户端上建立密码文件\n\n[root@abao ~]# vim /etc/pass #将账户“admin”密码写入\n\n[root@abao ~]# cat /etc/pass\n\nguobaobao！1314\n\n[root@abao ~]# chmod 600/etc/pass\n\n[root@abao ~]# rsync -avadmin@172.168.72.68::backup /backups/\n\nPassword:\n\n@ERROR: auth failed on modulebackup\n\nrsync error: error startingclient-server protocol (code 5) at main.c(1503) [receiver=3.0.6]\n\n[root@abao ~]#\n\n[root@abao ~]# rsync -avadmin@172.168.72.68::backup /backups/ –password-file=/etc/pass #注意黑体部分指定密码文件\n\nreceiving incremental filelist\n\nsent 57 bytes  received 106 bytes  326.00 bytes/sec\n\ntotal size is 1010  speedup is 6.20\n</code></pre><p>2、第二种方案：在rsync服务器端不指定用户</p>\n<pre><code>[root@baobao ~]# vim/etc/rsyncd.conf   #服务器端配置文件注释掉下面认证两行\n\n#auth users=admin\n\n#secretsfile=/etc/rsyncd.secrets\n\n[root@abao ~]# rsync -avadmin@172.168.72.68::backup /backups/\n\nreceiving incremental filelist\n\nsent 28 bytes  received 65 bytes  37.20 bytes/sec\n\ntotal size is 1010  speedup is 10.86\n\n或\n\n[root@abao ~]# rsync -av172.168.72.68::backup /backups/#不加账户默认是root\n\nreceiving incremental filelist\n\nsent 28 bytes  received 65 bytes  186.00 bytes/sec\n\ntotal size is 1010  speedup is 10.86\n</code></pre>"},{"title":"mtr命令详解","date":"2016-11-03T04:00:00.000Z","_content":"一般在windows 来判断网络连通性用ping 和tracert,ping的话可以来判断丢包率，tracert可以用来跟踪路由，在Linux中有一个更好的网络连通性判断工具，它可以结合ping nslookup tracert 来判断网络的相关特性,这个命令就是mtr\n<!--more-->\n[root@10.10.90.97 ~]# mtr -h\nusage: mtr [-hvrctglspni46] [--help] [--version] [--report]\n[--report-cycles=COUNT] [--curses] [--gtk]\n[--raw] [--split] [--no-dns] [--address interface]\n[--psize=bytes/-s bytes]\n[--interval=SECONDS] HOSTNAME [PACKETSIZE]\n\n\nmtr -h 提供帮助命令\nmtr -v 显示mtr的版本信息\nmtr -r 已报告模式显示\n\n[root@10.10.90.97 ~]# mtr -r 202.108.33.94\nFOCUS9097 Snt: 10 Loss% Last Avg Best Wrst StDev\n220.181.61.252 0.0% 6.8 3.3 1.8 7.4 2.2\n220.181.17.217 0.0% 0.4 0.5 0.4 0.7 0.1\n220.181.16.17 0.0% 0.6 0.5 0.5 0.6 0.0\n202.97.53.14 10.0% 0.7 0.7 0.7 0.8 0.0\n219.158.35.1 0.0% 0.8 0.8 0.8 0.9 0.0\n219.158.5.81 0.0% 1.2 1.3 1.2 1.6 0.1\n123.126.0.138 0.0% 1.2 1.1 1.1 1.3 0.1\n61.148.153.126 0.0% 1.9 10.5 1.5 89.9 27.9\n61.148.143.22 0.0% 1.5 1.6 1.5 1.7 0.0\n210.74.178.198 0.0% 1.6 1.6 1.5 1.9 0.1\n202.108.33.94 0.0% 1.5 1.5 1.4 1.5 0.0\n\n\n报告说明：\n第一列:显示的是IP地址和本机域名，这点和tracert很像\n第二列:snt:10 设置每秒发送数据包的数量，默认值是10 可以通过参数 -c来指定。\n\n[root@10.10.90.97 ~]# mtr -r -c 15 202.108.33.94\nFOCUS9097 Snt: 15 Loss% Last Avg Best Wrst StDev\n220.181.61.252 0.0% 1.9 3.4 1.8 12.9 3.1\n220.181.17.217 0.0% 0.5 0.5 0.4 0.8 0.1\n220.181.16.17 0.0% 0.5 0.6 0.5 2.3 0.5\n202.97.53.14 0.0% 0.7 0.7 0.7 0.7 0.0\n219.158.35.1 0.0% 0.9 0.8 0.8 0.9 0.0\n219.158.5.81 0.0% 1.3 2.8 1.2 22.8 5.5\n123.126.0.138 0.0% 1.1 1.1 1.1 1.2 0.0\n61.148.153.126 0.0% 13.8 7.4 1.6 60.4 15.5\n61.148.143.22 0.0% 1.7 1.6 1.5 1.8 0.1\n210.74.178.198 0.0% 1.6 1.6 1.4 1.7 0.1\n202.108.33.94 0.0% 1.5 1.5 1.4 1.7 0.1\n\n\n其中-c的说明是：–report-cycles COUNT\n\n第三列:是显示的每个对应IP的丢包率\n第四列:显示的最近一次的返回时延\n第五列:是平均值 这个应该是发送ping包的平均时延\n第六列:是最好或者说时延最短的\n第七列:是最差或者说时延最常的\n第八列:是标准偏差\n接下来接着说相关参数：\n\nmtr -s 用来指定ping数据包的大小\nmtr -n no-dns不对IP地址做域名解析\nmtr -a 来设置发送数据包的IP地址 这个对一个主机由多个IP地址是有用的\nmtr -i 使用这个参数来设置ICMP返回之间的要求默认是1秒\nmtr -4 IPv4\nmtr -6 IPv6","source":"_posts/mtr命令详解.md","raw":"---\ntitle: mtr命令详解\ndate: 2016-11-03\ntags:\n---\n一般在windows 来判断网络连通性用ping 和tracert,ping的话可以来判断丢包率，tracert可以用来跟踪路由，在Linux中有一个更好的网络连通性判断工具，它可以结合ping nslookup tracert 来判断网络的相关特性,这个命令就是mtr\n<!--more-->\n[root@10.10.90.97 ~]# mtr -h\nusage: mtr [-hvrctglspni46] [--help] [--version] [--report]\n[--report-cycles=COUNT] [--curses] [--gtk]\n[--raw] [--split] [--no-dns] [--address interface]\n[--psize=bytes/-s bytes]\n[--interval=SECONDS] HOSTNAME [PACKETSIZE]\n\n\nmtr -h 提供帮助命令\nmtr -v 显示mtr的版本信息\nmtr -r 已报告模式显示\n\n[root@10.10.90.97 ~]# mtr -r 202.108.33.94\nFOCUS9097 Snt: 10 Loss% Last Avg Best Wrst StDev\n220.181.61.252 0.0% 6.8 3.3 1.8 7.4 2.2\n220.181.17.217 0.0% 0.4 0.5 0.4 0.7 0.1\n220.181.16.17 0.0% 0.6 0.5 0.5 0.6 0.0\n202.97.53.14 10.0% 0.7 0.7 0.7 0.8 0.0\n219.158.35.1 0.0% 0.8 0.8 0.8 0.9 0.0\n219.158.5.81 0.0% 1.2 1.3 1.2 1.6 0.1\n123.126.0.138 0.0% 1.2 1.1 1.1 1.3 0.1\n61.148.153.126 0.0% 1.9 10.5 1.5 89.9 27.9\n61.148.143.22 0.0% 1.5 1.6 1.5 1.7 0.0\n210.74.178.198 0.0% 1.6 1.6 1.5 1.9 0.1\n202.108.33.94 0.0% 1.5 1.5 1.4 1.5 0.0\n\n\n报告说明：\n第一列:显示的是IP地址和本机域名，这点和tracert很像\n第二列:snt:10 设置每秒发送数据包的数量，默认值是10 可以通过参数 -c来指定。\n\n[root@10.10.90.97 ~]# mtr -r -c 15 202.108.33.94\nFOCUS9097 Snt: 15 Loss% Last Avg Best Wrst StDev\n220.181.61.252 0.0% 1.9 3.4 1.8 12.9 3.1\n220.181.17.217 0.0% 0.5 0.5 0.4 0.8 0.1\n220.181.16.17 0.0% 0.5 0.6 0.5 2.3 0.5\n202.97.53.14 0.0% 0.7 0.7 0.7 0.7 0.0\n219.158.35.1 0.0% 0.9 0.8 0.8 0.9 0.0\n219.158.5.81 0.0% 1.3 2.8 1.2 22.8 5.5\n123.126.0.138 0.0% 1.1 1.1 1.1 1.2 0.0\n61.148.153.126 0.0% 13.8 7.4 1.6 60.4 15.5\n61.148.143.22 0.0% 1.7 1.6 1.5 1.8 0.1\n210.74.178.198 0.0% 1.6 1.6 1.4 1.7 0.1\n202.108.33.94 0.0% 1.5 1.5 1.4 1.7 0.1\n\n\n其中-c的说明是：–report-cycles COUNT\n\n第三列:是显示的每个对应IP的丢包率\n第四列:显示的最近一次的返回时延\n第五列:是平均值 这个应该是发送ping包的平均时延\n第六列:是最好或者说时延最短的\n第七列:是最差或者说时延最常的\n第八列:是标准偏差\n接下来接着说相关参数：\n\nmtr -s 用来指定ping数据包的大小\nmtr -n no-dns不对IP地址做域名解析\nmtr -a 来设置发送数据包的IP地址 这个对一个主机由多个IP地址是有用的\nmtr -i 使用这个参数来设置ICMP返回之间的要求默认是1秒\nmtr -4 IPv4\nmtr -6 IPv6","slug":"mtr命令详解","published":1,"updated":"2017-03-01T05:59:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizqklz7w000albpv27vi7ih6","content":"<p>一般在windows 来判断网络连通性用ping 和tracert,ping的话可以来判断丢包率，tracert可以用来跟踪路由，在Linux中有一个更好的网络连通性判断工具，它可以结合ping nslookup tracert 来判断网络的相关特性,这个命令就是mtr<br><a id=\"more\"></a><br>[root@10.10.90.97 ~]# mtr -h<br>usage: mtr [-hvrctglspni46] [–help] [–version] [–report]<br>[–report-cycles=COUNT] [–curses] [–gtk]<br>[–raw] [–split] [–no-dns] [–address interface]<br>[–psize=bytes/-s bytes]<br>[–interval=SECONDS] HOSTNAME [PACKETSIZE]</p>\n<p>mtr -h 提供帮助命令<br>mtr -v 显示mtr的版本信息<br>mtr -r 已报告模式显示</p>\n<p>[root@10.10.90.97 ~]# mtr -r 202.108.33.94<br>FOCUS9097 Snt: 10 Loss% Last Avg Best Wrst StDev<br>220.181.61.252 0.0% 6.8 3.3 1.8 7.4 2.2<br>220.181.17.217 0.0% 0.4 0.5 0.4 0.7 0.1<br>220.181.16.17 0.0% 0.6 0.5 0.5 0.6 0.0<br>202.97.53.14 10.0% 0.7 0.7 0.7 0.8 0.0<br>219.158.35.1 0.0% 0.8 0.8 0.8 0.9 0.0<br>219.158.5.81 0.0% 1.2 1.3 1.2 1.6 0.1<br>123.126.0.138 0.0% 1.2 1.1 1.1 1.3 0.1<br>61.148.153.126 0.0% 1.9 10.5 1.5 89.9 27.9<br>61.148.143.22 0.0% 1.5 1.6 1.5 1.7 0.0<br>210.74.178.198 0.0% 1.6 1.6 1.5 1.9 0.1<br>202.108.33.94 0.0% 1.5 1.5 1.4 1.5 0.0</p>\n<p>报告说明：<br>第一列:显示的是IP地址和本机域名，这点和tracert很像<br>第二列:snt:10 设置每秒发送数据包的数量，默认值是10 可以通过参数 -c来指定。</p>\n<p>[root@10.10.90.97 ~]# mtr -r -c 15 202.108.33.94<br>FOCUS9097 Snt: 15 Loss% Last Avg Best Wrst StDev<br>220.181.61.252 0.0% 1.9 3.4 1.8 12.9 3.1<br>220.181.17.217 0.0% 0.5 0.5 0.4 0.8 0.1<br>220.181.16.17 0.0% 0.5 0.6 0.5 2.3 0.5<br>202.97.53.14 0.0% 0.7 0.7 0.7 0.7 0.0<br>219.158.35.1 0.0% 0.9 0.8 0.8 0.9 0.0<br>219.158.5.81 0.0% 1.3 2.8 1.2 22.8 5.5<br>123.126.0.138 0.0% 1.1 1.1 1.1 1.2 0.0<br>61.148.153.126 0.0% 13.8 7.4 1.6 60.4 15.5<br>61.148.143.22 0.0% 1.7 1.6 1.5 1.8 0.1<br>210.74.178.198 0.0% 1.6 1.6 1.4 1.7 0.1<br>202.108.33.94 0.0% 1.5 1.5 1.4 1.7 0.1</p>\n<p>其中-c的说明是：–report-cycles COUNT</p>\n<p>第三列:是显示的每个对应IP的丢包率<br>第四列:显示的最近一次的返回时延<br>第五列:是平均值 这个应该是发送ping包的平均时延<br>第六列:是最好或者说时延最短的<br>第七列:是最差或者说时延最常的<br>第八列:是标准偏差<br>接下来接着说相关参数：</p>\n<p>mtr -s 用来指定ping数据包的大小<br>mtr -n no-dns不对IP地址做域名解析<br>mtr -a 来设置发送数据包的IP地址 这个对一个主机由多个IP地址是有用的<br>mtr -i 使用这个参数来设置ICMP返回之间的要求默认是1秒<br>mtr -4 IPv4<br>mtr -6 IPv6</p>\n","excerpt":"<p>一般在windows 来判断网络连通性用ping 和tracert,ping的话可以来判断丢包率，tracert可以用来跟踪路由，在Linux中有一个更好的网络连通性判断工具，它可以结合ping nslookup tracert 来判断网络的相关特性,这个命令就是mtr<br>","more":"<br>[root@10.10.90.97 ~]# mtr -h<br>usage: mtr [-hvrctglspni46] [–help] [–version] [–report]<br>[–report-cycles=COUNT] [–curses] [–gtk]<br>[–raw] [–split] [–no-dns] [–address interface]<br>[–psize=bytes/-s bytes]<br>[–interval=SECONDS] HOSTNAME [PACKETSIZE]</p>\n<p>mtr -h 提供帮助命令<br>mtr -v 显示mtr的版本信息<br>mtr -r 已报告模式显示</p>\n<p>[root@10.10.90.97 ~]# mtr -r 202.108.33.94<br>FOCUS9097 Snt: 10 Loss% Last Avg Best Wrst StDev<br>220.181.61.252 0.0% 6.8 3.3 1.8 7.4 2.2<br>220.181.17.217 0.0% 0.4 0.5 0.4 0.7 0.1<br>220.181.16.17 0.0% 0.6 0.5 0.5 0.6 0.0<br>202.97.53.14 10.0% 0.7 0.7 0.7 0.8 0.0<br>219.158.35.1 0.0% 0.8 0.8 0.8 0.9 0.0<br>219.158.5.81 0.0% 1.2 1.3 1.2 1.6 0.1<br>123.126.0.138 0.0% 1.2 1.1 1.1 1.3 0.1<br>61.148.153.126 0.0% 1.9 10.5 1.5 89.9 27.9<br>61.148.143.22 0.0% 1.5 1.6 1.5 1.7 0.0<br>210.74.178.198 0.0% 1.6 1.6 1.5 1.9 0.1<br>202.108.33.94 0.0% 1.5 1.5 1.4 1.5 0.0</p>\n<p>报告说明：<br>第一列:显示的是IP地址和本机域名，这点和tracert很像<br>第二列:snt:10 设置每秒发送数据包的数量，默认值是10 可以通过参数 -c来指定。</p>\n<p>[root@10.10.90.97 ~]# mtr -r -c 15 202.108.33.94<br>FOCUS9097 Snt: 15 Loss% Last Avg Best Wrst StDev<br>220.181.61.252 0.0% 1.9 3.4 1.8 12.9 3.1<br>220.181.17.217 0.0% 0.5 0.5 0.4 0.8 0.1<br>220.181.16.17 0.0% 0.5 0.6 0.5 2.3 0.5<br>202.97.53.14 0.0% 0.7 0.7 0.7 0.7 0.0<br>219.158.35.1 0.0% 0.9 0.8 0.8 0.9 0.0<br>219.158.5.81 0.0% 1.3 2.8 1.2 22.8 5.5<br>123.126.0.138 0.0% 1.1 1.1 1.1 1.2 0.0<br>61.148.153.126 0.0% 13.8 7.4 1.6 60.4 15.5<br>61.148.143.22 0.0% 1.7 1.6 1.5 1.8 0.1<br>210.74.178.198 0.0% 1.6 1.6 1.4 1.7 0.1<br>202.108.33.94 0.0% 1.5 1.5 1.4 1.7 0.1</p>\n<p>其中-c的说明是：–report-cycles COUNT</p>\n<p>第三列:是显示的每个对应IP的丢包率<br>第四列:显示的最近一次的返回时延<br>第五列:是平均值 这个应该是发送ping包的平均时延<br>第六列:是最好或者说时延最短的<br>第七列:是最差或者说时延最常的<br>第八列:是标准偏差<br>接下来接着说相关参数：</p>\n<p>mtr -s 用来指定ping数据包的大小<br>mtr -n no-dns不对IP地址做域名解析<br>mtr -a 来设置发送数据包的IP地址 这个对一个主机由多个IP地址是有用的<br>mtr -i 使用这个参数来设置ICMP返回之间的要求默认是1秒<br>mtr -4 IPv4<br>mtr -6 IPv6</p>"},{"title":"mysql主从配置文件内容","date":"2016-09-05T04:00:00.000Z","_content":"\nmysql简要配置文件---master\n<!--more-->\n    [client]  \n    port = 3306  \n    default-character-set=utf8  \n    [mysqld]  \n    server-id=10  \n    log-bin=mysql-master-bin  \n    binlog_format = mixed  \n    expire_logs_days=15  \n    max_connections=10000  \n    innodb_flush_log_at_trx_commit=1  \n    sync_binlog=1  \n    binlog-ignore-db=mysql,test,information_schema  \n    skip-name-resolve  \n    port = 3306  \n    key_buffer_size = 16M  \n    max_allowed_packet = 16M  \n    join_buffer_size = 512M  \n    sort_buffer_size = 256M  \n    read_rnd_buffer_size = 128M  \n    innodb_buffer_pool_size = 4096M  \n    sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES  \n    [mysqld_safe]  \n    default-character-set=utf8mb4  \n    \n\n\nmysql简要配置文件---slave\n    [client]   \n    port = 3306  \n    default-character-set=utf8  \n    [mysqld]  \n    server-id=100  \n    #log-bin=mysql-slave-bin  \n    relay-log=mysqld-relay-bin  \n    max_binlog_size = 1000M  \n    binlog_format = mixed  \n    expire_logs_days=7  \n    innodb_flush_log_at_trx_commit=1  \n    sync_binlog=1  \n    read_only=1  \n    binlog-ignore-db=mysql,test,information_schema  \n    skip-name-resolve  \n    max_connections=10000  \n    max_user_connections=490  \n    max_connect_errors=2  \n    key_buffer_size = 16M  \n    max_allowed_packet = 16M  \n    join_buffer_size = 512M  \n    sort_buffer_size = 256M  \n    read_rnd_buffer_size = 128M  \n    innodb_buffer_pool_size = 4096M  \n    sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES  \n    [mysqld_safe]  \n    default-character-set=utf8mb4  ","source":"_posts/mysql主从配置文件内容.md","raw":"---\ntitle: mysql主从配置文件内容\ndate: 2016-09-05\ntags:\n---\n\nmysql简要配置文件---master\n<!--more-->\n    [client]  \n    port = 3306  \n    default-character-set=utf8  \n    [mysqld]  \n    server-id=10  \n    log-bin=mysql-master-bin  \n    binlog_format = mixed  \n    expire_logs_days=15  \n    max_connections=10000  \n    innodb_flush_log_at_trx_commit=1  \n    sync_binlog=1  \n    binlog-ignore-db=mysql,test,information_schema  \n    skip-name-resolve  \n    port = 3306  \n    key_buffer_size = 16M  \n    max_allowed_packet = 16M  \n    join_buffer_size = 512M  \n    sort_buffer_size = 256M  \n    read_rnd_buffer_size = 128M  \n    innodb_buffer_pool_size = 4096M  \n    sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES  \n    [mysqld_safe]  \n    default-character-set=utf8mb4  \n    \n\n\nmysql简要配置文件---slave\n    [client]   \n    port = 3306  \n    default-character-set=utf8  \n    [mysqld]  \n    server-id=100  \n    #log-bin=mysql-slave-bin  \n    relay-log=mysqld-relay-bin  \n    max_binlog_size = 1000M  \n    binlog_format = mixed  \n    expire_logs_days=7  \n    innodb_flush_log_at_trx_commit=1  \n    sync_binlog=1  \n    read_only=1  \n    binlog-ignore-db=mysql,test,information_schema  \n    skip-name-resolve  \n    max_connections=10000  \n    max_user_connections=490  \n    max_connect_errors=2  \n    key_buffer_size = 16M  \n    max_allowed_packet = 16M  \n    join_buffer_size = 512M  \n    sort_buffer_size = 256M  \n    read_rnd_buffer_size = 128M  \n    innodb_buffer_pool_size = 4096M  \n    sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES  \n    [mysqld_safe]  \n    default-character-set=utf8mb4  ","slug":"mysql主从配置文件内容","published":1,"updated":"2017-03-01T05:59:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizqklz7x000blbpv7n0kdryl","content":"<p>mysql简要配置文件—master<br><a id=\"more\"></a><br>    [client]<br>    port = 3306<br>    default-character-set=utf8<br>    [mysqld]<br>    server-id=10<br>    log-bin=mysql-master-bin<br>    binlog_format = mixed<br>    expire_logs_days=15<br>    max_connections=10000<br>    innodb_flush_log_at_trx_commit=1<br>    sync_binlog=1<br>    binlog-ignore-db=mysql,test,information_schema<br>    skip-name-resolve<br>    port = 3306<br>    key_buffer_size = 16M<br>    max_allowed_packet = 16M<br>    join_buffer_size = 512M<br>    sort_buffer_size = 256M<br>    read_rnd_buffer_size = 128M<br>    innodb_buffer_pool_size = 4096M<br>    sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES<br>    [mysqld_safe]<br>    default-character-set=utf8mb4  </p>\n<p>mysql简要配置文件—slave<br>    [client]<br>    port = 3306<br>    default-character-set=utf8<br>    [mysqld]<br>    server-id=100  </p>\n<pre><code>#log-bin=mysql-slave-bin  \nrelay-log=mysqld-relay-bin  \nmax_binlog_size = 1000M  \nbinlog_format = mixed  \nexpire_logs_days=7  \ninnodb_flush_log_at_trx_commit=1  \nsync_binlog=1  \nread_only=1  \nbinlog-ignore-db=mysql,test,information_schema  \nskip-name-resolve  \nmax_connections=10000  \nmax_user_connections=490  \nmax_connect_errors=2  \nkey_buffer_size = 16M  \nmax_allowed_packet = 16M  \njoin_buffer_size = 512M  \nsort_buffer_size = 256M  \nread_rnd_buffer_size = 128M  \ninnodb_buffer_pool_size = 4096M  \nsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES  \n[mysqld_safe]  \ndefault-character-set=utf8mb4  \n</code></pre>","excerpt":"<p>mysql简要配置文件—master<br>","more":"<br>    [client]<br>    port = 3306<br>    default-character-set=utf8<br>    [mysqld]<br>    server-id=10<br>    log-bin=mysql-master-bin<br>    binlog_format = mixed<br>    expire_logs_days=15<br>    max_connections=10000<br>    innodb_flush_log_at_trx_commit=1<br>    sync_binlog=1<br>    binlog-ignore-db=mysql,test,information_schema<br>    skip-name-resolve<br>    port = 3306<br>    key_buffer_size = 16M<br>    max_allowed_packet = 16M<br>    join_buffer_size = 512M<br>    sort_buffer_size = 256M<br>    read_rnd_buffer_size = 128M<br>    innodb_buffer_pool_size = 4096M<br>    sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES<br>    [mysqld_safe]<br>    default-character-set=utf8mb4  </p>\n<p>mysql简要配置文件—slave<br>    [client]<br>    port = 3306<br>    default-character-set=utf8<br>    [mysqld]<br>    server-id=100  </p>\n<pre><code>#log-bin=mysql-slave-bin  \nrelay-log=mysqld-relay-bin  \nmax_binlog_size = 1000M  \nbinlog_format = mixed  \nexpire_logs_days=7  \ninnodb_flush_log_at_trx_commit=1  \nsync_binlog=1  \nread_only=1  \nbinlog-ignore-db=mysql,test,information_schema  \nskip-name-resolve  \nmax_connections=10000  \nmax_user_connections=490  \nmax_connect_errors=2  \nkey_buffer_size = 16M  \nmax_allowed_packet = 16M  \njoin_buffer_size = 512M  \nsort_buffer_size = 256M  \nread_rnd_buffer_size = 128M  \ninnodb_buffer_pool_size = 4096M  \nsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES  \n[mysqld_safe]  \ndefault-character-set=utf8mb4  \n</code></pre>"},{"title":"tcpdump抓包命令详解","date":"2016-11-03T04:00:00.000Z","_content":"TCPdump抓包命令 \ntcpdump是一个用于截取网络分组，并输出分组内容的工具。tcpdump凭借强大的功能和灵活的截取策略，使其成为类UNIX系统下用于网络分析和问题排查的首选工具。 \ntcpdump提供了源代码，公开了接口，因此具备很强的可扩展性，对于网络维护和入侵者都是非常有用的工具。tcpdump存在于基本的Linux系统中，由于它需要将网络界面设置为混杂模式，普通用户不能正常执行，但具备root权限的用户可以直接执行它来获取网络上的信息。因此系统中存在网络分析工具主要不是对本机安全的威胁，而是对网络上的其他计算机的安全存在威胁。\n<!--more-->\n一、概述\n顾名思义，tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。\n引用\n# tcpdump -vv\ntcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes\n11:53:21.444591 IP (tos 0x10, ttl 64, id 19324, offset 0, flags [DF], proto 6, length: 92) asptest.localdomain.ssh > 192.168.228.244.1858: P 3962132600:3962132652(52) ack 2726525936 win 1266\nasptest.localdomain.1077 > 192.168.228.153.domain: [bad udp cksum 166e!] 325+ PTR? 244.228.168.192.in-addr.arpa. (46)\n11:53:21.446929 IP (tos 0x0, ttl 64, id 42911, offset 0, flags [DF], proto 17, length: 151) 192.168.228.153.domain > asptest.localdomain.1077: 325 NXDomain q: PTR? 244.228.168.192.in-addr.arpa. 0/1/0 ns: 168.192.in-addr.arpa. (123)\n11:53:21.447408 IP (tos 0x10, ttl 64, id 19328, offset 0, flags [DF], proto 6, length: 172) asptest.localdomain.ssh > 192.168.228.244.1858: P 168:300(132) ack 1 win 1266\n347 packets captured\n1474 packets received by filter\n745 packets dropped by kernel\n不带参数的tcpdump会收集网络中所有的信息包头，数据量巨大，必须过滤。\n\n二、选项介绍\n引用\n-A 以ASCII格式打印出所有分组，并将链路层的头最小化。 \n-c 在收到指定的数量的分组后，tcpdump就会停止。 \n-C 在将一个原始分组写入文件之前，检查文件当前的大小是否超过了参数file_size 中指定的大小。如果超过了指定大小，则关闭当前文件，然后在打开一个新的文件。参数 file_size 的单位是兆字节（是1,000,000字节，而不是1,048,576字节）。 \n-d 将匹配信息包的代码以人们能够理解的汇编格式给出。 \n-dd 将匹配信息包的代码以C语言程序段的格式给出。 \n-ddd 将匹配信息包的代码以十进制的形式给出。 \n-D 打印出系统中所有可以用tcpdump截包的网络接口。 \n-e 在输出行打印出数据链路层的头部信息。 \n-E 用spi@ipaddr algo:secret解密那些以addr作为地址，并且包含了安全参数索引值spi的IPsec ESP分组。 \n-f 将外部的Internet地址以数字的形式打印出来。 \n-F 从指定的文件中读取表达式，忽略命令行中给出的表达式。 \n-i 指定监听的网络接口。 \n-l 使标准输出变为缓冲行形式，可以把数据导出到文件。 \n-L 列出网络接口的已知数据链路。 \n-m 从文件module中导入SMI MIB模块定义。该参数可以被使用多次，以导入多个MIB模块。 \n-M 如果tcp报文中存在TCP-MD5选项，则需要用secret作为共享的验证码用于验证TCP-MD5选选项摘要（详情可参考RFC 2385）。 \n-b 在数据-链路层上选择协议，包括ip、arp、rarp、ipx都是这一层的。\n-n 不把网络地址转换成名字。\n-nn 不进行端口名称的转换。\n-N 不输出主机名中的域名部分。例如，‘nic.ddn.mil‘只输出’nic‘。 \n-t 在输出的每一行不打印时间戳。 \n-O 不运行分组分组匹配（packet-matching）代码优化程序。 \n-P 不将网络接口设置成混杂模式。 \n-q 快速输出。只输出较少的协议信息。 \n-r 从指定的文件中读取包(这些包一般通过-w选项产生)。 \n-S 将tcp的序列号以绝对值形式输出，而不是相对值。 \n-s 从每个分组中读取最开始的snaplen个字节，而不是默认的68个字节。 \n-T 将监听到的包直接解释为指定的类型的报文，常见的类型有rpc远程过程调用）和snmp（简单网络管理协议；）。 \n-t 不在每一行中输出时间戳。 \n-tt 在每一行中输出非格式化的时间戳。 \n-ttt 输出本行和前面一行之间的时间差。 \n-tttt 在每一行中输出由date处理的默认格式的时间戳。 \n-u 输出未解码的NFS句柄。 \n-v 输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息。 \n-vv 输出详细的报文信息。 \n-w 直接将分组写入文件中，而不是不分析并打印出来。\n\n三、tcpdump的表达式介绍\n表达式是一个正则表达式，tcpdump利用它作为过滤报文的条件，如果一个报文满足表 达式的条件，则这个报文将会被捕获。如果没有给出任何条件，则网络上所有的信息包 将会被截获。 \n在表达式中一般如下几种类型的关键字： \n引用\n第一种是关于类型的关键字，主要包括host，net，port，例如 host 210.27.48.2， 指明 210.27.48.2是一台主机，net 202.0.0.0指明202.0.0.0是一个网络地址，port 23 指明端口号是23。如果没有指定类型，缺省的类型是host。 \n第二种是确定传输方向的关键字，主要包括src，dst，dst or src，dst and src， 这些关键字指明了传输的方向。举例说明，src 210.27.48.2 ，指明ip包中源地址是 210.27.48.2 ， dst net 202.0.0.0 指明目的网络地址是202.0.0.0。如果没有指明 方向关键字，则缺省是src or dst关键字。 \n第三种是协议的关键字，主要包括fddi，ip，arp，rarp，tcp，udp等类型。Fddi指明是在FDDI (分布式光纤数据接口网络)上的特定的网络协议，实际上它是”ether”的别名，fddi和ether 具有类似的源地址和目的地址，所以可以将fddi协议包当作ether的包进行处理和分析。 其他的几个关键字就是指明了监听的包的协议内容。如果没有指定任何协议，则tcpdump 将会 监听所有协议的信息包。\n除了这三种类型的关键字之外，其他重要的关键字如下：gateway， broadcast，less， greater， 还有三种逻辑运算，取非运算是 ‘not ' '! ‘， 与运算是’and’，’&&';或运算是’or’ ，’&#124;&#124;’； 这些关键字可以组合起来构成强大的组合条件来满足人们的需要。\n四、输出结果介绍\n下面我们介绍几种典型的tcpdump命令的输出信息 \n(1) 数据链路层头信息 \n使用命令： \n#tcpdump --e host ICE\nICE 是一台装有linux的主机。它的MAC地址是0：90：27：58：AF：1A H219是一台装有Solaris的SUN工作站。它的MAC地址是8：0：20：79：5B：46； 上一条命令的输出结果如下所示：\n引用\n21:50:12.847509 eth0 < 8:0:20:79:5b:46 0:90:27:58:af:1a ip 60: h219.33357 > ICE. telne t 0:0(0) ack 22535 win 8760 (DF)\n21：50：12是显示的时间， 847509是ID号，eth0 <表示从网络接口eth0接收该分组， eth0 >表示从网络接口设备发送分组， 8:0:20:79:5b:46是主机H219的MAC地址， 它表明是从源地址H219发来的分组. 0:90:27:58:af:1a是主机ICE的MAC地址， 表示该分组的目的地址是ICE。 ip 是表明该分组是IP分组，60 是分组的长度， h219.33357 > ICE. telnet 表明该分组是从主机H219的33357端口发往主机ICE的 TELNET(23)端口。 ack 22535 表明对序列号是222535的包进行响应。 win 8760表明发 送窗口的大小是8760。 \n(2) ARP包的tcpdump输出信息 \n使用命令： \n#tcpdump arp\n得到的输出结果是：\n引用\n22:32:42.802509 eth0 > arp who-has route tell ICE (0:90:27:58:af:1a)\n22:32:42.802902 eth0 < arp reply route is-at 0:90:27:12:10:66 (0:90:27:58:af:1a)\n22:32:42是时间戳， 802509是ID号， eth0 >表明从主机发出该分组，arp表明是ARP请求包， who-has route tell ICE表明是主机ICE请求主机route的MAC地址。 0:90:27:58:af:1a是主机 ICE的MAC地址。\n(3) TCP包的输出信息 \n用tcpdump捕获的TCP包的一般输出信息是： \n引用\nsrc > dst: flags data-seqno ack window urgent options\nsrc > dst:表明从源地址到目的地址， flags是TCP报文中的标志信息，S 是SYN标志， F (FIN)， P (PUSH) ， R (RST) \".\" (没有标记); data-seqno是报文中的数据 的顺序号， ack是下次期望的顺序号， window是接收缓存的窗口大小， urgent表明 报文中是否有紧急指针。 Options是选项。 \n(4) UDP包的输出信息\n用tcpdump捕获的UDP包的一般输出信息是： \n引用\nroute.port1 > ICE.port2: udp lenth\nUDP十分简单，上面的输出行表明从主机route的port1端口发出的一个UDP报文 到主机ICE的port2端口，类型是UDP， 包的长度是lenth。 \n五、举例\n(1) 想要截获所有210.27.48.1 的主机收到的和发出的所有的分组： \n#tcpdump host 210.27.48.1 \n(2) 想要截获主机210.27.48.1 和主机210.27.48.2或210.27.48.3的通信，使用命令（注意：括号前的反斜杠是必须的）： \n#tcpdump host 210.27.48.1 and 210.27.48.2or210.27.48.3\n(3) 如果想要获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包，使用命令： \n#tcpdump ip host 210.27.48.1 and ! 210.27.48.2\n(4) 如果想要获取主机192.168.228.246接收或发出的ssh包，并且不转换主机名使用如下命令： \n#tcpdump -nn -n src host 192.168.228.246 and port 22 and tcp\n(5) 获取主机192.168.228.246接收或发出的ssh包，并把mac地址也一同显示：\n# tcpdump -e src host 192.168.228.246 and port 22 and tcp -n -nn\n(6) 过滤的是源主机为192.168.0.1与目的网络为192.168.0.0的报头：\ntcpdump src host 192.168.0.1 and dst net 192.168.0.0/24 \n(7) 过滤源主机物理地址为XXX的报头：\ntcpdump ether src 00:50:04:BA:9B and dst……\n（为什么ether src后面没有host或者net？物理地址当然不可能有网络喽）。 \n(8) 过滤源主机192.168.0.1和目的端口不是telnet的报头，并导入到tes.t.txt文件中：\nTcpdump src host 192.168.0.1 and dst port not telnet -l > test.txt\nip icmp arp rarp 和 tcp、udp、icmp这些选项等都要放到第一个参数的位置，用来过滤数据报的类型。\ntcpdump采用命令行方式，它的命令格式为：\ntcpdump [-nn] [-i 接口] [-w 储存档名] [-c 次数] [-Ae]\n                        [-qX] [-r 文件] [所欲捕获的数据内容]\n参数：\n-nn，直接以 IP 及 Port Number 显示，而非主机名与服务名称。\n-i，后面接要「监听」的网络接口，例如 eth0, lo, ppp0 等等的接口。\n-w，如果你要将监听所得的数据包数据储存下来，用这个参数就对了。后面接文件名。\n-c，监听的数据包数，如果没有这个参数， tcpdump 会持续不断的监听，\n     直到用户输入 [ctrl]-c 为止。\n-A，数据包的内容以 ASCII 显示，通常用来捉取 WWW 的网页数据包资料。\n-e，使用资料连接层 (OSI 第二层) 的 MAC 数据包数据来显示。\n-q，仅列出较为简短的数据包信息，每一行的内容比较精简。\n-X，可以列出十六进制 (hex) 以及 ASCII 的数据包内容，对于监听数据包内容很有用。\n-r，从后面接的文件将数据包数据读出来。那个「文件」是已经存在的文件，\n     并且这个「文件」是由 -w 所制作出来的。\n所欲捕获的数据内容：我们可以专门针对某些通信协议或者是 IP 来源进行数据包捕获。\n     那就可以简化输出的结果，并取得最有用的信息。常见的表示方法有。\n    'host foo', 'host 127.0.0.1' ：针对单台主机来进行数据包捕获。\n     'net 192.168' ：针对某个网段来进行数据包的捕获。\n     'src host 127.0.0.1' 'dst net 192.168'：同时加上来源(src)或目标(dst)限制。\n     'tcp port 21'：还可以针对通信协议检测，如tcp、udp、arp、ether 等。\n     除了这三种类型的关键字之外，其他重要的关键字如下：gateway, broadcast,less,\ngreater,还有三种逻辑运算，取非运算是 'not ' '! ', 与运算是'and','&&';或运算 是'o\nr' ,'||'；\n\n范例一：以 IP 与 Port Number 捉下 eth0 这个网卡上的数据包，持续 3 秒\n[root@linux ~]# tcpdump -i eth0 -nn\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes\n01:33:40.41 IP 192.168.1.100.22 > 192.168.1.11.1190: P 116:232(116) ack 1 win \n9648\n01:33:40.41 IP 192.168.1.100.22 > 192.168.1.11.1190: P 232:364(132) ack 1 win \n9648\n<==按下 [ctrl]-c 之后结束\n6680 packets captured              <==捉取下来的数据包数量\n14250 packets received by filter   <==由过滤所得的总数据包数量\n7512 packets dropped by kernel     <==被核心所丢弃的数据包\n至于那个在范例一所产生的输出中，我们可以大概区分为几个字段，现以范例一当中那行特殊字体行来说明一下：\n· 01:33:40.41：这个是此数据包被捕获的时间，“时:分:秒”的单位。\n· IP：通过的通信协议是IP。\n· 192.168.1.100.22>：传送端是192.168.1.100这个IP，而传送的Port Number为22，那个大于（>）的符号指的是数据包的传输方向。\n· 192.168.1.11.1190：接收端的IP是192.168.1.11，且该主机开启port 1190来接收。\n· P 116:232(116)：这个数据包带有PUSH的数据传输标志，且传输的数据为整体数据的116~232 Byte，所以这个数据包带有116 Bytes的数据量。\n· ack 1 win 9648：ACK与Window size的相关资料。\n最简单的说法，就是该数据包是由192.168.1.100传到192.168.1.11，通过的port是由22到1190，且带有116 Bytes的数据量，使用的是PUSH的标记，而不是SYN之类的主动联机标志。\n接下来，在一个网络状态很忙的主机上面，你想要取得某台主机对你联机的数据包数据时，使用tcpdump配合管线命令与正则表达式也可以，不过，毕竟不好捕获。我们可以通过tcpdump的表达式功能，就能够轻易地将所需要的数据独立的取出来。在上面的范例一当中，我们仅针对eth0做监听，所以整个eth0接口上面的数据都会被显示到屏幕上，但这样不好分析，可以简化吗？例如，只取出port 21的联机数据包，可以这样做：\n[root@linux ~]# tcpdump -i eth0 -nn port 21\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes\n01:54:37.96 IP 192.168.1.11.1240 > 192.168.1.100.21:. ack 1 win 65535\n01:54:37.96 IP 192.168.1.100.21 > 192.168.1.11.1240:P 1:21(20) ack 1 win 5840\n01:54:38.12 IP 192.168.1.11.1240 > 192.168.1.100.21:. ack 21 win 65515\n01:54:42.79 IP 192.168.1.11.1240 > 192.168.1.100.21:P 1:17(16) ack 21 win 65515\n01:54:42.79 IP 192.168.1.100.21 > 192.168.1.11.1240: . ack 17 win 5840\n01:54:42.79 IP 192.168.1.100.21 > 192.168.1.11.1240: P 21:55(34) ack 17 win 5840\n看！这样就仅取出port 21的信息，如果仔细看的话，你会发现数据包的传递都是双向的，Client端发出请求而Server端则予以响应，所以，当然是有去有回了。而我们也就可以经过这个数据包的流向来了解到数据包运动的过程了。例如：\n· 我们先在一个终端机窗口输入“tcpdump-i lo-nn”的监听。\n· 再另开一个终端机窗口来对本机（127.0.0.1）登录“ssh localhost”，那么输出的结果会是如何？\n[root@linux ~]# tcpdump -i lo -nn\n 1 tcpdump: verbose output suppressed, use -v or -vv for full protocol decode\n 2 listening on lo, link-type EN10MB (Ethernet), capture size 96 bytes\n 3 11:02:54.253777 IP 127.0.0.1.32936 > \n127.0.0.1.22: S 933696132:933696132(0) \n   win 32767 \n 4 11:02:54.253831 IP 127.0.0.1.22 > 127.0.0.1.32936: \nS 920046702:920046702(0) \n   ack 933696133 win 32767 \n 5 11:02:54.253871 IP 127.0.0.1.32936 > 127.0.0.1.22: . ack 1 win 8192 \n 6 11:02:54.272124 IP 127.0.0.1.22 > 127.0.0.1.32936: \nP 1:23(22) ack 1 win 8192 \n   \n 7 11:02:54.272375 IP 127.0.0.1.32936 > 127.0.0.1.22: . ack 23 win 8192\n代码显示的头两行是tcpdump的基本说明，然后：\n· 第3行显示的是来自Client端带有SYN主动联机的数据包。 \n· 第4行显示的是来自Server端，除了响应Client端之外（ACK），还带有SYN主动联机的标志。 \n· 第5行则显示Client端响应Server确定联机建立（ACK）。\n· 第6行以后则开始进入数据传输的步骤。\n从第3~5行的流程来看，熟不熟悉啊？没错。那就是3次握手的基础流程，有趣吧。不过tcpdump之所以被称为黑客软件之一远不止上面介绍的功能。上面介绍的功能可以用来作为我们主机的数据包联机与传输的流程分析，这将有助于我们了解到数据包的运作，同时了解到主机的防火墙设置规则是否有需要修订的地方。\n还有更神奇的用法。当我们使用tcpdump在Router上面监听明文的传输数据时，例如FTP传输协议，你觉得会发生什么问题呢？我们先在主机端执行“tcpdump -i lo port 21 -nn –X”，然后再以FTP登录本机，并输入账号与密码，结果你就可以发现如下的状况：\n[root@linux ~]# tcpdump -i lo -nn -X 'port 21'\n    0x0000:  4500 0048 2a28 4000 4006 1286 7f00 0001  E..H*(@.@.......\n    0x0010:  7f00 0001 0015 80ab 8355 2149 835c d825  .........U!I.\\.%\n    0x0020:  8018 2000 fe3c 0000 0101 080a 0e2e 0b67  .....<.........g\n    0x0030:  0e2e 0b61 3232 3020 2876 7346 5450 6420  ...a220.(vsFTPd.\n    0x0040:  322e 302e 3129 0d0a                      2.0.1)..\n\n    0x0000:  4510 0041 d34b 4000 4006 6959 7f00 0001  E..A.K@.@.iY....\n    0x0010:  7f00 0001 80ab 0015 835c d825 8355 215d  .........\\.%.U!]\n    0x0020:  8018 2000 fe35 0000 0101 080a 0e2e 1b37  .....5.........7\n    0x0030:  0e2e 0b67 5553 4552 2064 6d74 7361 690d  ...gUSER.dmtsai.\n    0x0040:  0a                                       .\n\n    0x0000:  4510 004a d34f 4000 4006 694c 7f00 0001  E..J.O@.@.iL....\n    0x0010:  7f00 0001 80ab 0015 835c d832 8355 217f  .........\\.2.U!.\n    0x0020:  8018 2000 fe3e 0000 0101 080a 0e2e 3227  .....>........2'\n    0x0030:  0e2e 1b38 5041 5353 206d 7970 6173 7377  ...8PASS.mypassw\n    0x0040:  6f72 6469 7379 6f75 0d0a                 ordisyou..\n上面的输出结果已经被简化过了，你需要自行在你的输出结果中搜索相关的字符串才行。从上面输出结果的特殊字体中，我们可以发现该FTP软件使用的是 vsFTPd，并且用户输入dmtsai这个账号名称，且密码是mypasswordisyou。如果使用的是明文方式来传输你的网络数据呢？\n另外你得了解，为了让网络接口可以让tcpdump监听，所以执行tcpdump时网络接口会启动在“混杂模式（promiscuous）”，所以你会在 /var/log/messages里面看到很多的警告信息，通知你说你的网卡被设置成为混杂模式。别担心，那是正常的。至于更多的应用，请参考man tcpdump了。\n\n例题：如何使用tcpdump监听来自eth0适配卡且通信协议为port 22，目标来源为192.168.1.100的数据包资料？\n答：tcpdump -i eth0 -nn 'port 22 and src host 192.168.1.100'。\n##############例子2#######################################\n \n普通情况下，直接启动tcpdump将监视第一个网络界面上所有流过的数据包。\n# tcpdump\ntcpdump: listening on fxp0\n11:58:47.873028 202.102.245.40.netbios-ns > 202.102.245.127.netbios-ns: udp 50\n11:58:47.974331 0:10:7b:8:3a:56 > 1:80:c2:0:0:0 802.1d ui/C len=43\n0000 0000 0080 0000 1007 cf08 0900 0000\n0e80 0000 902b 4695 0980 8701 0014 0002\n000f 0000 902b 4695 0008 00\n11:58:48.373134 0:0:e8:5b:6d:85 > Broadcast sap e0 ui/C len=97\nffff 0060 0004 ffff ffff ffff ffff ffff\n0452 ffff ffff 0000 e85b 6d85 4008 0002\n0640 4d41 5354 4552 5f57 4542 0000 0000\n0000 00\n使用-i参数指定tcpdump监听的网络界面，这在计算机具有多个网络界面时非常有用，\n使用-c参数指定要监听的数据包数量，\n使用-w参数指定将监听到的数据包写入文件中保存\nA想要截获所有210.27.48.1 的主机收到的和发出的所有的数据包：\n#tcpdump host 210.27.48.1\nB想要截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信，使用命令：（在命令行中适用　　　括号时，一定要\n#tcpdump host 210.27.48.1 and \\ (210.27.48.2 or 210.27.48.3 \\)\nC如果想要获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包，使用命令：\n#tcpdump ip host 210.27.48.1 and ! 210.27.48.2\nD如果想要获取主机210.27.48.1接收或发出的telnet包，使用如下命令：\n#tcpdump tcp port 23 host 210.27.48.1\nE 对本机的udp 123 端口进行监视 123 为ntp的服务端口\n# tcpdump udp port 123\nF 系统将只对名为hostname的主机的通信数据包进行监视。主机名可以是本地主机，也可以是网络上的任何一台计算机。下面的命令可以读取主机hostname发送的所有数据：\n#tcpdump -i eth0 src host hostname\nG 下面的命令可以监视所有送到主机hostname的数据包：\n#tcpdump -i eth0 dst host hostname\nH 我们还可以监视通过指定网关的数据包：\n#tcpdump -i eth0 gateway Gatewayname\nI 如果你还想监视编址到指定端口的TCP或UDP数据包，那么执行以下命令：\n#tcpdump -i eth0 host hostname and port 80\nJ 如果想要获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包\n，使用命令：\n#tcpdump ip host 210.27.48.1 and ! 210.27.48.2\nK 想要截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信，使用命令\n：（在命令行中适用　　　括号时，一定要\n#tcpdump host 210.27.48.1 and \\ (210.27.48.2 or 210.27.48.3 \\)\nL 如果想要获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包，使用命令：\n#tcpdump ip host 210.27.48.1 and ! 210.27.48.2\nM 如果想要获取主机210.27.48.1接收或发出的telnet包，使用如下命令：\n#tcpdump tcp port 23 host 210.27.48.1\n第三种是协议的关键字，主要包括fddi,ip ,arp,rarp,tcp,udp等类型\n除了这三种类型的关键字之外，其他重要的关键字如下：gateway, broadcast,less,\ngreater,还有三种逻辑运算，取非运算是 ‘not ‘ ‘! ‘, 与运算是‘and‘,‘&&‘;或运算 是‘o\nr‘ ,‘||‘；\n第二种是确定传输方向的关键字，主要包括src , dst ,dst or src, dst and src ,\n如果我们只需要列出送到80端口的数据包，用dst port；如果我们只希望看到返回80端口的数据包，用src port。\n#tcpdump –i eth0 host hostname and dst port 80 目的端口是80\n或者\n#tcpdump –i eth0 host hostname and src port 80 源端口是80 一般是提供http的服务的主机\n如果条件很多的话 要在条件之前加and 或 or 或 not\n#tcpdump -i eth0 host ! 211.161.223.70 and ! 211.161.223.71 and dst port 80\n如果在ethernet 使用混杂模式 系统的日志将会记录\nMay 7 20:03:46 localhost kernel: eth0: Promiscuous mode enabled.\nMay 7 20:03:46 localhost kernel: device eth0 entered promiscuous mode\nMay 7 20:03:57 localhost kernel: device eth0 left promiscuous mode\ntcpdump对截获的数据并没有进行彻底解码，数据包内的大部分内容是使用十六进制的形式直接打印输出的。显然这不利于分析网络故障，通常的解决办法是先使用带-w参数的tcpdump 截获数据并保存到文件中，然后再使用其他程序进行解码分析。当然也应该定义过滤规则，以避免捕获的数据包填满整个硬盘。\n除了过滤语句，还有一个很重要的参数，也就是说，如果这个参数不设置正确，会导致包数据的丢失！\n它就是-s 参数，snaplen, 也就是数据包的截取长度，仔细看man就会明白的！默认截取长度为60个字节，但一般ethernet MTU都是1500字节。所以，要抓取大于60字节的包时，使用默认参数就会导致包数据丢失！\n只要使用-s 0就可以按包长，截取数据！","source":"_posts/tcpdump抓包命令详解.md","raw":"---\ntitle: tcpdump抓包命令详解\ndate: 2016-11-03\ntags:\n---\nTCPdump抓包命令 \ntcpdump是一个用于截取网络分组，并输出分组内容的工具。tcpdump凭借强大的功能和灵活的截取策略，使其成为类UNIX系统下用于网络分析和问题排查的首选工具。 \ntcpdump提供了源代码，公开了接口，因此具备很强的可扩展性，对于网络维护和入侵者都是非常有用的工具。tcpdump存在于基本的Linux系统中，由于它需要将网络界面设置为混杂模式，普通用户不能正常执行，但具备root权限的用户可以直接执行它来获取网络上的信息。因此系统中存在网络分析工具主要不是对本机安全的威胁，而是对网络上的其他计算机的安全存在威胁。\n<!--more-->\n一、概述\n顾名思义，tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。\n引用\n# tcpdump -vv\ntcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes\n11:53:21.444591 IP (tos 0x10, ttl 64, id 19324, offset 0, flags [DF], proto 6, length: 92) asptest.localdomain.ssh > 192.168.228.244.1858: P 3962132600:3962132652(52) ack 2726525936 win 1266\nasptest.localdomain.1077 > 192.168.228.153.domain: [bad udp cksum 166e!] 325+ PTR? 244.228.168.192.in-addr.arpa. (46)\n11:53:21.446929 IP (tos 0x0, ttl 64, id 42911, offset 0, flags [DF], proto 17, length: 151) 192.168.228.153.domain > asptest.localdomain.1077: 325 NXDomain q: PTR? 244.228.168.192.in-addr.arpa. 0/1/0 ns: 168.192.in-addr.arpa. (123)\n11:53:21.447408 IP (tos 0x10, ttl 64, id 19328, offset 0, flags [DF], proto 6, length: 172) asptest.localdomain.ssh > 192.168.228.244.1858: P 168:300(132) ack 1 win 1266\n347 packets captured\n1474 packets received by filter\n745 packets dropped by kernel\n不带参数的tcpdump会收集网络中所有的信息包头，数据量巨大，必须过滤。\n\n二、选项介绍\n引用\n-A 以ASCII格式打印出所有分组，并将链路层的头最小化。 \n-c 在收到指定的数量的分组后，tcpdump就会停止。 \n-C 在将一个原始分组写入文件之前，检查文件当前的大小是否超过了参数file_size 中指定的大小。如果超过了指定大小，则关闭当前文件，然后在打开一个新的文件。参数 file_size 的单位是兆字节（是1,000,000字节，而不是1,048,576字节）。 \n-d 将匹配信息包的代码以人们能够理解的汇编格式给出。 \n-dd 将匹配信息包的代码以C语言程序段的格式给出。 \n-ddd 将匹配信息包的代码以十进制的形式给出。 \n-D 打印出系统中所有可以用tcpdump截包的网络接口。 \n-e 在输出行打印出数据链路层的头部信息。 \n-E 用spi@ipaddr algo:secret解密那些以addr作为地址，并且包含了安全参数索引值spi的IPsec ESP分组。 \n-f 将外部的Internet地址以数字的形式打印出来。 \n-F 从指定的文件中读取表达式，忽略命令行中给出的表达式。 \n-i 指定监听的网络接口。 \n-l 使标准输出变为缓冲行形式，可以把数据导出到文件。 \n-L 列出网络接口的已知数据链路。 \n-m 从文件module中导入SMI MIB模块定义。该参数可以被使用多次，以导入多个MIB模块。 \n-M 如果tcp报文中存在TCP-MD5选项，则需要用secret作为共享的验证码用于验证TCP-MD5选选项摘要（详情可参考RFC 2385）。 \n-b 在数据-链路层上选择协议，包括ip、arp、rarp、ipx都是这一层的。\n-n 不把网络地址转换成名字。\n-nn 不进行端口名称的转换。\n-N 不输出主机名中的域名部分。例如，‘nic.ddn.mil‘只输出’nic‘。 \n-t 在输出的每一行不打印时间戳。 \n-O 不运行分组分组匹配（packet-matching）代码优化程序。 \n-P 不将网络接口设置成混杂模式。 \n-q 快速输出。只输出较少的协议信息。 \n-r 从指定的文件中读取包(这些包一般通过-w选项产生)。 \n-S 将tcp的序列号以绝对值形式输出，而不是相对值。 \n-s 从每个分组中读取最开始的snaplen个字节，而不是默认的68个字节。 \n-T 将监听到的包直接解释为指定的类型的报文，常见的类型有rpc远程过程调用）和snmp（简单网络管理协议；）。 \n-t 不在每一行中输出时间戳。 \n-tt 在每一行中输出非格式化的时间戳。 \n-ttt 输出本行和前面一行之间的时间差。 \n-tttt 在每一行中输出由date处理的默认格式的时间戳。 \n-u 输出未解码的NFS句柄。 \n-v 输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息。 \n-vv 输出详细的报文信息。 \n-w 直接将分组写入文件中，而不是不分析并打印出来。\n\n三、tcpdump的表达式介绍\n表达式是一个正则表达式，tcpdump利用它作为过滤报文的条件，如果一个报文满足表 达式的条件，则这个报文将会被捕获。如果没有给出任何条件，则网络上所有的信息包 将会被截获。 \n在表达式中一般如下几种类型的关键字： \n引用\n第一种是关于类型的关键字，主要包括host，net，port，例如 host 210.27.48.2， 指明 210.27.48.2是一台主机，net 202.0.0.0指明202.0.0.0是一个网络地址，port 23 指明端口号是23。如果没有指定类型，缺省的类型是host。 \n第二种是确定传输方向的关键字，主要包括src，dst，dst or src，dst and src， 这些关键字指明了传输的方向。举例说明，src 210.27.48.2 ，指明ip包中源地址是 210.27.48.2 ， dst net 202.0.0.0 指明目的网络地址是202.0.0.0。如果没有指明 方向关键字，则缺省是src or dst关键字。 \n第三种是协议的关键字，主要包括fddi，ip，arp，rarp，tcp，udp等类型。Fddi指明是在FDDI (分布式光纤数据接口网络)上的特定的网络协议，实际上它是”ether”的别名，fddi和ether 具有类似的源地址和目的地址，所以可以将fddi协议包当作ether的包进行处理和分析。 其他的几个关键字就是指明了监听的包的协议内容。如果没有指定任何协议，则tcpdump 将会 监听所有协议的信息包。\n除了这三种类型的关键字之外，其他重要的关键字如下：gateway， broadcast，less， greater， 还有三种逻辑运算，取非运算是 ‘not ' '! ‘， 与运算是’and’，’&&';或运算是’or’ ，’&#124;&#124;’； 这些关键字可以组合起来构成强大的组合条件来满足人们的需要。\n四、输出结果介绍\n下面我们介绍几种典型的tcpdump命令的输出信息 \n(1) 数据链路层头信息 \n使用命令： \n#tcpdump --e host ICE\nICE 是一台装有linux的主机。它的MAC地址是0：90：27：58：AF：1A H219是一台装有Solaris的SUN工作站。它的MAC地址是8：0：20：79：5B：46； 上一条命令的输出结果如下所示：\n引用\n21:50:12.847509 eth0 < 8:0:20:79:5b:46 0:90:27:58:af:1a ip 60: h219.33357 > ICE. telne t 0:0(0) ack 22535 win 8760 (DF)\n21：50：12是显示的时间， 847509是ID号，eth0 <表示从网络接口eth0接收该分组， eth0 >表示从网络接口设备发送分组， 8:0:20:79:5b:46是主机H219的MAC地址， 它表明是从源地址H219发来的分组. 0:90:27:58:af:1a是主机ICE的MAC地址， 表示该分组的目的地址是ICE。 ip 是表明该分组是IP分组，60 是分组的长度， h219.33357 > ICE. telnet 表明该分组是从主机H219的33357端口发往主机ICE的 TELNET(23)端口。 ack 22535 表明对序列号是222535的包进行响应。 win 8760表明发 送窗口的大小是8760。 \n(2) ARP包的tcpdump输出信息 \n使用命令： \n#tcpdump arp\n得到的输出结果是：\n引用\n22:32:42.802509 eth0 > arp who-has route tell ICE (0:90:27:58:af:1a)\n22:32:42.802902 eth0 < arp reply route is-at 0:90:27:12:10:66 (0:90:27:58:af:1a)\n22:32:42是时间戳， 802509是ID号， eth0 >表明从主机发出该分组，arp表明是ARP请求包， who-has route tell ICE表明是主机ICE请求主机route的MAC地址。 0:90:27:58:af:1a是主机 ICE的MAC地址。\n(3) TCP包的输出信息 \n用tcpdump捕获的TCP包的一般输出信息是： \n引用\nsrc > dst: flags data-seqno ack window urgent options\nsrc > dst:表明从源地址到目的地址， flags是TCP报文中的标志信息，S 是SYN标志， F (FIN)， P (PUSH) ， R (RST) \".\" (没有标记); data-seqno是报文中的数据 的顺序号， ack是下次期望的顺序号， window是接收缓存的窗口大小， urgent表明 报文中是否有紧急指针。 Options是选项。 \n(4) UDP包的输出信息\n用tcpdump捕获的UDP包的一般输出信息是： \n引用\nroute.port1 > ICE.port2: udp lenth\nUDP十分简单，上面的输出行表明从主机route的port1端口发出的一个UDP报文 到主机ICE的port2端口，类型是UDP， 包的长度是lenth。 \n五、举例\n(1) 想要截获所有210.27.48.1 的主机收到的和发出的所有的分组： \n#tcpdump host 210.27.48.1 \n(2) 想要截获主机210.27.48.1 和主机210.27.48.2或210.27.48.3的通信，使用命令（注意：括号前的反斜杠是必须的）： \n#tcpdump host 210.27.48.1 and 210.27.48.2or210.27.48.3\n(3) 如果想要获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包，使用命令： \n#tcpdump ip host 210.27.48.1 and ! 210.27.48.2\n(4) 如果想要获取主机192.168.228.246接收或发出的ssh包，并且不转换主机名使用如下命令： \n#tcpdump -nn -n src host 192.168.228.246 and port 22 and tcp\n(5) 获取主机192.168.228.246接收或发出的ssh包，并把mac地址也一同显示：\n# tcpdump -e src host 192.168.228.246 and port 22 and tcp -n -nn\n(6) 过滤的是源主机为192.168.0.1与目的网络为192.168.0.0的报头：\ntcpdump src host 192.168.0.1 and dst net 192.168.0.0/24 \n(7) 过滤源主机物理地址为XXX的报头：\ntcpdump ether src 00:50:04:BA:9B and dst……\n（为什么ether src后面没有host或者net？物理地址当然不可能有网络喽）。 \n(8) 过滤源主机192.168.0.1和目的端口不是telnet的报头，并导入到tes.t.txt文件中：\nTcpdump src host 192.168.0.1 and dst port not telnet -l > test.txt\nip icmp arp rarp 和 tcp、udp、icmp这些选项等都要放到第一个参数的位置，用来过滤数据报的类型。\ntcpdump采用命令行方式，它的命令格式为：\ntcpdump [-nn] [-i 接口] [-w 储存档名] [-c 次数] [-Ae]\n                        [-qX] [-r 文件] [所欲捕获的数据内容]\n参数：\n-nn，直接以 IP 及 Port Number 显示，而非主机名与服务名称。\n-i，后面接要「监听」的网络接口，例如 eth0, lo, ppp0 等等的接口。\n-w，如果你要将监听所得的数据包数据储存下来，用这个参数就对了。后面接文件名。\n-c，监听的数据包数，如果没有这个参数， tcpdump 会持续不断的监听，\n     直到用户输入 [ctrl]-c 为止。\n-A，数据包的内容以 ASCII 显示，通常用来捉取 WWW 的网页数据包资料。\n-e，使用资料连接层 (OSI 第二层) 的 MAC 数据包数据来显示。\n-q，仅列出较为简短的数据包信息，每一行的内容比较精简。\n-X，可以列出十六进制 (hex) 以及 ASCII 的数据包内容，对于监听数据包内容很有用。\n-r，从后面接的文件将数据包数据读出来。那个「文件」是已经存在的文件，\n     并且这个「文件」是由 -w 所制作出来的。\n所欲捕获的数据内容：我们可以专门针对某些通信协议或者是 IP 来源进行数据包捕获。\n     那就可以简化输出的结果，并取得最有用的信息。常见的表示方法有。\n    'host foo', 'host 127.0.0.1' ：针对单台主机来进行数据包捕获。\n     'net 192.168' ：针对某个网段来进行数据包的捕获。\n     'src host 127.0.0.1' 'dst net 192.168'：同时加上来源(src)或目标(dst)限制。\n     'tcp port 21'：还可以针对通信协议检测，如tcp、udp、arp、ether 等。\n     除了这三种类型的关键字之外，其他重要的关键字如下：gateway, broadcast,less,\ngreater,还有三种逻辑运算，取非运算是 'not ' '! ', 与运算是'and','&&';或运算 是'o\nr' ,'||'；\n\n范例一：以 IP 与 Port Number 捉下 eth0 这个网卡上的数据包，持续 3 秒\n[root@linux ~]# tcpdump -i eth0 -nn\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes\n01:33:40.41 IP 192.168.1.100.22 > 192.168.1.11.1190: P 116:232(116) ack 1 win \n9648\n01:33:40.41 IP 192.168.1.100.22 > 192.168.1.11.1190: P 232:364(132) ack 1 win \n9648\n<==按下 [ctrl]-c 之后结束\n6680 packets captured              <==捉取下来的数据包数量\n14250 packets received by filter   <==由过滤所得的总数据包数量\n7512 packets dropped by kernel     <==被核心所丢弃的数据包\n至于那个在范例一所产生的输出中，我们可以大概区分为几个字段，现以范例一当中那行特殊字体行来说明一下：\n· 01:33:40.41：这个是此数据包被捕获的时间，“时:分:秒”的单位。\n· IP：通过的通信协议是IP。\n· 192.168.1.100.22>：传送端是192.168.1.100这个IP，而传送的Port Number为22，那个大于（>）的符号指的是数据包的传输方向。\n· 192.168.1.11.1190：接收端的IP是192.168.1.11，且该主机开启port 1190来接收。\n· P 116:232(116)：这个数据包带有PUSH的数据传输标志，且传输的数据为整体数据的116~232 Byte，所以这个数据包带有116 Bytes的数据量。\n· ack 1 win 9648：ACK与Window size的相关资料。\n最简单的说法，就是该数据包是由192.168.1.100传到192.168.1.11，通过的port是由22到1190，且带有116 Bytes的数据量，使用的是PUSH的标记，而不是SYN之类的主动联机标志。\n接下来，在一个网络状态很忙的主机上面，你想要取得某台主机对你联机的数据包数据时，使用tcpdump配合管线命令与正则表达式也可以，不过，毕竟不好捕获。我们可以通过tcpdump的表达式功能，就能够轻易地将所需要的数据独立的取出来。在上面的范例一当中，我们仅针对eth0做监听，所以整个eth0接口上面的数据都会被显示到屏幕上，但这样不好分析，可以简化吗？例如，只取出port 21的联机数据包，可以这样做：\n[root@linux ~]# tcpdump -i eth0 -nn port 21\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes\n01:54:37.96 IP 192.168.1.11.1240 > 192.168.1.100.21:. ack 1 win 65535\n01:54:37.96 IP 192.168.1.100.21 > 192.168.1.11.1240:P 1:21(20) ack 1 win 5840\n01:54:38.12 IP 192.168.1.11.1240 > 192.168.1.100.21:. ack 21 win 65515\n01:54:42.79 IP 192.168.1.11.1240 > 192.168.1.100.21:P 1:17(16) ack 21 win 65515\n01:54:42.79 IP 192.168.1.100.21 > 192.168.1.11.1240: . ack 17 win 5840\n01:54:42.79 IP 192.168.1.100.21 > 192.168.1.11.1240: P 21:55(34) ack 17 win 5840\n看！这样就仅取出port 21的信息，如果仔细看的话，你会发现数据包的传递都是双向的，Client端发出请求而Server端则予以响应，所以，当然是有去有回了。而我们也就可以经过这个数据包的流向来了解到数据包运动的过程了。例如：\n· 我们先在一个终端机窗口输入“tcpdump-i lo-nn”的监听。\n· 再另开一个终端机窗口来对本机（127.0.0.1）登录“ssh localhost”，那么输出的结果会是如何？\n[root@linux ~]# tcpdump -i lo -nn\n 1 tcpdump: verbose output suppressed, use -v or -vv for full protocol decode\n 2 listening on lo, link-type EN10MB (Ethernet), capture size 96 bytes\n 3 11:02:54.253777 IP 127.0.0.1.32936 > \n127.0.0.1.22: S 933696132:933696132(0) \n   win 32767 \n 4 11:02:54.253831 IP 127.0.0.1.22 > 127.0.0.1.32936: \nS 920046702:920046702(0) \n   ack 933696133 win 32767 \n 5 11:02:54.253871 IP 127.0.0.1.32936 > 127.0.0.1.22: . ack 1 win 8192 \n 6 11:02:54.272124 IP 127.0.0.1.22 > 127.0.0.1.32936: \nP 1:23(22) ack 1 win 8192 \n   \n 7 11:02:54.272375 IP 127.0.0.1.32936 > 127.0.0.1.22: . ack 23 win 8192\n代码显示的头两行是tcpdump的基本说明，然后：\n· 第3行显示的是来自Client端带有SYN主动联机的数据包。 \n· 第4行显示的是来自Server端，除了响应Client端之外（ACK），还带有SYN主动联机的标志。 \n· 第5行则显示Client端响应Server确定联机建立（ACK）。\n· 第6行以后则开始进入数据传输的步骤。\n从第3~5行的流程来看，熟不熟悉啊？没错。那就是3次握手的基础流程，有趣吧。不过tcpdump之所以被称为黑客软件之一远不止上面介绍的功能。上面介绍的功能可以用来作为我们主机的数据包联机与传输的流程分析，这将有助于我们了解到数据包的运作，同时了解到主机的防火墙设置规则是否有需要修订的地方。\n还有更神奇的用法。当我们使用tcpdump在Router上面监听明文的传输数据时，例如FTP传输协议，你觉得会发生什么问题呢？我们先在主机端执行“tcpdump -i lo port 21 -nn –X”，然后再以FTP登录本机，并输入账号与密码，结果你就可以发现如下的状况：\n[root@linux ~]# tcpdump -i lo -nn -X 'port 21'\n    0x0000:  4500 0048 2a28 4000 4006 1286 7f00 0001  E..H*(@.@.......\n    0x0010:  7f00 0001 0015 80ab 8355 2149 835c d825  .........U!I.\\.%\n    0x0020:  8018 2000 fe3c 0000 0101 080a 0e2e 0b67  .....<.........g\n    0x0030:  0e2e 0b61 3232 3020 2876 7346 5450 6420  ...a220.(vsFTPd.\n    0x0040:  322e 302e 3129 0d0a                      2.0.1)..\n\n    0x0000:  4510 0041 d34b 4000 4006 6959 7f00 0001  E..A.K@.@.iY....\n    0x0010:  7f00 0001 80ab 0015 835c d825 8355 215d  .........\\.%.U!]\n    0x0020:  8018 2000 fe35 0000 0101 080a 0e2e 1b37  .....5.........7\n    0x0030:  0e2e 0b67 5553 4552 2064 6d74 7361 690d  ...gUSER.dmtsai.\n    0x0040:  0a                                       .\n\n    0x0000:  4510 004a d34f 4000 4006 694c 7f00 0001  E..J.O@.@.iL....\n    0x0010:  7f00 0001 80ab 0015 835c d832 8355 217f  .........\\.2.U!.\n    0x0020:  8018 2000 fe3e 0000 0101 080a 0e2e 3227  .....>........2'\n    0x0030:  0e2e 1b38 5041 5353 206d 7970 6173 7377  ...8PASS.mypassw\n    0x0040:  6f72 6469 7379 6f75 0d0a                 ordisyou..\n上面的输出结果已经被简化过了，你需要自行在你的输出结果中搜索相关的字符串才行。从上面输出结果的特殊字体中，我们可以发现该FTP软件使用的是 vsFTPd，并且用户输入dmtsai这个账号名称，且密码是mypasswordisyou。如果使用的是明文方式来传输你的网络数据呢？\n另外你得了解，为了让网络接口可以让tcpdump监听，所以执行tcpdump时网络接口会启动在“混杂模式（promiscuous）”，所以你会在 /var/log/messages里面看到很多的警告信息，通知你说你的网卡被设置成为混杂模式。别担心，那是正常的。至于更多的应用，请参考man tcpdump了。\n\n例题：如何使用tcpdump监听来自eth0适配卡且通信协议为port 22，目标来源为192.168.1.100的数据包资料？\n答：tcpdump -i eth0 -nn 'port 22 and src host 192.168.1.100'。\n##############例子2#######################################\n \n普通情况下，直接启动tcpdump将监视第一个网络界面上所有流过的数据包。\n# tcpdump\ntcpdump: listening on fxp0\n11:58:47.873028 202.102.245.40.netbios-ns > 202.102.245.127.netbios-ns: udp 50\n11:58:47.974331 0:10:7b:8:3a:56 > 1:80:c2:0:0:0 802.1d ui/C len=43\n0000 0000 0080 0000 1007 cf08 0900 0000\n0e80 0000 902b 4695 0980 8701 0014 0002\n000f 0000 902b 4695 0008 00\n11:58:48.373134 0:0:e8:5b:6d:85 > Broadcast sap e0 ui/C len=97\nffff 0060 0004 ffff ffff ffff ffff ffff\n0452 ffff ffff 0000 e85b 6d85 4008 0002\n0640 4d41 5354 4552 5f57 4542 0000 0000\n0000 00\n使用-i参数指定tcpdump监听的网络界面，这在计算机具有多个网络界面时非常有用，\n使用-c参数指定要监听的数据包数量，\n使用-w参数指定将监听到的数据包写入文件中保存\nA想要截获所有210.27.48.1 的主机收到的和发出的所有的数据包：\n#tcpdump host 210.27.48.1\nB想要截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信，使用命令：（在命令行中适用　　　括号时，一定要\n#tcpdump host 210.27.48.1 and \\ (210.27.48.2 or 210.27.48.3 \\)\nC如果想要获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包，使用命令：\n#tcpdump ip host 210.27.48.1 and ! 210.27.48.2\nD如果想要获取主机210.27.48.1接收或发出的telnet包，使用如下命令：\n#tcpdump tcp port 23 host 210.27.48.1\nE 对本机的udp 123 端口进行监视 123 为ntp的服务端口\n# tcpdump udp port 123\nF 系统将只对名为hostname的主机的通信数据包进行监视。主机名可以是本地主机，也可以是网络上的任何一台计算机。下面的命令可以读取主机hostname发送的所有数据：\n#tcpdump -i eth0 src host hostname\nG 下面的命令可以监视所有送到主机hostname的数据包：\n#tcpdump -i eth0 dst host hostname\nH 我们还可以监视通过指定网关的数据包：\n#tcpdump -i eth0 gateway Gatewayname\nI 如果你还想监视编址到指定端口的TCP或UDP数据包，那么执行以下命令：\n#tcpdump -i eth0 host hostname and port 80\nJ 如果想要获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包\n，使用命令：\n#tcpdump ip host 210.27.48.1 and ! 210.27.48.2\nK 想要截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信，使用命令\n：（在命令行中适用　　　括号时，一定要\n#tcpdump host 210.27.48.1 and \\ (210.27.48.2 or 210.27.48.3 \\)\nL 如果想要获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包，使用命令：\n#tcpdump ip host 210.27.48.1 and ! 210.27.48.2\nM 如果想要获取主机210.27.48.1接收或发出的telnet包，使用如下命令：\n#tcpdump tcp port 23 host 210.27.48.1\n第三种是协议的关键字，主要包括fddi,ip ,arp,rarp,tcp,udp等类型\n除了这三种类型的关键字之外，其他重要的关键字如下：gateway, broadcast,less,\ngreater,还有三种逻辑运算，取非运算是 ‘not ‘ ‘! ‘, 与运算是‘and‘,‘&&‘;或运算 是‘o\nr‘ ,‘||‘；\n第二种是确定传输方向的关键字，主要包括src , dst ,dst or src, dst and src ,\n如果我们只需要列出送到80端口的数据包，用dst port；如果我们只希望看到返回80端口的数据包，用src port。\n#tcpdump –i eth0 host hostname and dst port 80 目的端口是80\n或者\n#tcpdump –i eth0 host hostname and src port 80 源端口是80 一般是提供http的服务的主机\n如果条件很多的话 要在条件之前加and 或 or 或 not\n#tcpdump -i eth0 host ! 211.161.223.70 and ! 211.161.223.71 and dst port 80\n如果在ethernet 使用混杂模式 系统的日志将会记录\nMay 7 20:03:46 localhost kernel: eth0: Promiscuous mode enabled.\nMay 7 20:03:46 localhost kernel: device eth0 entered promiscuous mode\nMay 7 20:03:57 localhost kernel: device eth0 left promiscuous mode\ntcpdump对截获的数据并没有进行彻底解码，数据包内的大部分内容是使用十六进制的形式直接打印输出的。显然这不利于分析网络故障，通常的解决办法是先使用带-w参数的tcpdump 截获数据并保存到文件中，然后再使用其他程序进行解码分析。当然也应该定义过滤规则，以避免捕获的数据包填满整个硬盘。\n除了过滤语句，还有一个很重要的参数，也就是说，如果这个参数不设置正确，会导致包数据的丢失！\n它就是-s 参数，snaplen, 也就是数据包的截取长度，仔细看man就会明白的！默认截取长度为60个字节，但一般ethernet MTU都是1500字节。所以，要抓取大于60字节的包时，使用默认参数就会导致包数据丢失！\n只要使用-s 0就可以按包长，截取数据！","slug":"tcpdump抓包命令详解","published":1,"updated":"2017-03-01T05:59:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizqklz7z000clbpvfkn3ye1e","content":"<p>TCPdump抓包命令<br>tcpdump是一个用于截取网络分组，并输出分组内容的工具。tcpdump凭借强大的功能和灵活的截取策略，使其成为类UNIX系统下用于网络分析和问题排查的首选工具。<br>tcpdump提供了源代码，公开了接口，因此具备很强的可扩展性，对于网络维护和入侵者都是非常有用的工具。tcpdump存在于基本的Linux系统中，由于它需要将网络界面设置为混杂模式，普通用户不能正常执行，但具备root权限的用户可以直接执行它来获取网络上的信息。因此系统中存在网络分析工具主要不是对本机安全的威胁，而是对网络上的其他计算机的安全存在威胁。<br><a id=\"more\"></a><br>一、概述<br>顾名思义，tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。<br>引用</p>\n<h1 id=\"tcpdump-vv\"><a href=\"#tcpdump-vv\" class=\"headerlink\" title=\"tcpdump -vv\"></a>tcpdump -vv</h1><p>tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes<br>11:53:21.444591 IP (tos 0x10, ttl 64, id 19324, offset 0, flags [DF], proto 6, length: 92) asptest.localdomain.ssh &gt; 192.168.228.244.1858: P 3962132600:3962132652(52) ack 2726525936 win 1266<br>asptest.localdomain.1077 &gt; 192.168.228.153.domain: [bad udp cksum 166e!] 325+ PTR? 244.228.168.192.in-addr.arpa. (46)<br>11:53:21.446929 IP (tos 0x0, ttl 64, id 42911, offset 0, flags [DF], proto 17, length: 151) 192.168.228.153.domain &gt; asptest.localdomain.1077: 325 NXDomain q: PTR? 244.228.168.192.in-addr.arpa. 0/1/0 ns: 168.192.in-addr.arpa. (123)<br>11:53:21.447408 IP (tos 0x10, ttl 64, id 19328, offset 0, flags [DF], proto 6, length: 172) asptest.localdomain.ssh &gt; 192.168.228.244.1858: P 168:300(132) ack 1 win 1266<br>347 packets captured<br>1474 packets received by filter<br>745 packets dropped by kernel<br>不带参数的tcpdump会收集网络中所有的信息包头，数据量巨大，必须过滤。</p>\n<p>二、选项介绍<br>引用<br>-A 以ASCII格式打印出所有分组，并将链路层的头最小化。<br>-c 在收到指定的数量的分组后，tcpdump就会停止。<br>-C 在将一个原始分组写入文件之前，检查文件当前的大小是否超过了参数file_size 中指定的大小。如果超过了指定大小，则关闭当前文件，然后在打开一个新的文件。参数 file_size 的单位是兆字节（是1,000,000字节，而不是1,048,576字节）。<br>-d 将匹配信息包的代码以人们能够理解的汇编格式给出。<br>-dd 将匹配信息包的代码以C语言程序段的格式给出。<br>-ddd 将匹配信息包的代码以十进制的形式给出。<br>-D 打印出系统中所有可以用tcpdump截包的网络接口。<br>-e 在输出行打印出数据链路层的头部信息。<br>-E 用spi@ipaddr algo:secret解密那些以addr作为地址，并且包含了安全参数索引值spi的IPsec ESP分组。<br>-f 将外部的Internet地址以数字的形式打印出来。<br>-F 从指定的文件中读取表达式，忽略命令行中给出的表达式。<br>-i 指定监听的网络接口。<br>-l 使标准输出变为缓冲行形式，可以把数据导出到文件。<br>-L 列出网络接口的已知数据链路。<br>-m 从文件module中导入SMI MIB模块定义。该参数可以被使用多次，以导入多个MIB模块。<br>-M 如果tcp报文中存在TCP-MD5选项，则需要用secret作为共享的验证码用于验证TCP-MD5选选项摘要（详情可参考RFC 2385）。<br>-b 在数据-链路层上选择协议，包括ip、arp、rarp、ipx都是这一层的。<br>-n 不把网络地址转换成名字。<br>-nn 不进行端口名称的转换。<br>-N 不输出主机名中的域名部分。例如，‘nic.ddn.mil‘只输出’nic‘。<br>-t 在输出的每一行不打印时间戳。<br>-O 不运行分组分组匹配（packet-matching）代码优化程序。<br>-P 不将网络接口设置成混杂模式。<br>-q 快速输出。只输出较少的协议信息。<br>-r 从指定的文件中读取包(这些包一般通过-w选项产生)。<br>-S 将tcp的序列号以绝对值形式输出，而不是相对值。<br>-s 从每个分组中读取最开始的snaplen个字节，而不是默认的68个字节。<br>-T 将监听到的包直接解释为指定的类型的报文，常见的类型有rpc远程过程调用）和snmp（简单网络管理协议；）。<br>-t 不在每一行中输出时间戳。<br>-tt 在每一行中输出非格式化的时间戳。<br>-ttt 输出本行和前面一行之间的时间差。<br>-tttt 在每一行中输出由date处理的默认格式的时间戳。<br>-u 输出未解码的NFS句柄。<br>-v 输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息。<br>-vv 输出详细的报文信息。<br>-w 直接将分组写入文件中，而不是不分析并打印出来。</p>\n<p>三、tcpdump的表达式介绍<br>表达式是一个正则表达式，tcpdump利用它作为过滤报文的条件，如果一个报文满足表 达式的条件，则这个报文将会被捕获。如果没有给出任何条件，则网络上所有的信息包 将会被截获。<br>在表达式中一般如下几种类型的关键字：<br>引用<br>第一种是关于类型的关键字，主要包括host，net，port，例如 host 210.27.48.2， 指明 210.27.48.2是一台主机，net 202.0.0.0指明202.0.0.0是一个网络地址，port 23 指明端口号是23。如果没有指定类型，缺省的类型是host。<br>第二种是确定传输方向的关键字，主要包括src，dst，dst or src，dst and src， 这些关键字指明了传输的方向。举例说明，src 210.27.48.2 ，指明ip包中源地址是 210.27.48.2 ， dst net 202.0.0.0 指明目的网络地址是202.0.0.0。如果没有指明 方向关键字，则缺省是src or dst关键字。<br>第三种是协议的关键字，主要包括fddi，ip，arp，rarp，tcp，udp等类型。Fddi指明是在FDDI (分布式光纤数据接口网络)上的特定的网络协议，实际上它是”ether”的别名，fddi和ether 具有类似的源地址和目的地址，所以可以将fddi协议包当作ether的包进行处理和分析。 其他的几个关键字就是指明了监听的包的协议内容。如果没有指定任何协议，则tcpdump 将会 监听所有协议的信息包。<br>除了这三种类型的关键字之外，其他重要的关键字如下：gateway， broadcast，less， greater， 还有三种逻辑运算，取非运算是 ‘not ‘ ‘! ‘， 与运算是’and’，’&amp;&amp;’;或运算是’or’ ，’&#124;&#124;’； 这些关键字可以组合起来构成强大的组合条件来满足人们的需要。<br>四、输出结果介绍<br>下面我们介绍几种典型的tcpdump命令的输出信息<br>(1) 数据链路层头信息<br>使用命令： </p>\n<p>#tcpdump –e host ICE<br>ICE 是一台装有linux的主机。它的MAC地址是0：90：27：58：AF：1A H219是一台装有Solaris的SUN工作站。它的MAC地址是8：0：20：79：5B：46； 上一条命令的输出结果如下所示：<br>引用<br>21:50:12.847509 eth0 &lt; 8:0:20:79:5b:46 0:90:27:58:af:1a ip 60: h219.33357 &gt; ICE. telne t 0:0(0) ack 22535 win 8760 (DF)<br>21：50：12是显示的时间， 847509是ID号，eth0 &lt;表示从网络接口eth0接收该分组， eth0 &gt;表示从网络接口设备发送分组， 8:0:20:79:5b:46是主机H219的MAC地址， 它表明是从源地址H219发来的分组. 0:90:27:58:af:1a是主机ICE的MAC地址， 表示该分组的目的地址是ICE。 ip 是表明该分组是IP分组，60 是分组的长度， h219.33357 &gt; ICE. telnet 表明该分组是从主机H219的33357端口发往主机ICE的 TELNET(23)端口。 ack 22535 表明对序列号是222535的包进行响应。 win 8760表明发 送窗口的大小是8760。<br>(2) ARP包的tcpdump输出信息<br>使用命令： </p>\n<p>#tcpdump arp<br>得到的输出结果是：<br>引用<br>22:32:42.802509 eth0 &gt; arp who-has route tell ICE (0:90:27:58:af:1a)<br>22:32:42.802902 eth0 &lt; arp reply route is-at 0:90:27:12:10:66 (0:90:27:58:af:1a)<br>22:32:42是时间戳， 802509是ID号， eth0 &gt;表明从主机发出该分组，arp表明是ARP请求包， who-has route tell ICE表明是主机ICE请求主机route的MAC地址。 0:90:27:58:af:1a是主机 ICE的MAC地址。<br>(3) TCP包的输出信息<br>用tcpdump捕获的TCP包的一般输出信息是：<br>引用<br>src &gt; dst: flags data-seqno ack window urgent options<br>src &gt; dst:表明从源地址到目的地址， flags是TCP报文中的标志信息，S 是SYN标志， F (FIN)， P (PUSH) ， R (RST) “.” (没有标记); data-seqno是报文中的数据 的顺序号， ack是下次期望的顺序号， window是接收缓存的窗口大小， urgent表明 报文中是否有紧急指针。 Options是选项。<br>(4) UDP包的输出信息<br>用tcpdump捕获的UDP包的一般输出信息是：<br>引用<br>route.port1 &gt; ICE.port2: udp lenth<br>UDP十分简单，上面的输出行表明从主机route的port1端口发出的一个UDP报文 到主机ICE的port2端口，类型是UDP， 包的长度是lenth。<br>五、举例<br>(1) 想要截获所有210.27.48.1 的主机收到的和发出的所有的分组： </p>\n<p>#tcpdump host 210.27.48.1<br>(2) 想要截获主机210.27.48.1 和主机210.27.48.2或210.27.48.3的通信，使用命令（注意：括号前的反斜杠是必须的）： </p>\n<p>#tcpdump host 210.27.48.1 and 210.27.48.2or210.27.48.3<br>(3) 如果想要获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包，使用命令： </p>\n<p>#tcpdump ip host 210.27.48.1 and ! 210.27.48.2<br>(4) 如果想要获取主机192.168.228.246接收或发出的ssh包，并且不转换主机名使用如下命令： </p>\n<p>#tcpdump -nn -n src host 192.168.228.246 and port 22 and tcp<br>(5) 获取主机192.168.228.246接收或发出的ssh包，并把mac地址也一同显示：</p>\n<h1 id=\"tcpdump-e-src-host-192-168-228-246-and-port-22-and-tcp-n-nn\"><a href=\"#tcpdump-e-src-host-192-168-228-246-and-port-22-and-tcp-n-nn\" class=\"headerlink\" title=\"tcpdump -e src host 192.168.228.246 and port 22 and tcp -n -nn\"></a>tcpdump -e src host 192.168.228.246 and port 22 and tcp -n -nn</h1><p>(6) 过滤的是源主机为192.168.0.1与目的网络为192.168.0.0的报头：<br>tcpdump src host 192.168.0.1 and dst net 192.168.0.0/24<br>(7) 过滤源主机物理地址为XXX的报头：<br>tcpdump ether src 00:50:04:BA:9B and dst……<br>（为什么ether src后面没有host或者net？物理地址当然不可能有网络喽）。<br>(8) 过滤源主机192.168.0.1和目的端口不是telnet的报头，并导入到tes.t.txt文件中：<br>Tcpdump src host 192.168.0.1 and dst port not telnet -l &gt; test.txt<br>ip icmp arp rarp 和 tcp、udp、icmp这些选项等都要放到第一个参数的位置，用来过滤数据报的类型。<br>tcpdump采用命令行方式，它的命令格式为：<br>tcpdump [-nn] [-i 接口] [-w 储存档名] [-c 次数] [-Ae]<br>                        [-qX] [-r 文件] [所欲捕获的数据内容]<br>参数：<br>-nn，直接以 IP 及 Port Number 显示，而非主机名与服务名称。<br>-i，后面接要「监听」的网络接口，例如 eth0, lo, ppp0 等等的接口。<br>-w，如果你要将监听所得的数据包数据储存下来，用这个参数就对了。后面接文件名。<br>-c，监听的数据包数，如果没有这个参数， tcpdump 会持续不断的监听，<br>     直到用户输入 [ctrl]-c 为止。<br>-A，数据包的内容以 ASCII 显示，通常用来捉取 WWW 的网页数据包资料。<br>-e，使用资料连接层 (OSI 第二层) 的 MAC 数据包数据来显示。<br>-q，仅列出较为简短的数据包信息，每一行的内容比较精简。<br>-X，可以列出十六进制 (hex) 以及 ASCII 的数据包内容，对于监听数据包内容很有用。<br>-r，从后面接的文件将数据包数据读出来。那个「文件」是已经存在的文件，<br>     并且这个「文件」是由 -w 所制作出来的。<br>所欲捕获的数据内容：我们可以专门针对某些通信协议或者是 IP 来源进行数据包捕获。<br>     那就可以简化输出的结果，并取得最有用的信息。常见的表示方法有。<br>    ‘host foo’, ‘host 127.0.0.1’ ：针对单台主机来进行数据包捕获。<br>     ‘net 192.168’ ：针对某个网段来进行数据包的捕获。<br>     ‘src host 127.0.0.1’ ‘dst net 192.168’：同时加上来源(src)或目标(dst)限制。<br>     ‘tcp port 21’：还可以针对通信协议检测，如tcp、udp、arp、ether 等。<br>     除了这三种类型的关键字之外，其他重要的关键字如下：gateway, broadcast,less,<br>greater,还有三种逻辑运算，取非运算是 ‘not ‘ ‘! ‘, 与运算是’and’,’&amp;&amp;’;或运算 是’o<br>r’ ,’||’；</p>\n<p>范例一：以 IP 与 Port Number 捉下 eth0 这个网卡上的数据包，持续 3 秒<br>[root@linux ~]# tcpdump -i eth0 -nn<br>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes<br>01:33:40.41 IP 192.168.1.100.22 &gt; 192.168.1.11.1190: P 116:232(116) ack 1 win<br>9648<br>01:33:40.41 IP 192.168.1.100.22 &gt; 192.168.1.11.1190: P 232:364(132) ack 1 win<br>9648<br>&lt;==按下 [ctrl]-c 之后结束<br>6680 packets captured              &lt;==捉取下来的数据包数量<br>14250 packets received by filter   &lt;==由过滤所得的总数据包数量<br>7512 packets dropped by kernel     &lt;==被核心所丢弃的数据包<br>至于那个在范例一所产生的输出中，我们可以大概区分为几个字段，现以范例一当中那行特殊字体行来说明一下：<br>· 01:33:40.41：这个是此数据包被捕获的时间，“时:分:秒”的单位。<br>· IP：通过的通信协议是IP。<br>· 192.168.1.100.22&gt;：传送端是192.168.1.100这个IP，而传送的Port Number为22，那个大于（&gt;）的符号指的是数据包的传输方向。<br>· 192.168.1.11.1190：接收端的IP是192.168.1.11，且该主机开启port 1190来接收。<br>· P 116:232(116)：这个数据包带有PUSH的数据传输标志，且传输的数据为整体数据的116~232 Byte，所以这个数据包带有116 Bytes的数据量。<br>· ack 1 win 9648：ACK与Window size的相关资料。<br>最简单的说法，就是该数据包是由192.168.1.100传到192.168.1.11，通过的port是由22到1190，且带有116 Bytes的数据量，使用的是PUSH的标记，而不是SYN之类的主动联机标志。<br>接下来，在一个网络状态很忙的主机上面，你想要取得某台主机对你联机的数据包数据时，使用tcpdump配合管线命令与正则表达式也可以，不过，毕竟不好捕获。我们可以通过tcpdump的表达式功能，就能够轻易地将所需要的数据独立的取出来。在上面的范例一当中，我们仅针对eth0做监听，所以整个eth0接口上面的数据都会被显示到屏幕上，但这样不好分析，可以简化吗？例如，只取出port 21的联机数据包，可以这样做：<br>[root@linux ~]# tcpdump -i eth0 -nn port 21<br>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes<br>01:54:37.96 IP 192.168.1.11.1240 &gt; 192.168.1.100.21:. ack 1 win 65535<br>01:54:37.96 IP 192.168.1.100.21 &gt; 192.168.1.11.1240:P 1:21(20) ack 1 win 5840<br>01:54:38.12 IP 192.168.1.11.1240 &gt; 192.168.1.100.21:. ack 21 win 65515<br>01:54:42.79 IP 192.168.1.11.1240 &gt; 192.168.1.100.21:P 1:17(16) ack 21 win 65515<br>01:54:42.79 IP 192.168.1.100.21 &gt; 192.168.1.11.1240: . ack 17 win 5840<br>01:54:42.79 IP 192.168.1.100.21 &gt; 192.168.1.11.1240: P 21:55(34) ack 17 win 5840<br>看！这样就仅取出port 21的信息，如果仔细看的话，你会发现数据包的传递都是双向的，Client端发出请求而Server端则予以响应，所以，当然是有去有回了。而我们也就可以经过这个数据包的流向来了解到数据包运动的过程了。例如：<br>· 我们先在一个终端机窗口输入“tcpdump-i lo-nn”的监听。<br>· 再另开一个终端机窗口来对本机（127.0.0.1）登录“ssh localhost”，那么输出的结果会是如何？<br>[root@linux ~]# tcpdump -i lo -nn<br> 1 tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br> 2 listening on lo, link-type EN10MB (Ethernet), capture size 96 bytes<br> 3 11:02:54.253777 IP 127.0.0.1.32936 &gt;<br>127.0.0.1.22: S 933696132:933696132(0)<br>   win 32767<br> 4 11:02:54.253831 IP 127.0.0.1.22 &gt; 127.0.0.1.32936:<br>S 920046702:920046702(0)<br>   ack 933696133 win 32767<br> 5 11:02:54.253871 IP 127.0.0.1.32936 &gt; 127.0.0.1.22: . ack 1 win 8192<br> 6 11:02:54.272124 IP 127.0.0.1.22 &gt; 127.0.0.1.32936:<br>P 1:23(22) ack 1 win 8192 </p>\n<p> 7 11:02:54.272375 IP 127.0.0.1.32936 &gt; 127.0.0.1.22: . ack 23 win 8192<br>代码显示的头两行是tcpdump的基本说明，然后：<br>· 第3行显示的是来自Client端带有SYN主动联机的数据包。<br>· 第4行显示的是来自Server端，除了响应Client端之外（ACK），还带有SYN主动联机的标志。<br>· 第5行则显示Client端响应Server确定联机建立（ACK）。<br>· 第6行以后则开始进入数据传输的步骤。<br>从第3~5行的流程来看，熟不熟悉啊？没错。那就是3次握手的基础流程，有趣吧。不过tcpdump之所以被称为黑客软件之一远不止上面介绍的功能。上面介绍的功能可以用来作为我们主机的数据包联机与传输的流程分析，这将有助于我们了解到数据包的运作，同时了解到主机的防火墙设置规则是否有需要修订的地方。<br>还有更神奇的用法。当我们使用tcpdump在Router上面监听明文的传输数据时，例如FTP传输协议，你觉得会发生什么问题呢？我们先在主机端执行“tcpdump -i lo port 21 -nn –X”，然后再以FTP登录本机，并输入账号与密码，结果你就可以发现如下的状况：<br>[root@linux ~]# tcpdump -i lo -nn -X ‘port 21’<br>    0x0000:  4500 0048 2a28 4000 4006 1286 7f00 0001  E..H*(@.@…….<br>    0x0010:  7f00 0001 0015 80ab 8355 2149 835c d825  ………U!I..%<br>    0x0020:  8018 2000 fe3c 0000 0101 080a 0e2e 0b67  …..&lt;………g<br>    0x0030:  0e2e 0b61 3232 3020 2876 7346 5450 6420  …a220.(vsFTPd.<br>    0x0040:  322e 302e 3129 0d0a                      2.0.1)..</p>\n<pre><code>0x0000:  4510 0041 d34b 4000 4006 6959 7f00 0001  E..A.K@.@.iY....\n0x0010:  7f00 0001 80ab 0015 835c d825 8355 215d  .........\\.%.U!]\n0x0020:  8018 2000 fe35 0000 0101 080a 0e2e 1b37  .....5.........7\n0x0030:  0e2e 0b67 5553 4552 2064 6d74 7361 690d  ...gUSER.dmtsai.\n0x0040:  0a                                       .\n\n0x0000:  4510 004a d34f 4000 4006 694c 7f00 0001  E..J.O@.@.iL....\n0x0010:  7f00 0001 80ab 0015 835c d832 8355 217f  .........\\.2.U!.\n0x0020:  8018 2000 fe3e 0000 0101 080a 0e2e 3227  .....&gt;........2&apos;\n0x0030:  0e2e 1b38 5041 5353 206d 7970 6173 7377  ...8PASS.mypassw\n0x0040:  6f72 6469 7379 6f75 0d0a                 ordisyou..\n</code></pre><p>上面的输出结果已经被简化过了，你需要自行在你的输出结果中搜索相关的字符串才行。从上面输出结果的特殊字体中，我们可以发现该FTP软件使用的是 vsFTPd，并且用户输入dmtsai这个账号名称，且密码是mypasswordisyou。如果使用的是明文方式来传输你的网络数据呢？<br>另外你得了解，为了让网络接口可以让tcpdump监听，所以执行tcpdump时网络接口会启动在“混杂模式（promiscuous）”，所以你会在 /var/log/messages里面看到很多的警告信息，通知你说你的网卡被设置成为混杂模式。别担心，那是正常的。至于更多的应用，请参考man tcpdump了。</p>\n<p>例题：如何使用tcpdump监听来自eth0适配卡且通信协议为port 22，目标来源为192.168.1.100的数据包资料？<br>答：tcpdump -i eth0 -nn ‘port 22 and src host 192.168.1.100’。</p>\n<p>##############例子2#######################################</p>\n<p>普通情况下，直接启动tcpdump将监视第一个网络界面上所有流过的数据包。</p>\n<h1 id=\"tcpdump\"><a href=\"#tcpdump\" class=\"headerlink\" title=\"tcpdump\"></a>tcpdump</h1><p>tcpdump: listening on fxp0<br>11:58:47.873028 202.102.245.40.netbios-ns &gt; 202.102.245.127.netbios-ns: udp 50<br>11:58:47.974331 0:10:7b:8:3a:56 &gt; 1:80:c2:0:0:0 802.1d ui/C len=43<br>0000 0000 0080 0000 1007 cf08 0900 0000<br>0e80 0000 902b 4695 0980 8701 0014 0002<br>000f 0000 902b 4695 0008 00<br>11:58:48.373134 0:0:e8:5b:6d:85 &gt; Broadcast sap e0 ui/C len=97<br>ffff 0060 0004 ffff ffff ffff ffff ffff<br>0452 ffff ffff 0000 e85b 6d85 4008 0002<br>0640 4d41 5354 4552 5f57 4542 0000 0000<br>0000 00<br>使用-i参数指定tcpdump监听的网络界面，这在计算机具有多个网络界面时非常有用，<br>使用-c参数指定要监听的数据包数量，<br>使用-w参数指定将监听到的数据包写入文件中保存<br>A想要截获所有210.27.48.1 的主机收到的和发出的所有的数据包：</p>\n<p>#tcpdump host 210.27.48.1<br>B想要截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信，使用命令：（在命令行中适用　　　括号时，一定要</p>\n<p>#tcpdump host 210.27.48.1 and \\ (210.27.48.2 or 210.27.48.3 )<br>C如果想要获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包，使用命令：</p>\n<p>#tcpdump ip host 210.27.48.1 and ! 210.27.48.2<br>D如果想要获取主机210.27.48.1接收或发出的telnet包，使用如下命令：</p>\n<p>#tcpdump tcp port 23 host 210.27.48.1<br>E 对本机的udp 123 端口进行监视 123 为ntp的服务端口</p>\n<h1 id=\"tcpdump-udp-port-123\"><a href=\"#tcpdump-udp-port-123\" class=\"headerlink\" title=\"tcpdump udp port 123\"></a>tcpdump udp port 123</h1><p>F 系统将只对名为hostname的主机的通信数据包进行监视。主机名可以是本地主机，也可以是网络上的任何一台计算机。下面的命令可以读取主机hostname发送的所有数据：</p>\n<p>#tcpdump -i eth0 src host hostname<br>G 下面的命令可以监视所有送到主机hostname的数据包：</p>\n<p>#tcpdump -i eth0 dst host hostname<br>H 我们还可以监视通过指定网关的数据包：</p>\n<p>#tcpdump -i eth0 gateway Gatewayname<br>I 如果你还想监视编址到指定端口的TCP或UDP数据包，那么执行以下命令：</p>\n<p>#tcpdump -i eth0 host hostname and port 80<br>J 如果想要获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包<br>，使用命令：</p>\n<p>#tcpdump ip host 210.27.48.1 and ! 210.27.48.2<br>K 想要截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信，使用命令<br>：（在命令行中适用　　　括号时，一定要</p>\n<p>#tcpdump host 210.27.48.1 and \\ (210.27.48.2 or 210.27.48.3 )<br>L 如果想要获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包，使用命令：</p>\n<p>#tcpdump ip host 210.27.48.1 and ! 210.27.48.2<br>M 如果想要获取主机210.27.48.1接收或发出的telnet包，使用如下命令：</p>\n<p>#tcpdump tcp port 23 host 210.27.48.1<br>第三种是协议的关键字，主要包括fddi,ip ,arp,rarp,tcp,udp等类型<br>除了这三种类型的关键字之外，其他重要的关键字如下：gateway, broadcast,less,<br>greater,还有三种逻辑运算，取非运算是 ‘not ‘ ‘! ‘, 与运算是‘and‘,‘&amp;&amp;‘;或运算 是‘o<br>r‘ ,‘||‘；<br>第二种是确定传输方向的关键字，主要包括src , dst ,dst or src, dst and src ,<br>如果我们只需要列出送到80端口的数据包，用dst port；如果我们只希望看到返回80端口的数据包，用src port。</p>\n<p>#tcpdump –i eth0 host hostname and dst port 80 目的端口是80<br>或者</p>\n<p>#tcpdump –i eth0 host hostname and src port 80 源端口是80 一般是提供http的服务的主机<br>如果条件很多的话 要在条件之前加and 或 or 或 not</p>\n<p>#tcpdump -i eth0 host ! 211.161.223.70 and ! 211.161.223.71 and dst port 80<br>如果在ethernet 使用混杂模式 系统的日志将会记录<br>May 7 20:03:46 localhost kernel: eth0: Promiscuous mode enabled.<br>May 7 20:03:46 localhost kernel: device eth0 entered promiscuous mode<br>May 7 20:03:57 localhost kernel: device eth0 left promiscuous mode<br>tcpdump对截获的数据并没有进行彻底解码，数据包内的大部分内容是使用十六进制的形式直接打印输出的。显然这不利于分析网络故障，通常的解决办法是先使用带-w参数的tcpdump 截获数据并保存到文件中，然后再使用其他程序进行解码分析。当然也应该定义过滤规则，以避免捕获的数据包填满整个硬盘。<br>除了过滤语句，还有一个很重要的参数，也就是说，如果这个参数不设置正确，会导致包数据的丢失！<br>它就是-s 参数，snaplen, 也就是数据包的截取长度，仔细看man就会明白的！默认截取长度为60个字节，但一般ethernet MTU都是1500字节。所以，要抓取大于60字节的包时，使用默认参数就会导致包数据丢失！<br>只要使用-s 0就可以按包长，截取数据！</p>\n","excerpt":"<p>TCPdump抓包命令<br>tcpdump是一个用于截取网络分组，并输出分组内容的工具。tcpdump凭借强大的功能和灵活的截取策略，使其成为类UNIX系统下用于网络分析和问题排查的首选工具。<br>tcpdump提供了源代码，公开了接口，因此具备很强的可扩展性，对于网络维护和入侵者都是非常有用的工具。tcpdump存在于基本的Linux系统中，由于它需要将网络界面设置为混杂模式，普通用户不能正常执行，但具备root权限的用户可以直接执行它来获取网络上的信息。因此系统中存在网络分析工具主要不是对本机安全的威胁，而是对网络上的其他计算机的安全存在威胁。<br>","more":"<br>一、概述<br>顾名思义，tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。<br>引用</p>\n<h1 id=\"tcpdump-vv\"><a href=\"#tcpdump-vv\" class=\"headerlink\" title=\"tcpdump -vv\"></a>tcpdump -vv</h1><p>tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes<br>11:53:21.444591 IP (tos 0x10, ttl 64, id 19324, offset 0, flags [DF], proto 6, length: 92) asptest.localdomain.ssh &gt; 192.168.228.244.1858: P 3962132600:3962132652(52) ack 2726525936 win 1266<br>asptest.localdomain.1077 &gt; 192.168.228.153.domain: [bad udp cksum 166e!] 325+ PTR? 244.228.168.192.in-addr.arpa. (46)<br>11:53:21.446929 IP (tos 0x0, ttl 64, id 42911, offset 0, flags [DF], proto 17, length: 151) 192.168.228.153.domain &gt; asptest.localdomain.1077: 325 NXDomain q: PTR? 244.228.168.192.in-addr.arpa. 0/1/0 ns: 168.192.in-addr.arpa. (123)<br>11:53:21.447408 IP (tos 0x10, ttl 64, id 19328, offset 0, flags [DF], proto 6, length: 172) asptest.localdomain.ssh &gt; 192.168.228.244.1858: P 168:300(132) ack 1 win 1266<br>347 packets captured<br>1474 packets received by filter<br>745 packets dropped by kernel<br>不带参数的tcpdump会收集网络中所有的信息包头，数据量巨大，必须过滤。</p>\n<p>二、选项介绍<br>引用<br>-A 以ASCII格式打印出所有分组，并将链路层的头最小化。<br>-c 在收到指定的数量的分组后，tcpdump就会停止。<br>-C 在将一个原始分组写入文件之前，检查文件当前的大小是否超过了参数file_size 中指定的大小。如果超过了指定大小，则关闭当前文件，然后在打开一个新的文件。参数 file_size 的单位是兆字节（是1,000,000字节，而不是1,048,576字节）。<br>-d 将匹配信息包的代码以人们能够理解的汇编格式给出。<br>-dd 将匹配信息包的代码以C语言程序段的格式给出。<br>-ddd 将匹配信息包的代码以十进制的形式给出。<br>-D 打印出系统中所有可以用tcpdump截包的网络接口。<br>-e 在输出行打印出数据链路层的头部信息。<br>-E 用spi@ipaddr algo:secret解密那些以addr作为地址，并且包含了安全参数索引值spi的IPsec ESP分组。<br>-f 将外部的Internet地址以数字的形式打印出来。<br>-F 从指定的文件中读取表达式，忽略命令行中给出的表达式。<br>-i 指定监听的网络接口。<br>-l 使标准输出变为缓冲行形式，可以把数据导出到文件。<br>-L 列出网络接口的已知数据链路。<br>-m 从文件module中导入SMI MIB模块定义。该参数可以被使用多次，以导入多个MIB模块。<br>-M 如果tcp报文中存在TCP-MD5选项，则需要用secret作为共享的验证码用于验证TCP-MD5选选项摘要（详情可参考RFC 2385）。<br>-b 在数据-链路层上选择协议，包括ip、arp、rarp、ipx都是这一层的。<br>-n 不把网络地址转换成名字。<br>-nn 不进行端口名称的转换。<br>-N 不输出主机名中的域名部分。例如，‘nic.ddn.mil‘只输出’nic‘。<br>-t 在输出的每一行不打印时间戳。<br>-O 不运行分组分组匹配（packet-matching）代码优化程序。<br>-P 不将网络接口设置成混杂模式。<br>-q 快速输出。只输出较少的协议信息。<br>-r 从指定的文件中读取包(这些包一般通过-w选项产生)。<br>-S 将tcp的序列号以绝对值形式输出，而不是相对值。<br>-s 从每个分组中读取最开始的snaplen个字节，而不是默认的68个字节。<br>-T 将监听到的包直接解释为指定的类型的报文，常见的类型有rpc远程过程调用）和snmp（简单网络管理协议；）。<br>-t 不在每一行中输出时间戳。<br>-tt 在每一行中输出非格式化的时间戳。<br>-ttt 输出本行和前面一行之间的时间差。<br>-tttt 在每一行中输出由date处理的默认格式的时间戳。<br>-u 输出未解码的NFS句柄。<br>-v 输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息。<br>-vv 输出详细的报文信息。<br>-w 直接将分组写入文件中，而不是不分析并打印出来。</p>\n<p>三、tcpdump的表达式介绍<br>表达式是一个正则表达式，tcpdump利用它作为过滤报文的条件，如果一个报文满足表 达式的条件，则这个报文将会被捕获。如果没有给出任何条件，则网络上所有的信息包 将会被截获。<br>在表达式中一般如下几种类型的关键字：<br>引用<br>第一种是关于类型的关键字，主要包括host，net，port，例如 host 210.27.48.2， 指明 210.27.48.2是一台主机，net 202.0.0.0指明202.0.0.0是一个网络地址，port 23 指明端口号是23。如果没有指定类型，缺省的类型是host。<br>第二种是确定传输方向的关键字，主要包括src，dst，dst or src，dst and src， 这些关键字指明了传输的方向。举例说明，src 210.27.48.2 ，指明ip包中源地址是 210.27.48.2 ， dst net 202.0.0.0 指明目的网络地址是202.0.0.0。如果没有指明 方向关键字，则缺省是src or dst关键字。<br>第三种是协议的关键字，主要包括fddi，ip，arp，rarp，tcp，udp等类型。Fddi指明是在FDDI (分布式光纤数据接口网络)上的特定的网络协议，实际上它是”ether”的别名，fddi和ether 具有类似的源地址和目的地址，所以可以将fddi协议包当作ether的包进行处理和分析。 其他的几个关键字就是指明了监听的包的协议内容。如果没有指定任何协议，则tcpdump 将会 监听所有协议的信息包。<br>除了这三种类型的关键字之外，其他重要的关键字如下：gateway， broadcast，less， greater， 还有三种逻辑运算，取非运算是 ‘not ‘ ‘! ‘， 与运算是’and’，’&amp;&amp;’;或运算是’or’ ，’&#124;&#124;’； 这些关键字可以组合起来构成强大的组合条件来满足人们的需要。<br>四、输出结果介绍<br>下面我们介绍几种典型的tcpdump命令的输出信息<br>(1) 数据链路层头信息<br>使用命令： </p>\n<p>#tcpdump –e host ICE<br>ICE 是一台装有linux的主机。它的MAC地址是0：90：27：58：AF：1A H219是一台装有Solaris的SUN工作站。它的MAC地址是8：0：20：79：5B：46； 上一条命令的输出结果如下所示：<br>引用<br>21:50:12.847509 eth0 &lt; 8:0:20:79:5b:46 0:90:27:58:af:1a ip 60: h219.33357 &gt; ICE. telne t 0:0(0) ack 22535 win 8760 (DF)<br>21：50：12是显示的时间， 847509是ID号，eth0 &lt;表示从网络接口eth0接收该分组， eth0 &gt;表示从网络接口设备发送分组， 8:0:20:79:5b:46是主机H219的MAC地址， 它表明是从源地址H219发来的分组. 0:90:27:58:af:1a是主机ICE的MAC地址， 表示该分组的目的地址是ICE。 ip 是表明该分组是IP分组，60 是分组的长度， h219.33357 &gt; ICE. telnet 表明该分组是从主机H219的33357端口发往主机ICE的 TELNET(23)端口。 ack 22535 表明对序列号是222535的包进行响应。 win 8760表明发 送窗口的大小是8760。<br>(2) ARP包的tcpdump输出信息<br>使用命令： </p>\n<p>#tcpdump arp<br>得到的输出结果是：<br>引用<br>22:32:42.802509 eth0 &gt; arp who-has route tell ICE (0:90:27:58:af:1a)<br>22:32:42.802902 eth0 &lt; arp reply route is-at 0:90:27:12:10:66 (0:90:27:58:af:1a)<br>22:32:42是时间戳， 802509是ID号， eth0 &gt;表明从主机发出该分组，arp表明是ARP请求包， who-has route tell ICE表明是主机ICE请求主机route的MAC地址。 0:90:27:58:af:1a是主机 ICE的MAC地址。<br>(3) TCP包的输出信息<br>用tcpdump捕获的TCP包的一般输出信息是：<br>引用<br>src &gt; dst: flags data-seqno ack window urgent options<br>src &gt; dst:表明从源地址到目的地址， flags是TCP报文中的标志信息，S 是SYN标志， F (FIN)， P (PUSH) ， R (RST) “.” (没有标记); data-seqno是报文中的数据 的顺序号， ack是下次期望的顺序号， window是接收缓存的窗口大小， urgent表明 报文中是否有紧急指针。 Options是选项。<br>(4) UDP包的输出信息<br>用tcpdump捕获的UDP包的一般输出信息是：<br>引用<br>route.port1 &gt; ICE.port2: udp lenth<br>UDP十分简单，上面的输出行表明从主机route的port1端口发出的一个UDP报文 到主机ICE的port2端口，类型是UDP， 包的长度是lenth。<br>五、举例<br>(1) 想要截获所有210.27.48.1 的主机收到的和发出的所有的分组： </p>\n<p>#tcpdump host 210.27.48.1<br>(2) 想要截获主机210.27.48.1 和主机210.27.48.2或210.27.48.3的通信，使用命令（注意：括号前的反斜杠是必须的）： </p>\n<p>#tcpdump host 210.27.48.1 and 210.27.48.2or210.27.48.3<br>(3) 如果想要获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包，使用命令： </p>\n<p>#tcpdump ip host 210.27.48.1 and ! 210.27.48.2<br>(4) 如果想要获取主机192.168.228.246接收或发出的ssh包，并且不转换主机名使用如下命令： </p>\n<p>#tcpdump -nn -n src host 192.168.228.246 and port 22 and tcp<br>(5) 获取主机192.168.228.246接收或发出的ssh包，并把mac地址也一同显示：</p>\n<h1 id=\"tcpdump-e-src-host-192-168-228-246-and-port-22-and-tcp-n-nn\"><a href=\"#tcpdump-e-src-host-192-168-228-246-and-port-22-and-tcp-n-nn\" class=\"headerlink\" title=\"tcpdump -e src host 192.168.228.246 and port 22 and tcp -n -nn\"></a>tcpdump -e src host 192.168.228.246 and port 22 and tcp -n -nn</h1><p>(6) 过滤的是源主机为192.168.0.1与目的网络为192.168.0.0的报头：<br>tcpdump src host 192.168.0.1 and dst net 192.168.0.0/24<br>(7) 过滤源主机物理地址为XXX的报头：<br>tcpdump ether src 00:50:04:BA:9B and dst……<br>（为什么ether src后面没有host或者net？物理地址当然不可能有网络喽）。<br>(8) 过滤源主机192.168.0.1和目的端口不是telnet的报头，并导入到tes.t.txt文件中：<br>Tcpdump src host 192.168.0.1 and dst port not telnet -l &gt; test.txt<br>ip icmp arp rarp 和 tcp、udp、icmp这些选项等都要放到第一个参数的位置，用来过滤数据报的类型。<br>tcpdump采用命令行方式，它的命令格式为：<br>tcpdump [-nn] [-i 接口] [-w 储存档名] [-c 次数] [-Ae]<br>                        [-qX] [-r 文件] [所欲捕获的数据内容]<br>参数：<br>-nn，直接以 IP 及 Port Number 显示，而非主机名与服务名称。<br>-i，后面接要「监听」的网络接口，例如 eth0, lo, ppp0 等等的接口。<br>-w，如果你要将监听所得的数据包数据储存下来，用这个参数就对了。后面接文件名。<br>-c，监听的数据包数，如果没有这个参数， tcpdump 会持续不断的监听，<br>     直到用户输入 [ctrl]-c 为止。<br>-A，数据包的内容以 ASCII 显示，通常用来捉取 WWW 的网页数据包资料。<br>-e，使用资料连接层 (OSI 第二层) 的 MAC 数据包数据来显示。<br>-q，仅列出较为简短的数据包信息，每一行的内容比较精简。<br>-X，可以列出十六进制 (hex) 以及 ASCII 的数据包内容，对于监听数据包内容很有用。<br>-r，从后面接的文件将数据包数据读出来。那个「文件」是已经存在的文件，<br>     并且这个「文件」是由 -w 所制作出来的。<br>所欲捕获的数据内容：我们可以专门针对某些通信协议或者是 IP 来源进行数据包捕获。<br>     那就可以简化输出的结果，并取得最有用的信息。常见的表示方法有。<br>    ‘host foo’, ‘host 127.0.0.1’ ：针对单台主机来进行数据包捕获。<br>     ‘net 192.168’ ：针对某个网段来进行数据包的捕获。<br>     ‘src host 127.0.0.1’ ‘dst net 192.168’：同时加上来源(src)或目标(dst)限制。<br>     ‘tcp port 21’：还可以针对通信协议检测，如tcp、udp、arp、ether 等。<br>     除了这三种类型的关键字之外，其他重要的关键字如下：gateway, broadcast,less,<br>greater,还有三种逻辑运算，取非运算是 ‘not ‘ ‘! ‘, 与运算是’and’,’&amp;&amp;’;或运算 是’o<br>r’ ,’||’；</p>\n<p>范例一：以 IP 与 Port Number 捉下 eth0 这个网卡上的数据包，持续 3 秒<br>[root@linux ~]# tcpdump -i eth0 -nn<br>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes<br>01:33:40.41 IP 192.168.1.100.22 &gt; 192.168.1.11.1190: P 116:232(116) ack 1 win<br>9648<br>01:33:40.41 IP 192.168.1.100.22 &gt; 192.168.1.11.1190: P 232:364(132) ack 1 win<br>9648<br>&lt;==按下 [ctrl]-c 之后结束<br>6680 packets captured              &lt;==捉取下来的数据包数量<br>14250 packets received by filter   &lt;==由过滤所得的总数据包数量<br>7512 packets dropped by kernel     &lt;==被核心所丢弃的数据包<br>至于那个在范例一所产生的输出中，我们可以大概区分为几个字段，现以范例一当中那行特殊字体行来说明一下：<br>· 01:33:40.41：这个是此数据包被捕获的时间，“时:分:秒”的单位。<br>· IP：通过的通信协议是IP。<br>· 192.168.1.100.22&gt;：传送端是192.168.1.100这个IP，而传送的Port Number为22，那个大于（&gt;）的符号指的是数据包的传输方向。<br>· 192.168.1.11.1190：接收端的IP是192.168.1.11，且该主机开启port 1190来接收。<br>· P 116:232(116)：这个数据包带有PUSH的数据传输标志，且传输的数据为整体数据的116~232 Byte，所以这个数据包带有116 Bytes的数据量。<br>· ack 1 win 9648：ACK与Window size的相关资料。<br>最简单的说法，就是该数据包是由192.168.1.100传到192.168.1.11，通过的port是由22到1190，且带有116 Bytes的数据量，使用的是PUSH的标记，而不是SYN之类的主动联机标志。<br>接下来，在一个网络状态很忙的主机上面，你想要取得某台主机对你联机的数据包数据时，使用tcpdump配合管线命令与正则表达式也可以，不过，毕竟不好捕获。我们可以通过tcpdump的表达式功能，就能够轻易地将所需要的数据独立的取出来。在上面的范例一当中，我们仅针对eth0做监听，所以整个eth0接口上面的数据都会被显示到屏幕上，但这样不好分析，可以简化吗？例如，只取出port 21的联机数据包，可以这样做：<br>[root@linux ~]# tcpdump -i eth0 -nn port 21<br>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes<br>01:54:37.96 IP 192.168.1.11.1240 &gt; 192.168.1.100.21:. ack 1 win 65535<br>01:54:37.96 IP 192.168.1.100.21 &gt; 192.168.1.11.1240:P 1:21(20) ack 1 win 5840<br>01:54:38.12 IP 192.168.1.11.1240 &gt; 192.168.1.100.21:. ack 21 win 65515<br>01:54:42.79 IP 192.168.1.11.1240 &gt; 192.168.1.100.21:P 1:17(16) ack 21 win 65515<br>01:54:42.79 IP 192.168.1.100.21 &gt; 192.168.1.11.1240: . ack 17 win 5840<br>01:54:42.79 IP 192.168.1.100.21 &gt; 192.168.1.11.1240: P 21:55(34) ack 17 win 5840<br>看！这样就仅取出port 21的信息，如果仔细看的话，你会发现数据包的传递都是双向的，Client端发出请求而Server端则予以响应，所以，当然是有去有回了。而我们也就可以经过这个数据包的流向来了解到数据包运动的过程了。例如：<br>· 我们先在一个终端机窗口输入“tcpdump-i lo-nn”的监听。<br>· 再另开一个终端机窗口来对本机（127.0.0.1）登录“ssh localhost”，那么输出的结果会是如何？<br>[root@linux ~]# tcpdump -i lo -nn<br> 1 tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br> 2 listening on lo, link-type EN10MB (Ethernet), capture size 96 bytes<br> 3 11:02:54.253777 IP 127.0.0.1.32936 &gt;<br>127.0.0.1.22: S 933696132:933696132(0)<br>   win 32767<br> 4 11:02:54.253831 IP 127.0.0.1.22 &gt; 127.0.0.1.32936:<br>S 920046702:920046702(0)<br>   ack 933696133 win 32767<br> 5 11:02:54.253871 IP 127.0.0.1.32936 &gt; 127.0.0.1.22: . ack 1 win 8192<br> 6 11:02:54.272124 IP 127.0.0.1.22 &gt; 127.0.0.1.32936:<br>P 1:23(22) ack 1 win 8192 </p>\n<p> 7 11:02:54.272375 IP 127.0.0.1.32936 &gt; 127.0.0.1.22: . ack 23 win 8192<br>代码显示的头两行是tcpdump的基本说明，然后：<br>· 第3行显示的是来自Client端带有SYN主动联机的数据包。<br>· 第4行显示的是来自Server端，除了响应Client端之外（ACK），还带有SYN主动联机的标志。<br>· 第5行则显示Client端响应Server确定联机建立（ACK）。<br>· 第6行以后则开始进入数据传输的步骤。<br>从第3~5行的流程来看，熟不熟悉啊？没错。那就是3次握手的基础流程，有趣吧。不过tcpdump之所以被称为黑客软件之一远不止上面介绍的功能。上面介绍的功能可以用来作为我们主机的数据包联机与传输的流程分析，这将有助于我们了解到数据包的运作，同时了解到主机的防火墙设置规则是否有需要修订的地方。<br>还有更神奇的用法。当我们使用tcpdump在Router上面监听明文的传输数据时，例如FTP传输协议，你觉得会发生什么问题呢？我们先在主机端执行“tcpdump -i lo port 21 -nn –X”，然后再以FTP登录本机，并输入账号与密码，结果你就可以发现如下的状况：<br>[root@linux ~]# tcpdump -i lo -nn -X ‘port 21’<br>    0x0000:  4500 0048 2a28 4000 4006 1286 7f00 0001  E..H*(@.@…….<br>    0x0010:  7f00 0001 0015 80ab 8355 2149 835c d825  ………U!I..%<br>    0x0020:  8018 2000 fe3c 0000 0101 080a 0e2e 0b67  …..&lt;………g<br>    0x0030:  0e2e 0b61 3232 3020 2876 7346 5450 6420  …a220.(vsFTPd.<br>    0x0040:  322e 302e 3129 0d0a                      2.0.1)..</p>\n<pre><code>0x0000:  4510 0041 d34b 4000 4006 6959 7f00 0001  E..A.K@.@.iY....\n0x0010:  7f00 0001 80ab 0015 835c d825 8355 215d  .........\\.%.U!]\n0x0020:  8018 2000 fe35 0000 0101 080a 0e2e 1b37  .....5.........7\n0x0030:  0e2e 0b67 5553 4552 2064 6d74 7361 690d  ...gUSER.dmtsai.\n0x0040:  0a                                       .\n\n0x0000:  4510 004a d34f 4000 4006 694c 7f00 0001  E..J.O@.@.iL....\n0x0010:  7f00 0001 80ab 0015 835c d832 8355 217f  .........\\.2.U!.\n0x0020:  8018 2000 fe3e 0000 0101 080a 0e2e 3227  .....&gt;........2&apos;\n0x0030:  0e2e 1b38 5041 5353 206d 7970 6173 7377  ...8PASS.mypassw\n0x0040:  6f72 6469 7379 6f75 0d0a                 ordisyou..\n</code></pre><p>上面的输出结果已经被简化过了，你需要自行在你的输出结果中搜索相关的字符串才行。从上面输出结果的特殊字体中，我们可以发现该FTP软件使用的是 vsFTPd，并且用户输入dmtsai这个账号名称，且密码是mypasswordisyou。如果使用的是明文方式来传输你的网络数据呢？<br>另外你得了解，为了让网络接口可以让tcpdump监听，所以执行tcpdump时网络接口会启动在“混杂模式（promiscuous）”，所以你会在 /var/log/messages里面看到很多的警告信息，通知你说你的网卡被设置成为混杂模式。别担心，那是正常的。至于更多的应用，请参考man tcpdump了。</p>\n<p>例题：如何使用tcpdump监听来自eth0适配卡且通信协议为port 22，目标来源为192.168.1.100的数据包资料？<br>答：tcpdump -i eth0 -nn ‘port 22 and src host 192.168.1.100’。</p>\n<p>##############例子2#######################################</p>\n<p>普通情况下，直接启动tcpdump将监视第一个网络界面上所有流过的数据包。</p>\n<h1 id=\"tcpdump\"><a href=\"#tcpdump\" class=\"headerlink\" title=\"tcpdump\"></a>tcpdump</h1><p>tcpdump: listening on fxp0<br>11:58:47.873028 202.102.245.40.netbios-ns &gt; 202.102.245.127.netbios-ns: udp 50<br>11:58:47.974331 0:10:7b:8:3a:56 &gt; 1:80:c2:0:0:0 802.1d ui/C len=43<br>0000 0000 0080 0000 1007 cf08 0900 0000<br>0e80 0000 902b 4695 0980 8701 0014 0002<br>000f 0000 902b 4695 0008 00<br>11:58:48.373134 0:0:e8:5b:6d:85 &gt; Broadcast sap e0 ui/C len=97<br>ffff 0060 0004 ffff ffff ffff ffff ffff<br>0452 ffff ffff 0000 e85b 6d85 4008 0002<br>0640 4d41 5354 4552 5f57 4542 0000 0000<br>0000 00<br>使用-i参数指定tcpdump监听的网络界面，这在计算机具有多个网络界面时非常有用，<br>使用-c参数指定要监听的数据包数量，<br>使用-w参数指定将监听到的数据包写入文件中保存<br>A想要截获所有210.27.48.1 的主机收到的和发出的所有的数据包：</p>\n<p>#tcpdump host 210.27.48.1<br>B想要截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信，使用命令：（在命令行中适用　　　括号时，一定要</p>\n<p>#tcpdump host 210.27.48.1 and \\ (210.27.48.2 or 210.27.48.3 )<br>C如果想要获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包，使用命令：</p>\n<p>#tcpdump ip host 210.27.48.1 and ! 210.27.48.2<br>D如果想要获取主机210.27.48.1接收或发出的telnet包，使用如下命令：</p>\n<p>#tcpdump tcp port 23 host 210.27.48.1<br>E 对本机的udp 123 端口进行监视 123 为ntp的服务端口</p>\n<h1 id=\"tcpdump-udp-port-123\"><a href=\"#tcpdump-udp-port-123\" class=\"headerlink\" title=\"tcpdump udp port 123\"></a>tcpdump udp port 123</h1><p>F 系统将只对名为hostname的主机的通信数据包进行监视。主机名可以是本地主机，也可以是网络上的任何一台计算机。下面的命令可以读取主机hostname发送的所有数据：</p>\n<p>#tcpdump -i eth0 src host hostname<br>G 下面的命令可以监视所有送到主机hostname的数据包：</p>\n<p>#tcpdump -i eth0 dst host hostname<br>H 我们还可以监视通过指定网关的数据包：</p>\n<p>#tcpdump -i eth0 gateway Gatewayname<br>I 如果你还想监视编址到指定端口的TCP或UDP数据包，那么执行以下命令：</p>\n<p>#tcpdump -i eth0 host hostname and port 80<br>J 如果想要获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包<br>，使用命令：</p>\n<p>#tcpdump ip host 210.27.48.1 and ! 210.27.48.2<br>K 想要截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信，使用命令<br>：（在命令行中适用　　　括号时，一定要</p>\n<p>#tcpdump host 210.27.48.1 and \\ (210.27.48.2 or 210.27.48.3 )<br>L 如果想要获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包，使用命令：</p>\n<p>#tcpdump ip host 210.27.48.1 and ! 210.27.48.2<br>M 如果想要获取主机210.27.48.1接收或发出的telnet包，使用如下命令：</p>\n<p>#tcpdump tcp port 23 host 210.27.48.1<br>第三种是协议的关键字，主要包括fddi,ip ,arp,rarp,tcp,udp等类型<br>除了这三种类型的关键字之外，其他重要的关键字如下：gateway, broadcast,less,<br>greater,还有三种逻辑运算，取非运算是 ‘not ‘ ‘! ‘, 与运算是‘and‘,‘&amp;&amp;‘;或运算 是‘o<br>r‘ ,‘||‘；<br>第二种是确定传输方向的关键字，主要包括src , dst ,dst or src, dst and src ,<br>如果我们只需要列出送到80端口的数据包，用dst port；如果我们只希望看到返回80端口的数据包，用src port。</p>\n<p>#tcpdump –i eth0 host hostname and dst port 80 目的端口是80<br>或者</p>\n<p>#tcpdump –i eth0 host hostname and src port 80 源端口是80 一般是提供http的服务的主机<br>如果条件很多的话 要在条件之前加and 或 or 或 not</p>\n<p>#tcpdump -i eth0 host ! 211.161.223.70 and ! 211.161.223.71 and dst port 80<br>如果在ethernet 使用混杂模式 系统的日志将会记录<br>May 7 20:03:46 localhost kernel: eth0: Promiscuous mode enabled.<br>May 7 20:03:46 localhost kernel: device eth0 entered promiscuous mode<br>May 7 20:03:57 localhost kernel: device eth0 left promiscuous mode<br>tcpdump对截获的数据并没有进行彻底解码，数据包内的大部分内容是使用十六进制的形式直接打印输出的。显然这不利于分析网络故障，通常的解决办法是先使用带-w参数的tcpdump 截获数据并保存到文件中，然后再使用其他程序进行解码分析。当然也应该定义过滤规则，以避免捕获的数据包填满整个硬盘。<br>除了过滤语句，还有一个很重要的参数，也就是说，如果这个参数不设置正确，会导致包数据的丢失！<br>它就是-s 参数，snaplen, 也就是数据包的截取长度，仔细看man就会明白的！默认截取长度为60个字节，但一般ethernet MTU都是1500字节。所以，要抓取大于60字节的包时，使用默认参数就会导致包数据丢失！<br>只要使用-s 0就可以按包长，截取数据！</p>"},{"title":"tsung使用说明","date":"2017-01-08T05:00:00.000Z","_content":"\n1、tsung安装\n\ntsung 一个非常优秀的压力测试工具，在8核32G机器上可以轻易的产生每秒10000个并发请求，且占用的资源很少，当前版本1.5.0\n<!--more-->\n使用erlang开发，需要先安装erlang虚拟机。安装过程略\n\n2、tsung使用  \n$ tsung -f ./tsung/tsung.xml sta\n\n3、tusng.xml\n\n下面是我自己的tsung.xml\n\n        <?xml version=\"1.0\"?>\n    <!DOCTYPE tsung SYSTEM \"/usr/local/share/tsung/tsung-1.0.dtd\">\n    <!-- dumptraffic是调试模式，如果为true，就会打印详细的请求返回信息，一般设置为false， -->\n    <tsung loglevel=\"notice\" dumptraffic=\"false\" version=\"1.0\">\n    <!-- tsung所在的服务器，maxusers就是tsung产生的最大用户数 -->\n      <clients>\n    <client host=\"localhost\" use_controller_vm=\"true\"  maxusers=\"100000\" />\n      </clients>\n    <!-- 被测服务器的ip和端口号，type一般设为tcp ->\n      <servers>\n    <server host=\"@server\" port=\"@port\" type=\"tcp\"/>\n      </servers>\n    <!-- tsung产生的压力 -->\n    <load>\n    <!-- phase=\"1\" 第一阶段；duration：测试持续时间；unit：单位秒 -->\n    <arrivalphase phase=\"1\" duration=\"@duration\" unit=\"second\">\n    <!-- maxnumber：最大用户数；arrivalrate：每秒新增用户数；unit：单位秒-->\n      <users maxnumber=\"@maxuser\" arrivalrate=\"@user\" unit=\"second\"/>\n    </arrivalphase>\n      </load>\n    <!-- 外部变量 -->\n      <options>\n    <!-- 引入一个外部文件，类型为file_server，变量名为userfile，文件路径：/tmp/users-->\n    <!-- 文件是以逗号分隔的csv文件 -->\n    <option name=\"file_server\" id=\"userfile\" value=\"/tmp/users\"/>\n      </options>\n    <!-- 会话，每个用户都按照sessions中的配置发送请求 -->\n      <sessions>\n    <!--probability=“100”:这个session的请求概率是100%，如果要同时测多个api，可以设置请求概率；请求类型为http -->\n    <session name=\"test\" probability=\"100\" type=\"ts_http\">\n    <!-- 请求次数，to是最大请求数，如果设为100，就是每个用户请求100次 -->\n      <for from=\"1\" to=\"@loop\" incr=\"1\" var=\"counter\">\n    <!-- 解析前面引入的外部文件，以逗号做为分隔符，随机读取 -->\n    <setdynvars sourcetype=\"file\" fileid=\"userfile\" delimiter=\",\" order=\"random\">\n      <var name=\"user_id\" />\n      <var name=\"passwd\" />\n      <var name=\"auth_token\" />\n    </setdynvars>\n    <!-- 返回随机小数，变量名为decimal，code中可以写erlang函数 -->\n    <setdynvars sourcetype=\"eval\" code=\"fun({Pid,DynVars}) -> random:uniform() end.\">\n      <var name=\"decimal\" />\n    </setdynvars>\n    <!-- 返回随机数，从1到10000 -->\n    <setdynvars sourcetype=\"random_number\" start=\"1\" end=\"10000\">\n       <var name=\"int_1_10000\" />\n    </setdynvars>\n    <!-- 返回随机字符串，长度为10 -->\n    <setdynvars sourcetype=\"random_string\" length=\"10\">\n       <var name=\"string_10\" />\n    </setdynvars>\n    <!-- subst=\"true\"：如果在request中使用变量，需要设置subst -->\n    <request subst=\"true\">\n    <!-- url：被测试的url；method：GET、POST等；contents：POST请求的参数 -->\n      <http url=\"@api\" method=\"@method\" contents=\"@contents\" version=\"1.1\">\n    <!-- http header，可以添加Authorization、Cookie等，注意变量的使用格式：%%_xxx%% -->\n    <http_header name=\"Authorization\" value=\"111\"/>\n    <http_header name=\"Cookie\" value=\"authToken=%%_auth_token%%; Path=/\"/>\n    <!-- content-Type：POST请求参数的格式，如果是json格式可以这样写 -->\n    <http_header name=\"Content-Type\" value=\"application/json\"/>\n      </http>\n    </request>\n    <!-- thinktime：两次请求之间的间隔时间，一般小于10s -->\n    <thinktime value=\"1\"/>\n      </for>\n    </session>\n      </sessions>\n    </tsung> \n  \n\n如果被测接口需要登录跳转，可以指明跳转条件：   \n \n\n    <!-- if need login, http 302 will be return -->\n    <request subst=\"true\">\n      <dyn_variable name=\"redirect1\" re=\"Location: ((http|https)://.*)\\r\"/>\n      <http url=\"@api\" method=\"@method\" contents=\"@contents\" version=\"1.1\"></http>\n    </request>\n    \n    <if var=\"redirect1\" neq=\"\">\n      <request subst=\"true\">\n    <!-- 这里可以使用xpath提取页面中的元素值 -->\n    <dyn_variable name=\"lt\" xpath=\"//input[@name='lt']/@value\"/>\n    <dyn_variable name=\"s_uuid\" xpath=\"//input[@name='s_uuid']/@value\"/>\n    <dyn_variable name=\"eventId\" xpath=\"//input[@name='_eventId']/@value\"/>\n    <http url=\"%%_redirect1%%\" method=\"GET\"></http>\n      </request>\n    \n      <request subst=\"true\">\n    <dyn_variable name=\"redirect2\" re=\"Location: (http://.*)\\r\"/>\n    <http url=\"%%_redirect1%%\" method=\"POST\" contents=\"username=%%_username%%&amp;password=%%_password%%&amp;lt=%%_lt%%&amp;s_uuid=%%_s_uuid%%&amp;_eventId=%%_eventId%%&amp;j_captcha_response=''\"></http>\n      </request>\n    \n      <request subst=\"true\">\n    <dyn_variable name=\"redirect3\" re=\"Location: (http://.*)\\r\"/>\n    <http url=\"%%_redirect2%%\" method=\"GET\"></http>\n      </request>\n    \n      <request subst=\"true\">\n    <http url=\"%%_redirect3%%\" method=\"@method\" contents=\"@contents\"></http>\n      </request>\n    </if>\n    \n\n4、通过shell控制tsung\n\n如果每次使用tsung -f tsung.xml start运行tsung，那么每次修改测试接口或者压力改变都需要修改xml，非常麻烦，我写了一个shell脚本，替换上面的tsung.xml中以@开头的变量\n\n    #!/bin/bash\n    defaultTestFile=\"$HOME/tsung_test.xml\"\n    defaultUser=20\n    defaultDuration=100\n    # s\n    defaultThinktime=1\n    defaultServer=\"tomcat1\"\n    defaultPort=9000\n    defaultApi=\"/test\"\n    defaultMethod=\"POST\"\n    defaultLoopCount=50\n    defaultMaxuser=5000\n    \n    while [ $# -gt 0 ]; do\n      case \"$1\" in\n    -f|--testFile)\n    testFile=$2\n    shift \n    shift ;;\n    -u|--user)\n    user=$2\n    shift \n    shift ;;\n    -d|--duration)\n    duration=$2\n    shift \n    shift ;;\n    -t|--thinktime)\n    thinktime=$2\n    shift \n    shift ;;\n    -s|--server)\n    server=$2\n    shift \n    shift ;;\n    -p|--port)\n    port=$2\n    shift \n    shift ;;\n    -a|--api)\n    api=$2\n    shift \n    shift ;;\n    -m|--method)\n    method=$2\n    shift \n    shift ;;\n    -l|--loopCount)\n    loopCount=$2\n    shift \n    shift ;;\n    -x|--maxuser)\n    maxuser=$2\n    shift \n    shift ;;\n    -h|--help)\n    echo \"-f | --testFile: tsung test file xml,default $defaultTestFile\"\n    echo \"-u | --user: user number per second, default $defaultUser\"\n    echo \"-x | --maxuser: max user number, default $defaultMaxuser\"\n    echo \"-d | --duration: times used to generate user,default $defaultDuration s\"\n    echo \"-t | --thinktime: the inteval time between two request,default $defaultThinktime s\"\n    echo \"-l | --loopCount: Each user's request number,default $defaultLoopCount\"\n    echo \"-s | --server: play server,default $defaultServer\"\n    echo \"-p | --port: play server http port,default $defaultPort\"\n    echo \"-a | --api: api, default $defaultApi\"\n    echo \"-m | --method: POST/GET,default $defaultMethod\"\n    echo \"-h | --help: print this help\"\n    shift\n    exit 1\n    ;;\n    --)\n      shift\n      break\n      ;;\n    *)\n      echo \"wrong input:$1,use -h or --help see how to use\" 1>&2\n      exit 1\n      ;;\n      esac\n    done\n    \n    processName=\"tsung\"\n    pid=`ps aux | grep $processName | grep -v grep | awk '{print $2}'`\n    #convert from string to array\n    pid=($pid)\n    if [ ${#pid[*]} -gt 3 ]; then\n      echo \"warning!!! a $processName process is running,please wait\"\n      exit 1\n    fi\n    \n    #env\n    #set default parameters\n    testFile=${testFile:=$defaultTestFile}\n    user=${user:=$defaultUser}\n    duration=${duration:=$defaultDuration}\n    thinktime=${thinktime:=$defaultThinktime}\n    server=${server:=$defaultServer}\n    port=${port:=$defaultPort}\n    api=${api:=$defaultApi}\n    method=${method:=$defaultMethod}\n    loopCount=${loopCount:=$defaultLoopCount}\n    maxuser=${maxuser:=$defaultMaxuser}\n    \n    #key of params is nodname in tusng_test.xml file\n    declare -A params\n    params=( \\\n      [\"user\"]=$user \\\n      [\"maxuser\"]=$maxuser \\\n      [\"duration\"]=$duration \\\n      [\"thinktime\"]=$thinktime \\\n      [\"server\"]=$server \\\n      [\"port\"]=$port \\\n      [\"api\"]=$api \\\n      [\"method\"]=$method \\\n      [\"loopCount\"]=$loopCount \\\n      )\n    reportPath=\"$HOME/.tsung/log\"\n    currentTest=`date +%Y%m%d-%H%M`\n    reportPath=\"$reportPath/$currentTest\"\n    mkdir -p $reportPath\n    #deal with jmx file\n    cp $testFile $reportPath\n    currentTestFile=\"$reportPath/tsung_test.xml\"\n    function replace(){\n      echo \"$1:$2\" | tee -a \"$reportPath/test.env\"\n      #change / to \\/ for sed \n      local val=${2//\\//\\\\\\/}\n      sed -i \"s/@${1}/${val}/\" $currentTestFile\n    }\n    for key in ${!params[*]}\n    do\n      replace $key ${params[$key]}\n    done\n    #start tsung \n    tsung -f $currentTestFile start &\n    wait %1\n    cd $reportPath\n    /usr/local/lib/tsung/bin/tsung_stats.pl\n\n\n5、tsung结果分析\n\ntsung生成的测试报告都放在$HOME/.tsung/log下，以日期加时间的方式命名，如：`.tsung/log/20150407-1951`，其中最重要的几张图是\n\n- tsung产生的用户数曲线图 .tsung/log/20150407-1951/images/graphes-Users-simultaneous.png\n ![](http://static.oschina.net/uploads/space/2015/0706/135050_sSxO_780347.png)\n\nY轴代表每秒用户数，tsung每秒会产生一批用户，这个统计结果是每十秒统计一次，所有的图的起始位置显示的是0，其实是第一个10秒\n\n\n- http接口响应数曲线图（TPS） .tsung/log/20150407-1951/images/graphes-HTTP_CODE-rate.png\n ![](http://static.oschina.net/uploads/space/2015/0706/135106_dKTc_780347.png)\n \n Y轴是每秒响应数，右上角的200是http状态码，如果有多个状态码，会有多条不同颜色的曲线。\n\n- http接口响应时间曲线图 .tsung/log/20150407-1951/images/graphes-Perfs-mean.png\n\n![](http://static.oschina.net/uploads/space/2015/0706/135120_sPqf_780347.png)\n\n  Y轴是接口响应时间，单位是毫秒，request的线代表请求响应总耗时，connect的线代表tcp链接建立的时间。\n\n6、主要统计信息  \nTsung统计数据是平均每十秒重置一次，所以这里的响应时间（连接、请求、页面、会话）是指每十秒的平均响应时间；  \nconnect： 表示 每个连接持续时间；  \nHightest 10sec mean\t连接最长持续时间  \nLowest 10sec mean\t连接最短持续时间  \nHighest rate \t每秒最高建立连接速率  \nMean\t平均每个连接持续时间  \nCount\t总连接数  \npage： 表示 每个请求集合的响应时间,（一个页面表示一组没有被thinktime间隔的请求）  \nrequest： 表示 每个请求的响应时间；  \nHightest 10sec mean\t请求最长响应时间  \nLowest 10sec mean\t请求最短响应时间  \nHighest rate \t请求最快发送速率  \nMean\t平均每个请求响应时间  \nCount\t总请求数  \nsession： 表示 每个用户会话持续时间；  \nHightest 10sec mean\t会话最长持续时间  \nLowest 10sec mean\t会话最短持续时间  \nHighest rate \t每秒最高进行会话速率  \nMean\t平均每个会话持续时间  \nCount\t总会话数  \n \n7、数据流量统计  \nsize_rcv: 表示 响应请求数据量  \nsize_sent:表示 发送请求数据量  \nHightest rate\t每秒最高 响应/发送 请求数据量  \nTotal \t响应/发送 请求总数据量  \n \n8、计数统计  \nconnected\t表示会话开始且尚未结束，并且已建立连接的最大用户数  \nfinished_user_count\t表示已经完成会话的最大用户数  \nusers\t表示会话开始且尚未结束的最大用户数  \nusers_count\t表示Tsung总共生成的用户总数  \n \n9、错误统计  \nError_abort_max_conn_retries\t重新尝试连接错误  \nError_connect_timeout\t连接超时错误  \nError_connect_nxdomain\t不存在的域错误  \nError_unknown\t位置错误  \n \nHighest rate \t发生错误最高速率  \nTotal number\t发生该错误总个数  \n   \n10、http返回状态码统计  \n200：表示客户端请求已成功响应  \nHighest rate\t状态码返回最高速率  \nTotal number\t返回状态码的总个数  \n","source":"_posts/tsung说明文档.md","raw":"---\ntitle: tsung使用说明\ndate: 2017-01-08\ntags:\n---\n\n1、tsung安装\n\ntsung 一个非常优秀的压力测试工具，在8核32G机器上可以轻易的产生每秒10000个并发请求，且占用的资源很少，当前版本1.5.0\n<!--more-->\n使用erlang开发，需要先安装erlang虚拟机。安装过程略\n\n2、tsung使用  \n$ tsung -f ./tsung/tsung.xml sta\n\n3、tusng.xml\n\n下面是我自己的tsung.xml\n\n        <?xml version=\"1.0\"?>\n    <!DOCTYPE tsung SYSTEM \"/usr/local/share/tsung/tsung-1.0.dtd\">\n    <!-- dumptraffic是调试模式，如果为true，就会打印详细的请求返回信息，一般设置为false， -->\n    <tsung loglevel=\"notice\" dumptraffic=\"false\" version=\"1.0\">\n    <!-- tsung所在的服务器，maxusers就是tsung产生的最大用户数 -->\n      <clients>\n    <client host=\"localhost\" use_controller_vm=\"true\"  maxusers=\"100000\" />\n      </clients>\n    <!-- 被测服务器的ip和端口号，type一般设为tcp ->\n      <servers>\n    <server host=\"@server\" port=\"@port\" type=\"tcp\"/>\n      </servers>\n    <!-- tsung产生的压力 -->\n    <load>\n    <!-- phase=\"1\" 第一阶段；duration：测试持续时间；unit：单位秒 -->\n    <arrivalphase phase=\"1\" duration=\"@duration\" unit=\"second\">\n    <!-- maxnumber：最大用户数；arrivalrate：每秒新增用户数；unit：单位秒-->\n      <users maxnumber=\"@maxuser\" arrivalrate=\"@user\" unit=\"second\"/>\n    </arrivalphase>\n      </load>\n    <!-- 外部变量 -->\n      <options>\n    <!-- 引入一个外部文件，类型为file_server，变量名为userfile，文件路径：/tmp/users-->\n    <!-- 文件是以逗号分隔的csv文件 -->\n    <option name=\"file_server\" id=\"userfile\" value=\"/tmp/users\"/>\n      </options>\n    <!-- 会话，每个用户都按照sessions中的配置发送请求 -->\n      <sessions>\n    <!--probability=“100”:这个session的请求概率是100%，如果要同时测多个api，可以设置请求概率；请求类型为http -->\n    <session name=\"test\" probability=\"100\" type=\"ts_http\">\n    <!-- 请求次数，to是最大请求数，如果设为100，就是每个用户请求100次 -->\n      <for from=\"1\" to=\"@loop\" incr=\"1\" var=\"counter\">\n    <!-- 解析前面引入的外部文件，以逗号做为分隔符，随机读取 -->\n    <setdynvars sourcetype=\"file\" fileid=\"userfile\" delimiter=\",\" order=\"random\">\n      <var name=\"user_id\" />\n      <var name=\"passwd\" />\n      <var name=\"auth_token\" />\n    </setdynvars>\n    <!-- 返回随机小数，变量名为decimal，code中可以写erlang函数 -->\n    <setdynvars sourcetype=\"eval\" code=\"fun({Pid,DynVars}) -> random:uniform() end.\">\n      <var name=\"decimal\" />\n    </setdynvars>\n    <!-- 返回随机数，从1到10000 -->\n    <setdynvars sourcetype=\"random_number\" start=\"1\" end=\"10000\">\n       <var name=\"int_1_10000\" />\n    </setdynvars>\n    <!-- 返回随机字符串，长度为10 -->\n    <setdynvars sourcetype=\"random_string\" length=\"10\">\n       <var name=\"string_10\" />\n    </setdynvars>\n    <!-- subst=\"true\"：如果在request中使用变量，需要设置subst -->\n    <request subst=\"true\">\n    <!-- url：被测试的url；method：GET、POST等；contents：POST请求的参数 -->\n      <http url=\"@api\" method=\"@method\" contents=\"@contents\" version=\"1.1\">\n    <!-- http header，可以添加Authorization、Cookie等，注意变量的使用格式：%%_xxx%% -->\n    <http_header name=\"Authorization\" value=\"111\"/>\n    <http_header name=\"Cookie\" value=\"authToken=%%_auth_token%%; Path=/\"/>\n    <!-- content-Type：POST请求参数的格式，如果是json格式可以这样写 -->\n    <http_header name=\"Content-Type\" value=\"application/json\"/>\n      </http>\n    </request>\n    <!-- thinktime：两次请求之间的间隔时间，一般小于10s -->\n    <thinktime value=\"1\"/>\n      </for>\n    </session>\n      </sessions>\n    </tsung> \n  \n\n如果被测接口需要登录跳转，可以指明跳转条件：   \n \n\n    <!-- if need login, http 302 will be return -->\n    <request subst=\"true\">\n      <dyn_variable name=\"redirect1\" re=\"Location: ((http|https)://.*)\\r\"/>\n      <http url=\"@api\" method=\"@method\" contents=\"@contents\" version=\"1.1\"></http>\n    </request>\n    \n    <if var=\"redirect1\" neq=\"\">\n      <request subst=\"true\">\n    <!-- 这里可以使用xpath提取页面中的元素值 -->\n    <dyn_variable name=\"lt\" xpath=\"//input[@name='lt']/@value\"/>\n    <dyn_variable name=\"s_uuid\" xpath=\"//input[@name='s_uuid']/@value\"/>\n    <dyn_variable name=\"eventId\" xpath=\"//input[@name='_eventId']/@value\"/>\n    <http url=\"%%_redirect1%%\" method=\"GET\"></http>\n      </request>\n    \n      <request subst=\"true\">\n    <dyn_variable name=\"redirect2\" re=\"Location: (http://.*)\\r\"/>\n    <http url=\"%%_redirect1%%\" method=\"POST\" contents=\"username=%%_username%%&amp;password=%%_password%%&amp;lt=%%_lt%%&amp;s_uuid=%%_s_uuid%%&amp;_eventId=%%_eventId%%&amp;j_captcha_response=''\"></http>\n      </request>\n    \n      <request subst=\"true\">\n    <dyn_variable name=\"redirect3\" re=\"Location: (http://.*)\\r\"/>\n    <http url=\"%%_redirect2%%\" method=\"GET\"></http>\n      </request>\n    \n      <request subst=\"true\">\n    <http url=\"%%_redirect3%%\" method=\"@method\" contents=\"@contents\"></http>\n      </request>\n    </if>\n    \n\n4、通过shell控制tsung\n\n如果每次使用tsung -f tsung.xml start运行tsung，那么每次修改测试接口或者压力改变都需要修改xml，非常麻烦，我写了一个shell脚本，替换上面的tsung.xml中以@开头的变量\n\n    #!/bin/bash\n    defaultTestFile=\"$HOME/tsung_test.xml\"\n    defaultUser=20\n    defaultDuration=100\n    # s\n    defaultThinktime=1\n    defaultServer=\"tomcat1\"\n    defaultPort=9000\n    defaultApi=\"/test\"\n    defaultMethod=\"POST\"\n    defaultLoopCount=50\n    defaultMaxuser=5000\n    \n    while [ $# -gt 0 ]; do\n      case \"$1\" in\n    -f|--testFile)\n    testFile=$2\n    shift \n    shift ;;\n    -u|--user)\n    user=$2\n    shift \n    shift ;;\n    -d|--duration)\n    duration=$2\n    shift \n    shift ;;\n    -t|--thinktime)\n    thinktime=$2\n    shift \n    shift ;;\n    -s|--server)\n    server=$2\n    shift \n    shift ;;\n    -p|--port)\n    port=$2\n    shift \n    shift ;;\n    -a|--api)\n    api=$2\n    shift \n    shift ;;\n    -m|--method)\n    method=$2\n    shift \n    shift ;;\n    -l|--loopCount)\n    loopCount=$2\n    shift \n    shift ;;\n    -x|--maxuser)\n    maxuser=$2\n    shift \n    shift ;;\n    -h|--help)\n    echo \"-f | --testFile: tsung test file xml,default $defaultTestFile\"\n    echo \"-u | --user: user number per second, default $defaultUser\"\n    echo \"-x | --maxuser: max user number, default $defaultMaxuser\"\n    echo \"-d | --duration: times used to generate user,default $defaultDuration s\"\n    echo \"-t | --thinktime: the inteval time between two request,default $defaultThinktime s\"\n    echo \"-l | --loopCount: Each user's request number,default $defaultLoopCount\"\n    echo \"-s | --server: play server,default $defaultServer\"\n    echo \"-p | --port: play server http port,default $defaultPort\"\n    echo \"-a | --api: api, default $defaultApi\"\n    echo \"-m | --method: POST/GET,default $defaultMethod\"\n    echo \"-h | --help: print this help\"\n    shift\n    exit 1\n    ;;\n    --)\n      shift\n      break\n      ;;\n    *)\n      echo \"wrong input:$1,use -h or --help see how to use\" 1>&2\n      exit 1\n      ;;\n      esac\n    done\n    \n    processName=\"tsung\"\n    pid=`ps aux | grep $processName | grep -v grep | awk '{print $2}'`\n    #convert from string to array\n    pid=($pid)\n    if [ ${#pid[*]} -gt 3 ]; then\n      echo \"warning!!! a $processName process is running,please wait\"\n      exit 1\n    fi\n    \n    #env\n    #set default parameters\n    testFile=${testFile:=$defaultTestFile}\n    user=${user:=$defaultUser}\n    duration=${duration:=$defaultDuration}\n    thinktime=${thinktime:=$defaultThinktime}\n    server=${server:=$defaultServer}\n    port=${port:=$defaultPort}\n    api=${api:=$defaultApi}\n    method=${method:=$defaultMethod}\n    loopCount=${loopCount:=$defaultLoopCount}\n    maxuser=${maxuser:=$defaultMaxuser}\n    \n    #key of params is nodname in tusng_test.xml file\n    declare -A params\n    params=( \\\n      [\"user\"]=$user \\\n      [\"maxuser\"]=$maxuser \\\n      [\"duration\"]=$duration \\\n      [\"thinktime\"]=$thinktime \\\n      [\"server\"]=$server \\\n      [\"port\"]=$port \\\n      [\"api\"]=$api \\\n      [\"method\"]=$method \\\n      [\"loopCount\"]=$loopCount \\\n      )\n    reportPath=\"$HOME/.tsung/log\"\n    currentTest=`date +%Y%m%d-%H%M`\n    reportPath=\"$reportPath/$currentTest\"\n    mkdir -p $reportPath\n    #deal with jmx file\n    cp $testFile $reportPath\n    currentTestFile=\"$reportPath/tsung_test.xml\"\n    function replace(){\n      echo \"$1:$2\" | tee -a \"$reportPath/test.env\"\n      #change / to \\/ for sed \n      local val=${2//\\//\\\\\\/}\n      sed -i \"s/@${1}/${val}/\" $currentTestFile\n    }\n    for key in ${!params[*]}\n    do\n      replace $key ${params[$key]}\n    done\n    #start tsung \n    tsung -f $currentTestFile start &\n    wait %1\n    cd $reportPath\n    /usr/local/lib/tsung/bin/tsung_stats.pl\n\n\n5、tsung结果分析\n\ntsung生成的测试报告都放在$HOME/.tsung/log下，以日期加时间的方式命名，如：`.tsung/log/20150407-1951`，其中最重要的几张图是\n\n- tsung产生的用户数曲线图 .tsung/log/20150407-1951/images/graphes-Users-simultaneous.png\n ![](http://static.oschina.net/uploads/space/2015/0706/135050_sSxO_780347.png)\n\nY轴代表每秒用户数，tsung每秒会产生一批用户，这个统计结果是每十秒统计一次，所有的图的起始位置显示的是0，其实是第一个10秒\n\n\n- http接口响应数曲线图（TPS） .tsung/log/20150407-1951/images/graphes-HTTP_CODE-rate.png\n ![](http://static.oschina.net/uploads/space/2015/0706/135106_dKTc_780347.png)\n \n Y轴是每秒响应数，右上角的200是http状态码，如果有多个状态码，会有多条不同颜色的曲线。\n\n- http接口响应时间曲线图 .tsung/log/20150407-1951/images/graphes-Perfs-mean.png\n\n![](http://static.oschina.net/uploads/space/2015/0706/135120_sPqf_780347.png)\n\n  Y轴是接口响应时间，单位是毫秒，request的线代表请求响应总耗时，connect的线代表tcp链接建立的时间。\n\n6、主要统计信息  \nTsung统计数据是平均每十秒重置一次，所以这里的响应时间（连接、请求、页面、会话）是指每十秒的平均响应时间；  \nconnect： 表示 每个连接持续时间；  \nHightest 10sec mean\t连接最长持续时间  \nLowest 10sec mean\t连接最短持续时间  \nHighest rate \t每秒最高建立连接速率  \nMean\t平均每个连接持续时间  \nCount\t总连接数  \npage： 表示 每个请求集合的响应时间,（一个页面表示一组没有被thinktime间隔的请求）  \nrequest： 表示 每个请求的响应时间；  \nHightest 10sec mean\t请求最长响应时间  \nLowest 10sec mean\t请求最短响应时间  \nHighest rate \t请求最快发送速率  \nMean\t平均每个请求响应时间  \nCount\t总请求数  \nsession： 表示 每个用户会话持续时间；  \nHightest 10sec mean\t会话最长持续时间  \nLowest 10sec mean\t会话最短持续时间  \nHighest rate \t每秒最高进行会话速率  \nMean\t平均每个会话持续时间  \nCount\t总会话数  \n \n7、数据流量统计  \nsize_rcv: 表示 响应请求数据量  \nsize_sent:表示 发送请求数据量  \nHightest rate\t每秒最高 响应/发送 请求数据量  \nTotal \t响应/发送 请求总数据量  \n \n8、计数统计  \nconnected\t表示会话开始且尚未结束，并且已建立连接的最大用户数  \nfinished_user_count\t表示已经完成会话的最大用户数  \nusers\t表示会话开始且尚未结束的最大用户数  \nusers_count\t表示Tsung总共生成的用户总数  \n \n9、错误统计  \nError_abort_max_conn_retries\t重新尝试连接错误  \nError_connect_timeout\t连接超时错误  \nError_connect_nxdomain\t不存在的域错误  \nError_unknown\t位置错误  \n \nHighest rate \t发生错误最高速率  \nTotal number\t发生该错误总个数  \n   \n10、http返回状态码统计  \n200：表示客户端请求已成功响应  \nHighest rate\t状态码返回最高速率  \nTotal number\t返回状态码的总个数  \n","slug":"tsung说明文档","published":1,"updated":"2017-03-01T05:59:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizqklz80000dlbpvxfqets1t","content":"<p>1、tsung安装</p>\n<p>tsung 一个非常优秀的压力测试工具，在8核32G机器上可以轻易的产生每秒10000个并发请求，且占用的资源很少，当前版本1.5.0<br><a id=\"more\"></a><br>使用erlang开发，需要先安装erlang虚拟机。安装过程略</p>\n<p>2、tsung使用<br>$ tsung -f ./tsung/tsung.xml sta</p>\n<p>3、tusng.xml</p>\n<p>下面是我自己的tsung.xml</p>\n<pre><code>    &lt;?xml version=&quot;1.0&quot;?&gt;\n&lt;!DOCTYPE tsung SYSTEM &quot;/usr/local/share/tsung/tsung-1.0.dtd&quot;&gt;\n&lt;!-- dumptraffic是调试模式，如果为true，就会打印详细的请求返回信息，一般设置为false， --&gt;\n&lt;tsung loglevel=&quot;notice&quot; dumptraffic=&quot;false&quot; version=&quot;1.0&quot;&gt;\n&lt;!-- tsung所在的服务器，maxusers就是tsung产生的最大用户数 --&gt;\n  &lt;clients&gt;\n&lt;client host=&quot;localhost&quot; use_controller_vm=&quot;true&quot;  maxusers=&quot;100000&quot; /&gt;\n  &lt;/clients&gt;\n&lt;!-- 被测服务器的ip和端口号，type一般设为tcp -&gt;\n  &lt;servers&gt;\n&lt;server host=&quot;@server&quot; port=&quot;@port&quot; type=&quot;tcp&quot;/&gt;\n  &lt;/servers&gt;\n&lt;!-- tsung产生的压力 --&gt;\n&lt;load&gt;\n&lt;!-- phase=&quot;1&quot; 第一阶段；duration：测试持续时间；unit：单位秒 --&gt;\n&lt;arrivalphase phase=&quot;1&quot; duration=&quot;@duration&quot; unit=&quot;second&quot;&gt;\n&lt;!-- maxnumber：最大用户数；arrivalrate：每秒新增用户数；unit：单位秒--&gt;\n  &lt;users maxnumber=&quot;@maxuser&quot; arrivalrate=&quot;@user&quot; unit=&quot;second&quot;/&gt;\n&lt;/arrivalphase&gt;\n  &lt;/load&gt;\n&lt;!-- 外部变量 --&gt;\n  &lt;options&gt;\n&lt;!-- 引入一个外部文件，类型为file_server，变量名为userfile，文件路径：/tmp/users--&gt;\n&lt;!-- 文件是以逗号分隔的csv文件 --&gt;\n&lt;option name=&quot;file_server&quot; id=&quot;userfile&quot; value=&quot;/tmp/users&quot;/&gt;\n  &lt;/options&gt;\n&lt;!-- 会话，每个用户都按照sessions中的配置发送请求 --&gt;\n  &lt;sessions&gt;\n&lt;!--probability=“100”:这个session的请求概率是100%，如果要同时测多个api，可以设置请求概率；请求类型为http --&gt;\n&lt;session name=&quot;test&quot; probability=&quot;100&quot; type=&quot;ts_http&quot;&gt;\n&lt;!-- 请求次数，to是最大请求数，如果设为100，就是每个用户请求100次 --&gt;\n  &lt;for from=&quot;1&quot; to=&quot;@loop&quot; incr=&quot;1&quot; var=&quot;counter&quot;&gt;\n&lt;!-- 解析前面引入的外部文件，以逗号做为分隔符，随机读取 --&gt;\n&lt;setdynvars sourcetype=&quot;file&quot; fileid=&quot;userfile&quot; delimiter=&quot;,&quot; order=&quot;random&quot;&gt;\n  &lt;var name=&quot;user_id&quot; /&gt;\n  &lt;var name=&quot;passwd&quot; /&gt;\n  &lt;var name=&quot;auth_token&quot; /&gt;\n&lt;/setdynvars&gt;\n&lt;!-- 返回随机小数，变量名为decimal，code中可以写erlang函数 --&gt;\n&lt;setdynvars sourcetype=&quot;eval&quot; code=&quot;fun({Pid,DynVars}) -&gt; random:uniform() end.&quot;&gt;\n  &lt;var name=&quot;decimal&quot; /&gt;\n&lt;/setdynvars&gt;\n&lt;!-- 返回随机数，从1到10000 --&gt;\n&lt;setdynvars sourcetype=&quot;random_number&quot; start=&quot;1&quot; end=&quot;10000&quot;&gt;\n   &lt;var name=&quot;int_1_10000&quot; /&gt;\n&lt;/setdynvars&gt;\n&lt;!-- 返回随机字符串，长度为10 --&gt;\n&lt;setdynvars sourcetype=&quot;random_string&quot; length=&quot;10&quot;&gt;\n   &lt;var name=&quot;string_10&quot; /&gt;\n&lt;/setdynvars&gt;\n&lt;!-- subst=&quot;true&quot;：如果在request中使用变量，需要设置subst --&gt;\n&lt;request subst=&quot;true&quot;&gt;\n&lt;!-- url：被测试的url；method：GET、POST等；contents：POST请求的参数 --&gt;\n  &lt;http url=&quot;@api&quot; method=&quot;@method&quot; contents=&quot;@contents&quot; version=&quot;1.1&quot;&gt;\n&lt;!-- http header，可以添加Authorization、Cookie等，注意变量的使用格式：%%_xxx%% --&gt;\n&lt;http_header name=&quot;Authorization&quot; value=&quot;111&quot;/&gt;\n&lt;http_header name=&quot;Cookie&quot; value=&quot;authToken=%%_auth_token%%; Path=/&quot;/&gt;\n&lt;!-- content-Type：POST请求参数的格式，如果是json格式可以这样写 --&gt;\n&lt;http_header name=&quot;Content-Type&quot; value=&quot;application/json&quot;/&gt;\n  &lt;/http&gt;\n&lt;/request&gt;\n&lt;!-- thinktime：两次请求之间的间隔时间，一般小于10s --&gt;\n&lt;thinktime value=&quot;1&quot;/&gt;\n  &lt;/for&gt;\n&lt;/session&gt;\n  &lt;/sessions&gt;\n&lt;/tsung&gt; \n</code></pre><p>如果被测接口需要登录跳转，可以指明跳转条件：   </p>\n<pre><code>&lt;!-- if need login, http 302 will be return --&gt;\n&lt;request subst=&quot;true&quot;&gt;\n  &lt;dyn_variable name=&quot;redirect1&quot; re=&quot;Location: ((http|https)://.*)\\r&quot;/&gt;\n  &lt;http url=&quot;@api&quot; method=&quot;@method&quot; contents=&quot;@contents&quot; version=&quot;1.1&quot;&gt;&lt;/http&gt;\n&lt;/request&gt;\n\n&lt;if var=&quot;redirect1&quot; neq=&quot;&quot;&gt;\n  &lt;request subst=&quot;true&quot;&gt;\n&lt;!-- 这里可以使用xpath提取页面中的元素值 --&gt;\n&lt;dyn_variable name=&quot;lt&quot; xpath=&quot;//input[@name=&apos;lt&apos;]/@value&quot;/&gt;\n&lt;dyn_variable name=&quot;s_uuid&quot; xpath=&quot;//input[@name=&apos;s_uuid&apos;]/@value&quot;/&gt;\n&lt;dyn_variable name=&quot;eventId&quot; xpath=&quot;//input[@name=&apos;_eventId&apos;]/@value&quot;/&gt;\n&lt;http url=&quot;%%_redirect1%%&quot; method=&quot;GET&quot;&gt;&lt;/http&gt;\n  &lt;/request&gt;\n\n  &lt;request subst=&quot;true&quot;&gt;\n&lt;dyn_variable name=&quot;redirect2&quot; re=&quot;Location: (http://.*)\\r&quot;/&gt;\n&lt;http url=&quot;%%_redirect1%%&quot; method=&quot;POST&quot; contents=&quot;username=%%_username%%&amp;amp;password=%%_password%%&amp;amp;lt=%%_lt%%&amp;amp;s_uuid=%%_s_uuid%%&amp;amp;_eventId=%%_eventId%%&amp;amp;j_captcha_response=&apos;&apos;&quot;&gt;&lt;/http&gt;\n  &lt;/request&gt;\n\n  &lt;request subst=&quot;true&quot;&gt;\n&lt;dyn_variable name=&quot;redirect3&quot; re=&quot;Location: (http://.*)\\r&quot;/&gt;\n&lt;http url=&quot;%%_redirect2%%&quot; method=&quot;GET&quot;&gt;&lt;/http&gt;\n  &lt;/request&gt;\n\n  &lt;request subst=&quot;true&quot;&gt;\n&lt;http url=&quot;%%_redirect3%%&quot; method=&quot;@method&quot; contents=&quot;@contents&quot;&gt;&lt;/http&gt;\n  &lt;/request&gt;\n&lt;/if&gt;\n</code></pre><p>4、通过shell控制tsung</p>\n<p>如果每次使用tsung -f tsung.xml start运行tsung，那么每次修改测试接口或者压力改变都需要修改xml，非常麻烦，我写了一个shell脚本，替换上面的tsung.xml中以@开头的变量</p>\n<pre><code>#!/bin/bash\ndefaultTestFile=&quot;$HOME/tsung_test.xml&quot;\ndefaultUser=20\ndefaultDuration=100\n# s\ndefaultThinktime=1\ndefaultServer=&quot;tomcat1&quot;\ndefaultPort=9000\ndefaultApi=&quot;/test&quot;\ndefaultMethod=&quot;POST&quot;\ndefaultLoopCount=50\ndefaultMaxuser=5000\n\nwhile [ $# -gt 0 ]; do\n  case &quot;$1&quot; in\n-f|--testFile)\ntestFile=$2\nshift \nshift ;;\n-u|--user)\nuser=$2\nshift \nshift ;;\n-d|--duration)\nduration=$2\nshift \nshift ;;\n-t|--thinktime)\nthinktime=$2\nshift \nshift ;;\n-s|--server)\nserver=$2\nshift \nshift ;;\n-p|--port)\nport=$2\nshift \nshift ;;\n-a|--api)\napi=$2\nshift \nshift ;;\n-m|--method)\nmethod=$2\nshift \nshift ;;\n-l|--loopCount)\nloopCount=$2\nshift \nshift ;;\n-x|--maxuser)\nmaxuser=$2\nshift \nshift ;;\n-h|--help)\necho &quot;-f | --testFile: tsung test file xml,default $defaultTestFile&quot;\necho &quot;-u | --user: user number per second, default $defaultUser&quot;\necho &quot;-x | --maxuser: max user number, default $defaultMaxuser&quot;\necho &quot;-d | --duration: times used to generate user,default $defaultDuration s&quot;\necho &quot;-t | --thinktime: the inteval time between two request,default $defaultThinktime s&quot;\necho &quot;-l | --loopCount: Each user&apos;s request number,default $defaultLoopCount&quot;\necho &quot;-s | --server: play server,default $defaultServer&quot;\necho &quot;-p | --port: play server http port,default $defaultPort&quot;\necho &quot;-a | --api: api, default $defaultApi&quot;\necho &quot;-m | --method: POST/GET,default $defaultMethod&quot;\necho &quot;-h | --help: print this help&quot;\nshift\nexit 1\n;;\n--)\n  shift\n  break\n  ;;\n*)\n  echo &quot;wrong input:$1,use -h or --help see how to use&quot; 1&gt;&amp;2\n  exit 1\n  ;;\n  esac\ndone\n\nprocessName=&quot;tsung&quot;\npid=`ps aux | grep $processName | grep -v grep | awk &apos;{print $2}&apos;`\n#convert from string to array\npid=($pid)\nif [ ${#pid[*]} -gt 3 ]; then\n  echo &quot;warning!!! a $processName process is running,please wait&quot;\n  exit 1\nfi\n\n#env\n#set default parameters\ntestFile=${testFile:=$defaultTestFile}\nuser=${user:=$defaultUser}\nduration=${duration:=$defaultDuration}\nthinktime=${thinktime:=$defaultThinktime}\nserver=${server:=$defaultServer}\nport=${port:=$defaultPort}\napi=${api:=$defaultApi}\nmethod=${method:=$defaultMethod}\nloopCount=${loopCount:=$defaultLoopCount}\nmaxuser=${maxuser:=$defaultMaxuser}\n\n#key of params is nodname in tusng_test.xml file\ndeclare -A params\nparams=( \\\n  [&quot;user&quot;]=$user \\\n  [&quot;maxuser&quot;]=$maxuser \\\n  [&quot;duration&quot;]=$duration \\\n  [&quot;thinktime&quot;]=$thinktime \\\n  [&quot;server&quot;]=$server \\\n  [&quot;port&quot;]=$port \\\n  [&quot;api&quot;]=$api \\\n  [&quot;method&quot;]=$method \\\n  [&quot;loopCount&quot;]=$loopCount \\\n  )\nreportPath=&quot;$HOME/.tsung/log&quot;\ncurrentTest=`date +%Y%m%d-%H%M`\nreportPath=&quot;$reportPath/$currentTest&quot;\nmkdir -p $reportPath\n#deal with jmx file\ncp $testFile $reportPath\ncurrentTestFile=&quot;$reportPath/tsung_test.xml&quot;\nfunction replace(){\n  echo &quot;$1:$2&quot; | tee -a &quot;$reportPath/test.env&quot;\n  #change / to \\/ for sed \n  local val=${2//\\//\\\\\\/}\n  sed -i &quot;s/@${1}/${val}/&quot; $currentTestFile\n}\nfor key in ${!params[*]}\ndo\n  replace $key ${params[$key]}\ndone\n#start tsung \ntsung -f $currentTestFile start &amp;\nwait %1\ncd $reportPath\n/usr/local/lib/tsung/bin/tsung_stats.pl\n</code></pre><p>5、tsung结果分析</p>\n<p>tsung生成的测试报告都放在$HOME/.tsung/log下，以日期加时间的方式命名，如：<code>.tsung/log/20150407-1951</code>，其中最重要的几张图是</p>\n<ul>\n<li>tsung产生的用户数曲线图 .tsung/log/20150407-1951/images/graphes-Users-simultaneous.png<br><img src=\"http://static.oschina.net/uploads/space/2015/0706/135050_sSxO_780347.png\" alt=\"\"></li>\n</ul>\n<p>Y轴代表每秒用户数，tsung每秒会产生一批用户，这个统计结果是每十秒统计一次，所有的图的起始位置显示的是0，其实是第一个10秒</p>\n<ul>\n<li><p>http接口响应数曲线图（TPS） .tsung/log/20150407-1951/images/graphes-HTTP_CODE-rate.png<br><img src=\"http://static.oschina.net/uploads/space/2015/0706/135106_dKTc_780347.png\" alt=\"\"></p>\n<p>Y轴是每秒响应数，右上角的200是http状态码，如果有多个状态码，会有多条不同颜色的曲线。</p>\n</li>\n<li><p>http接口响应时间曲线图 .tsung/log/20150407-1951/images/graphes-Perfs-mean.png</p>\n</li>\n</ul>\n<p><img src=\"http://static.oschina.net/uploads/space/2015/0706/135120_sPqf_780347.png\" alt=\"\"></p>\n<p>  Y轴是接口响应时间，单位是毫秒，request的线代表请求响应总耗时，connect的线代表tcp链接建立的时间。</p>\n<p>6、主要统计信息<br>Tsung统计数据是平均每十秒重置一次，所以这里的响应时间（连接、请求、页面、会话）是指每十秒的平均响应时间；<br>connect： 表示 每个连接持续时间；<br>Hightest 10sec mean    连接最长持续时间<br>Lowest 10sec mean    连接最短持续时间<br>Highest rate     每秒最高建立连接速率<br>Mean    平均每个连接持续时间<br>Count    总连接数<br>page： 表示 每个请求集合的响应时间,（一个页面表示一组没有被thinktime间隔的请求）<br>request： 表示 每个请求的响应时间；<br>Hightest 10sec mean    请求最长响应时间<br>Lowest 10sec mean    请求最短响应时间<br>Highest rate     请求最快发送速率<br>Mean    平均每个请求响应时间<br>Count    总请求数<br>session： 表示 每个用户会话持续时间；<br>Hightest 10sec mean    会话最长持续时间<br>Lowest 10sec mean    会话最短持续时间<br>Highest rate     每秒最高进行会话速率<br>Mean    平均每个会话持续时间<br>Count    总会话数  </p>\n<p>7、数据流量统计<br>size_rcv: 表示 响应请求数据量<br>size_sent:表示 发送请求数据量<br>Hightest rate    每秒最高 响应/发送 请求数据量<br>Total     响应/发送 请求总数据量  </p>\n<p>8、计数统计<br>connected    表示会话开始且尚未结束，并且已建立连接的最大用户数<br>finished_user_count    表示已经完成会话的最大用户数<br>users    表示会话开始且尚未结束的最大用户数<br>users_count    表示Tsung总共生成的用户总数  </p>\n<p>9、错误统计<br>Error_abort_max_conn_retries    重新尝试连接错误<br>Error_connect_timeout    连接超时错误<br>Error_connect_nxdomain    不存在的域错误<br>Error_unknown    位置错误  </p>\n<p>Highest rate     发生错误最高速率<br>Total number    发生该错误总个数  </p>\n<p>10、http返回状态码统计<br>200：表示客户端请求已成功响应<br>Highest rate    状态码返回最高速率<br>Total number    返回状态码的总个数  </p>\n","excerpt":"<p>1、tsung安装</p>\n<p>tsung 一个非常优秀的压力测试工具，在8核32G机器上可以轻易的产生每秒10000个并发请求，且占用的资源很少，当前版本1.5.0<br>","more":"<br>使用erlang开发，需要先安装erlang虚拟机。安装过程略</p>\n<p>2、tsung使用<br>$ tsung -f ./tsung/tsung.xml sta</p>\n<p>3、tusng.xml</p>\n<p>下面是我自己的tsung.xml</p>\n<pre><code>    &lt;?xml version=&quot;1.0&quot;?&gt;\n&lt;!DOCTYPE tsung SYSTEM &quot;/usr/local/share/tsung/tsung-1.0.dtd&quot;&gt;\n&lt;!-- dumptraffic是调试模式，如果为true，就会打印详细的请求返回信息，一般设置为false， --&gt;\n&lt;tsung loglevel=&quot;notice&quot; dumptraffic=&quot;false&quot; version=&quot;1.0&quot;&gt;\n&lt;!-- tsung所在的服务器，maxusers就是tsung产生的最大用户数 --&gt;\n  &lt;clients&gt;\n&lt;client host=&quot;localhost&quot; use_controller_vm=&quot;true&quot;  maxusers=&quot;100000&quot; /&gt;\n  &lt;/clients&gt;\n&lt;!-- 被测服务器的ip和端口号，type一般设为tcp -&gt;\n  &lt;servers&gt;\n&lt;server host=&quot;@server&quot; port=&quot;@port&quot; type=&quot;tcp&quot;/&gt;\n  &lt;/servers&gt;\n&lt;!-- tsung产生的压力 --&gt;\n&lt;load&gt;\n&lt;!-- phase=&quot;1&quot; 第一阶段；duration：测试持续时间；unit：单位秒 --&gt;\n&lt;arrivalphase phase=&quot;1&quot; duration=&quot;@duration&quot; unit=&quot;second&quot;&gt;\n&lt;!-- maxnumber：最大用户数；arrivalrate：每秒新增用户数；unit：单位秒--&gt;\n  &lt;users maxnumber=&quot;@maxuser&quot; arrivalrate=&quot;@user&quot; unit=&quot;second&quot;/&gt;\n&lt;/arrivalphase&gt;\n  &lt;/load&gt;\n&lt;!-- 外部变量 --&gt;\n  &lt;options&gt;\n&lt;!-- 引入一个外部文件，类型为file_server，变量名为userfile，文件路径：/tmp/users--&gt;\n&lt;!-- 文件是以逗号分隔的csv文件 --&gt;\n&lt;option name=&quot;file_server&quot; id=&quot;userfile&quot; value=&quot;/tmp/users&quot;/&gt;\n  &lt;/options&gt;\n&lt;!-- 会话，每个用户都按照sessions中的配置发送请求 --&gt;\n  &lt;sessions&gt;\n&lt;!--probability=“100”:这个session的请求概率是100%，如果要同时测多个api，可以设置请求概率；请求类型为http --&gt;\n&lt;session name=&quot;test&quot; probability=&quot;100&quot; type=&quot;ts_http&quot;&gt;\n&lt;!-- 请求次数，to是最大请求数，如果设为100，就是每个用户请求100次 --&gt;\n  &lt;for from=&quot;1&quot; to=&quot;@loop&quot; incr=&quot;1&quot; var=&quot;counter&quot;&gt;\n&lt;!-- 解析前面引入的外部文件，以逗号做为分隔符，随机读取 --&gt;\n&lt;setdynvars sourcetype=&quot;file&quot; fileid=&quot;userfile&quot; delimiter=&quot;,&quot; order=&quot;random&quot;&gt;\n  &lt;var name=&quot;user_id&quot; /&gt;\n  &lt;var name=&quot;passwd&quot; /&gt;\n  &lt;var name=&quot;auth_token&quot; /&gt;\n&lt;/setdynvars&gt;\n&lt;!-- 返回随机小数，变量名为decimal，code中可以写erlang函数 --&gt;\n&lt;setdynvars sourcetype=&quot;eval&quot; code=&quot;fun({Pid,DynVars}) -&gt; random:uniform() end.&quot;&gt;\n  &lt;var name=&quot;decimal&quot; /&gt;\n&lt;/setdynvars&gt;\n&lt;!-- 返回随机数，从1到10000 --&gt;\n&lt;setdynvars sourcetype=&quot;random_number&quot; start=&quot;1&quot; end=&quot;10000&quot;&gt;\n   &lt;var name=&quot;int_1_10000&quot; /&gt;\n&lt;/setdynvars&gt;\n&lt;!-- 返回随机字符串，长度为10 --&gt;\n&lt;setdynvars sourcetype=&quot;random_string&quot; length=&quot;10&quot;&gt;\n   &lt;var name=&quot;string_10&quot; /&gt;\n&lt;/setdynvars&gt;\n&lt;!-- subst=&quot;true&quot;：如果在request中使用变量，需要设置subst --&gt;\n&lt;request subst=&quot;true&quot;&gt;\n&lt;!-- url：被测试的url；method：GET、POST等；contents：POST请求的参数 --&gt;\n  &lt;http url=&quot;@api&quot; method=&quot;@method&quot; contents=&quot;@contents&quot; version=&quot;1.1&quot;&gt;\n&lt;!-- http header，可以添加Authorization、Cookie等，注意变量的使用格式：%%_xxx%% --&gt;\n&lt;http_header name=&quot;Authorization&quot; value=&quot;111&quot;/&gt;\n&lt;http_header name=&quot;Cookie&quot; value=&quot;authToken=%%_auth_token%%; Path=/&quot;/&gt;\n&lt;!-- content-Type：POST请求参数的格式，如果是json格式可以这样写 --&gt;\n&lt;http_header name=&quot;Content-Type&quot; value=&quot;application/json&quot;/&gt;\n  &lt;/http&gt;\n&lt;/request&gt;\n&lt;!-- thinktime：两次请求之间的间隔时间，一般小于10s --&gt;\n&lt;thinktime value=&quot;1&quot;/&gt;\n  &lt;/for&gt;\n&lt;/session&gt;\n  &lt;/sessions&gt;\n&lt;/tsung&gt; \n</code></pre><p>如果被测接口需要登录跳转，可以指明跳转条件：   </p>\n<pre><code>&lt;!-- if need login, http 302 will be return --&gt;\n&lt;request subst=&quot;true&quot;&gt;\n  &lt;dyn_variable name=&quot;redirect1&quot; re=&quot;Location: ((http|https)://.*)\\r&quot;/&gt;\n  &lt;http url=&quot;@api&quot; method=&quot;@method&quot; contents=&quot;@contents&quot; version=&quot;1.1&quot;&gt;&lt;/http&gt;\n&lt;/request&gt;\n\n&lt;if var=&quot;redirect1&quot; neq=&quot;&quot;&gt;\n  &lt;request subst=&quot;true&quot;&gt;\n&lt;!-- 这里可以使用xpath提取页面中的元素值 --&gt;\n&lt;dyn_variable name=&quot;lt&quot; xpath=&quot;//input[@name=&apos;lt&apos;]/@value&quot;/&gt;\n&lt;dyn_variable name=&quot;s_uuid&quot; xpath=&quot;//input[@name=&apos;s_uuid&apos;]/@value&quot;/&gt;\n&lt;dyn_variable name=&quot;eventId&quot; xpath=&quot;//input[@name=&apos;_eventId&apos;]/@value&quot;/&gt;\n&lt;http url=&quot;%%_redirect1%%&quot; method=&quot;GET&quot;&gt;&lt;/http&gt;\n  &lt;/request&gt;\n\n  &lt;request subst=&quot;true&quot;&gt;\n&lt;dyn_variable name=&quot;redirect2&quot; re=&quot;Location: (http://.*)\\r&quot;/&gt;\n&lt;http url=&quot;%%_redirect1%%&quot; method=&quot;POST&quot; contents=&quot;username=%%_username%%&amp;amp;password=%%_password%%&amp;amp;lt=%%_lt%%&amp;amp;s_uuid=%%_s_uuid%%&amp;amp;_eventId=%%_eventId%%&amp;amp;j_captcha_response=&apos;&apos;&quot;&gt;&lt;/http&gt;\n  &lt;/request&gt;\n\n  &lt;request subst=&quot;true&quot;&gt;\n&lt;dyn_variable name=&quot;redirect3&quot; re=&quot;Location: (http://.*)\\r&quot;/&gt;\n&lt;http url=&quot;%%_redirect2%%&quot; method=&quot;GET&quot;&gt;&lt;/http&gt;\n  &lt;/request&gt;\n\n  &lt;request subst=&quot;true&quot;&gt;\n&lt;http url=&quot;%%_redirect3%%&quot; method=&quot;@method&quot; contents=&quot;@contents&quot;&gt;&lt;/http&gt;\n  &lt;/request&gt;\n&lt;/if&gt;\n</code></pre><p>4、通过shell控制tsung</p>\n<p>如果每次使用tsung -f tsung.xml start运行tsung，那么每次修改测试接口或者压力改变都需要修改xml，非常麻烦，我写了一个shell脚本，替换上面的tsung.xml中以@开头的变量</p>\n<pre><code>#!/bin/bash\ndefaultTestFile=&quot;$HOME/tsung_test.xml&quot;\ndefaultUser=20\ndefaultDuration=100\n# s\ndefaultThinktime=1\ndefaultServer=&quot;tomcat1&quot;\ndefaultPort=9000\ndefaultApi=&quot;/test&quot;\ndefaultMethod=&quot;POST&quot;\ndefaultLoopCount=50\ndefaultMaxuser=5000\n\nwhile [ $# -gt 0 ]; do\n  case &quot;$1&quot; in\n-f|--testFile)\ntestFile=$2\nshift \nshift ;;\n-u|--user)\nuser=$2\nshift \nshift ;;\n-d|--duration)\nduration=$2\nshift \nshift ;;\n-t|--thinktime)\nthinktime=$2\nshift \nshift ;;\n-s|--server)\nserver=$2\nshift \nshift ;;\n-p|--port)\nport=$2\nshift \nshift ;;\n-a|--api)\napi=$2\nshift \nshift ;;\n-m|--method)\nmethod=$2\nshift \nshift ;;\n-l|--loopCount)\nloopCount=$2\nshift \nshift ;;\n-x|--maxuser)\nmaxuser=$2\nshift \nshift ;;\n-h|--help)\necho &quot;-f | --testFile: tsung test file xml,default $defaultTestFile&quot;\necho &quot;-u | --user: user number per second, default $defaultUser&quot;\necho &quot;-x | --maxuser: max user number, default $defaultMaxuser&quot;\necho &quot;-d | --duration: times used to generate user,default $defaultDuration s&quot;\necho &quot;-t | --thinktime: the inteval time between two request,default $defaultThinktime s&quot;\necho &quot;-l | --loopCount: Each user&apos;s request number,default $defaultLoopCount&quot;\necho &quot;-s | --server: play server,default $defaultServer&quot;\necho &quot;-p | --port: play server http port,default $defaultPort&quot;\necho &quot;-a | --api: api, default $defaultApi&quot;\necho &quot;-m | --method: POST/GET,default $defaultMethod&quot;\necho &quot;-h | --help: print this help&quot;\nshift\nexit 1\n;;\n--)\n  shift\n  break\n  ;;\n*)\n  echo &quot;wrong input:$1,use -h or --help see how to use&quot; 1&gt;&amp;2\n  exit 1\n  ;;\n  esac\ndone\n\nprocessName=&quot;tsung&quot;\npid=`ps aux | grep $processName | grep -v grep | awk &apos;{print $2}&apos;`\n#convert from string to array\npid=($pid)\nif [ ${#pid[*]} -gt 3 ]; then\n  echo &quot;warning!!! a $processName process is running,please wait&quot;\n  exit 1\nfi\n\n#env\n#set default parameters\ntestFile=${testFile:=$defaultTestFile}\nuser=${user:=$defaultUser}\nduration=${duration:=$defaultDuration}\nthinktime=${thinktime:=$defaultThinktime}\nserver=${server:=$defaultServer}\nport=${port:=$defaultPort}\napi=${api:=$defaultApi}\nmethod=${method:=$defaultMethod}\nloopCount=${loopCount:=$defaultLoopCount}\nmaxuser=${maxuser:=$defaultMaxuser}\n\n#key of params is nodname in tusng_test.xml file\ndeclare -A params\nparams=( \\\n  [&quot;user&quot;]=$user \\\n  [&quot;maxuser&quot;]=$maxuser \\\n  [&quot;duration&quot;]=$duration \\\n  [&quot;thinktime&quot;]=$thinktime \\\n  [&quot;server&quot;]=$server \\\n  [&quot;port&quot;]=$port \\\n  [&quot;api&quot;]=$api \\\n  [&quot;method&quot;]=$method \\\n  [&quot;loopCount&quot;]=$loopCount \\\n  )\nreportPath=&quot;$HOME/.tsung/log&quot;\ncurrentTest=`date +%Y%m%d-%H%M`\nreportPath=&quot;$reportPath/$currentTest&quot;\nmkdir -p $reportPath\n#deal with jmx file\ncp $testFile $reportPath\ncurrentTestFile=&quot;$reportPath/tsung_test.xml&quot;\nfunction replace(){\n  echo &quot;$1:$2&quot; | tee -a &quot;$reportPath/test.env&quot;\n  #change / to \\/ for sed \n  local val=${2//\\//\\\\\\/}\n  sed -i &quot;s/@${1}/${val}/&quot; $currentTestFile\n}\nfor key in ${!params[*]}\ndo\n  replace $key ${params[$key]}\ndone\n#start tsung \ntsung -f $currentTestFile start &amp;\nwait %1\ncd $reportPath\n/usr/local/lib/tsung/bin/tsung_stats.pl\n</code></pre><p>5、tsung结果分析</p>\n<p>tsung生成的测试报告都放在$HOME/.tsung/log下，以日期加时间的方式命名，如：<code>.tsung/log/20150407-1951</code>，其中最重要的几张图是</p>\n<ul>\n<li>tsung产生的用户数曲线图 .tsung/log/20150407-1951/images/graphes-Users-simultaneous.png<br><img src=\"http://static.oschina.net/uploads/space/2015/0706/135050_sSxO_780347.png\" alt=\"\"></li>\n</ul>\n<p>Y轴代表每秒用户数，tsung每秒会产生一批用户，这个统计结果是每十秒统计一次，所有的图的起始位置显示的是0，其实是第一个10秒</p>\n<ul>\n<li><p>http接口响应数曲线图（TPS） .tsung/log/20150407-1951/images/graphes-HTTP_CODE-rate.png<br><img src=\"http://static.oschina.net/uploads/space/2015/0706/135106_dKTc_780347.png\" alt=\"\"></p>\n<p>Y轴是每秒响应数，右上角的200是http状态码，如果有多个状态码，会有多条不同颜色的曲线。</p>\n</li>\n<li><p>http接口响应时间曲线图 .tsung/log/20150407-1951/images/graphes-Perfs-mean.png</p>\n</li>\n</ul>\n<p><img src=\"http://static.oschina.net/uploads/space/2015/0706/135120_sPqf_780347.png\" alt=\"\"></p>\n<p>  Y轴是接口响应时间，单位是毫秒，request的线代表请求响应总耗时，connect的线代表tcp链接建立的时间。</p>\n<p>6、主要统计信息<br>Tsung统计数据是平均每十秒重置一次，所以这里的响应时间（连接、请求、页面、会话）是指每十秒的平均响应时间；<br>connect： 表示 每个连接持续时间；<br>Hightest 10sec mean    连接最长持续时间<br>Lowest 10sec mean    连接最短持续时间<br>Highest rate     每秒最高建立连接速率<br>Mean    平均每个连接持续时间<br>Count    总连接数<br>page： 表示 每个请求集合的响应时间,（一个页面表示一组没有被thinktime间隔的请求）<br>request： 表示 每个请求的响应时间；<br>Hightest 10sec mean    请求最长响应时间<br>Lowest 10sec mean    请求最短响应时间<br>Highest rate     请求最快发送速率<br>Mean    平均每个请求响应时间<br>Count    总请求数<br>session： 表示 每个用户会话持续时间；<br>Hightest 10sec mean    会话最长持续时间<br>Lowest 10sec mean    会话最短持续时间<br>Highest rate     每秒最高进行会话速率<br>Mean    平均每个会话持续时间<br>Count    总会话数  </p>\n<p>7、数据流量统计<br>size_rcv: 表示 响应请求数据量<br>size_sent:表示 发送请求数据量<br>Hightest rate    每秒最高 响应/发送 请求数据量<br>Total     响应/发送 请求总数据量  </p>\n<p>8、计数统计<br>connected    表示会话开始且尚未结束，并且已建立连接的最大用户数<br>finished_user_count    表示已经完成会话的最大用户数<br>users    表示会话开始且尚未结束的最大用户数<br>users_count    表示Tsung总共生成的用户总数  </p>\n<p>9、错误统计<br>Error_abort_max_conn_retries    重新尝试连接错误<br>Error_connect_timeout    连接超时错误<br>Error_connect_nxdomain    不存在的域错误<br>Error_unknown    位置错误  </p>\n<p>Highest rate     发生错误最高速率<br>Total number    发生该错误总个数  </p>\n<p>10、http返回状态码统计<br>200：表示客户端请求已成功响应<br>Highest rate    状态码返回最高速率<br>Total number    返回状态码的总个数  </p>"},{"title":"yum仓库搭建之RPM包制作","date":"2016-11-05T04:00:00.000Z","_content":" 常见的软件安装方式有以下几种  \n1.yum安装，可自动解决依赖，但不能自定义软件安装位置  \n2.编译安装，可指定安装路径，指定装模块，但编译参数冗长，且耗时较长，不能解决依赖问题。  \n<!--more-->\n3.rpm安装，安装速度较速，但不能自动解决依赖，尤其是遇到需要的依赖包较多时，特别费时。  \n本文主要介绍利用fpm工具制作个性化的rpm包，后期可放到yum仓库中，直接用yum安装。  \n【fpm介绍】  \n项目地址：https://github.com/jordansissel/fpm  \n作者把这个fpm称作Effing Package Management，翻译过来就是该死的包管理器，粗暴一点就是去他妈的包管理器。Ubuntu及CentOS的包管理及安装方式完全不同，要想同时掌握这两种平台下的软件包安装方法是很困难的，为了不再遭受这痛苦，fpm便应运而生了。fpm是由jordansissel于2011年开发的一套打包工具，可快速度地将你安装好的程序目录或包打包为rpm及deb等结尾软件包。与传统的打包工具(rpmbuild、dh_make)相比，制作起来更加简单、方便、快捷。  \n【fpm安装】  \n1.安装ruby及gcc    \n\n    yum install ruby-devel gcc  \n2.安装fpm    \n\n    gem install fpm  \n3.fpm打包   \n语法格式  \n\n    fpm -s <source type> -t <target type> [options]  \n其中源类型主要有：dir、gem、rpm、python等，目标类型主要有rpm,deb,puppet,solaris等。  \n-s指定输入的包类型  \n-t指定输出包的类型  \n-n, --name指定输出的包名  \n-v, --version指定版本号，默认为1.0  \n-d, --depends指定依赖包，可重复多次出现，通常以\"-d 'name' or -d 'name > version'\"的形式展现。  \n-f, --force强制输出，会覆盖掉旧包  \n-p, --package OUTPUT 指定输出目录  \n【打包实例】  \n定制cron初始化rpm包    \n\n    $fpm -s dir -t rpm -a noarch -p /root/ -n cron-init-script -v 1.0 /var/spool/cron/  \n    no value for epoch is set, defaulting to nil {:level=>:warn}  \n    no value for epoch is set, defaulting to nil {:level=>:warn}  \n    Created package {:path=>\"/root/cron-init-script-1.0-1.noarch.rpm\"}  \n    $ll /root/cron-init-script-1.0-1.noarch.rpm   \n    -rw-r--r-- 1 root root 1693 Nov  2 22:24 /root/cron-init-script-1.0-1.noarch.rpm  \n在客户端yum安装cron-init-script  \n\n    yum install cron-init-scipt\n\n【升级RPM包】  \n1.编辑cron任务  \n\n    $crontab -l  \n    */5 * * * * /usr/sbin/ntpdate pool.ntp.org >/dev/null 2>&1  \n    */10 * * * * /usr/sbin/ntpdate 1.pool.ntp.org >/dev/null 2>&1  \n\n2.重新生成包\n    \n    fpm -s dir -t rpm -a noarch -p /tools/fpm/ -n cron-init-script -v 1.1 /var/spool/cron/\n\n  \n\nyum仓库搭建之RPM包制作  \n3.传到yum仓库  \n\n    $cp cron-init-script-1.1-1.noarch.rpm /application/yum/centos6.6/x86_64/ \n\n4.更新yum仓库索引  \n\n    $createrepo --update /application/yum/centos6.6/x86_64/\n    Spawning worker 0 with 1 pkgs  \n    Workers Finished  \n    Gathering worker results  \n    Saving Primary metadata  \n    Saving file lists metadata  \n    Saving other metadata  \n    Generating sqlite DBs  \n    Sqlite DBs complete  \n5.客户端清空yum缓存    \n\n    ###yum clean all  \n    Loaded plugins: fastestmirror, security  \n    Cleaning repos: oldboy  \n    Cleaning up Everything   \n    Cleaning up list of fastest mirrors  \n6.查找cron包  \n\n    # yum list |grep cron-init  \n    cron-init-script.noarch 1.0-1  @oldboy#前面的@表示已经安装过，保留下来的信息   \n    cron-init-script.noarch 1.1-1  oldboy   \n7.更新cron包  \n    \n    # crontab -l  \n    */5 * * * * /usr/sbin/ntpdate pool.ntp.org >/dev/null 2>&1  \n    # yum update cron-init-script  \n    Is this ok [y/N]: y  \n    Running Transaction  \n      Updating  : cron-init-script-1.1-1.noarch1/2   \n      Cleanup: cron-init-script-1.0-1.noarch2/2   \n      Verifying  : cron-init-script-1.1-1.noarch1/2   \n      Verifying  : cron-init-script-1.0-1.noarch2/2  \n    Updated:  \n      cron-init-script.noarch 0:1.1-1 \n    Complete!  \n    # crontab -l  \n    */5 * * * * /usr/sbin/ntpdate pool.ntp.org >/dev/null 2>&1  \n    */10 * * * * /usr/sbin/ntpdate 1.pool.ntp.org >/dev/null 2>&1  \ncron任务已更新。  \n    \n    \n    fpm -f -s dir -t rpm -n easemob-sersync-ssy -v 2.5.4_64bit  --iteration 1.el6.centos -a native \\  \n    -C /tmp/easemob-serync \\  \n    --vendor 'sam@easemob.com' \\  \n    --description 'Ejabberd packager by easemob.com' \\  \n    --url 'https://github.com/easemob/serync/' \\  \n    --rpm-user easemob \\  \n    --rpm-group easemob \\  \n    --verbose \\  \n    --epoch 20160616  \n    \n    \n    \n    createrepo /data/apps/data/nginx/yum/ssy/ssy201606/x86_64/6/easemob-ssy/packages/\n    ","source":"_posts/yum仓库搭建之RPM包制作.md","raw":"---\ntitle: yum仓库搭建之RPM包制作\ndate: 2016-11-05\ntags:\n---\n 常见的软件安装方式有以下几种  \n1.yum安装，可自动解决依赖，但不能自定义软件安装位置  \n2.编译安装，可指定安装路径，指定装模块，但编译参数冗长，且耗时较长，不能解决依赖问题。  \n<!--more-->\n3.rpm安装，安装速度较速，但不能自动解决依赖，尤其是遇到需要的依赖包较多时，特别费时。  \n本文主要介绍利用fpm工具制作个性化的rpm包，后期可放到yum仓库中，直接用yum安装。  \n【fpm介绍】  \n项目地址：https://github.com/jordansissel/fpm  \n作者把这个fpm称作Effing Package Management，翻译过来就是该死的包管理器，粗暴一点就是去他妈的包管理器。Ubuntu及CentOS的包管理及安装方式完全不同，要想同时掌握这两种平台下的软件包安装方法是很困难的，为了不再遭受这痛苦，fpm便应运而生了。fpm是由jordansissel于2011年开发的一套打包工具，可快速度地将你安装好的程序目录或包打包为rpm及deb等结尾软件包。与传统的打包工具(rpmbuild、dh_make)相比，制作起来更加简单、方便、快捷。  \n【fpm安装】  \n1.安装ruby及gcc    \n\n    yum install ruby-devel gcc  \n2.安装fpm    \n\n    gem install fpm  \n3.fpm打包   \n语法格式  \n\n    fpm -s <source type> -t <target type> [options]  \n其中源类型主要有：dir、gem、rpm、python等，目标类型主要有rpm,deb,puppet,solaris等。  \n-s指定输入的包类型  \n-t指定输出包的类型  \n-n, --name指定输出的包名  \n-v, --version指定版本号，默认为1.0  \n-d, --depends指定依赖包，可重复多次出现，通常以\"-d 'name' or -d 'name > version'\"的形式展现。  \n-f, --force强制输出，会覆盖掉旧包  \n-p, --package OUTPUT 指定输出目录  \n【打包实例】  \n定制cron初始化rpm包    \n\n    $fpm -s dir -t rpm -a noarch -p /root/ -n cron-init-script -v 1.0 /var/spool/cron/  \n    no value for epoch is set, defaulting to nil {:level=>:warn}  \n    no value for epoch is set, defaulting to nil {:level=>:warn}  \n    Created package {:path=>\"/root/cron-init-script-1.0-1.noarch.rpm\"}  \n    $ll /root/cron-init-script-1.0-1.noarch.rpm   \n    -rw-r--r-- 1 root root 1693 Nov  2 22:24 /root/cron-init-script-1.0-1.noarch.rpm  \n在客户端yum安装cron-init-script  \n\n    yum install cron-init-scipt\n\n【升级RPM包】  \n1.编辑cron任务  \n\n    $crontab -l  \n    */5 * * * * /usr/sbin/ntpdate pool.ntp.org >/dev/null 2>&1  \n    */10 * * * * /usr/sbin/ntpdate 1.pool.ntp.org >/dev/null 2>&1  \n\n2.重新生成包\n    \n    fpm -s dir -t rpm -a noarch -p /tools/fpm/ -n cron-init-script -v 1.1 /var/spool/cron/\n\n  \n\nyum仓库搭建之RPM包制作  \n3.传到yum仓库  \n\n    $cp cron-init-script-1.1-1.noarch.rpm /application/yum/centos6.6/x86_64/ \n\n4.更新yum仓库索引  \n\n    $createrepo --update /application/yum/centos6.6/x86_64/\n    Spawning worker 0 with 1 pkgs  \n    Workers Finished  \n    Gathering worker results  \n    Saving Primary metadata  \n    Saving file lists metadata  \n    Saving other metadata  \n    Generating sqlite DBs  \n    Sqlite DBs complete  \n5.客户端清空yum缓存    \n\n    ###yum clean all  \n    Loaded plugins: fastestmirror, security  \n    Cleaning repos: oldboy  \n    Cleaning up Everything   \n    Cleaning up list of fastest mirrors  \n6.查找cron包  \n\n    # yum list |grep cron-init  \n    cron-init-script.noarch 1.0-1  @oldboy#前面的@表示已经安装过，保留下来的信息   \n    cron-init-script.noarch 1.1-1  oldboy   \n7.更新cron包  \n    \n    # crontab -l  \n    */5 * * * * /usr/sbin/ntpdate pool.ntp.org >/dev/null 2>&1  \n    # yum update cron-init-script  \n    Is this ok [y/N]: y  \n    Running Transaction  \n      Updating  : cron-init-script-1.1-1.noarch1/2   \n      Cleanup: cron-init-script-1.0-1.noarch2/2   \n      Verifying  : cron-init-script-1.1-1.noarch1/2   \n      Verifying  : cron-init-script-1.0-1.noarch2/2  \n    Updated:  \n      cron-init-script.noarch 0:1.1-1 \n    Complete!  \n    # crontab -l  \n    */5 * * * * /usr/sbin/ntpdate pool.ntp.org >/dev/null 2>&1  \n    */10 * * * * /usr/sbin/ntpdate 1.pool.ntp.org >/dev/null 2>&1  \ncron任务已更新。  \n    \n    \n    fpm -f -s dir -t rpm -n easemob-sersync-ssy -v 2.5.4_64bit  --iteration 1.el6.centos -a native \\  \n    -C /tmp/easemob-serync \\  \n    --vendor 'sam@easemob.com' \\  \n    --description 'Ejabberd packager by easemob.com' \\  \n    --url 'https://github.com/easemob/serync/' \\  \n    --rpm-user easemob \\  \n    --rpm-group easemob \\  \n    --verbose \\  \n    --epoch 20160616  \n    \n    \n    \n    createrepo /data/apps/data/nginx/yum/ssy/ssy201606/x86_64/6/easemob-ssy/packages/\n    ","slug":"yum仓库搭建之RPM包制作","published":1,"updated":"2017-03-01T06:04:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizqklz81000elbpvmb6elqio","content":"<p> 常见的软件安装方式有以下几种<br>1.yum安装，可自动解决依赖，但不能自定义软件安装位置<br>2.编译安装，可指定安装路径，指定装模块，但编译参数冗长，且耗时较长，不能解决依赖问题。<br><a id=\"more\"></a><br>3.rpm安装，安装速度较速，但不能自动解决依赖，尤其是遇到需要的依赖包较多时，特别费时。<br>本文主要介绍利用fpm工具制作个性化的rpm包，后期可放到yum仓库中，直接用yum安装。<br>【fpm介绍】<br>项目地址：<a href=\"https://github.com/jordansissel/fpm\" target=\"_blank\" rel=\"external\">https://github.com/jordansissel/fpm</a><br>作者把这个fpm称作Effing Package Management，翻译过来就是该死的包管理器，粗暴一点就是去他妈的包管理器。Ubuntu及CentOS的包管理及安装方式完全不同，要想同时掌握这两种平台下的软件包安装方法是很困难的，为了不再遭受这痛苦，fpm便应运而生了。fpm是由jordansissel于2011年开发的一套打包工具，可快速度地将你安装好的程序目录或包打包为rpm及deb等结尾软件包。与传统的打包工具(rpmbuild、dh_make)相比，制作起来更加简单、方便、快捷。<br>【fpm安装】<br>1.安装ruby及gcc    </p>\n<pre><code>yum install ruby-devel gcc  \n</code></pre><p>2.安装fpm    </p>\n<pre><code>gem install fpm  \n</code></pre><p>3.fpm打包<br>语法格式  </p>\n<pre><code>fpm -s &lt;source type&gt; -t &lt;target type&gt; [options]  \n</code></pre><p>其中源类型主要有：dir、gem、rpm、python等，目标类型主要有rpm,deb,puppet,solaris等。<br>-s指定输入的包类型<br>-t指定输出包的类型<br>-n, –name指定输出的包名<br>-v, –version指定版本号，默认为1.0<br>-d, –depends指定依赖包，可重复多次出现，通常以”-d ‘name’ or -d ‘name &gt; version’”的形式展现。<br>-f, –force强制输出，会覆盖掉旧包<br>-p, –package OUTPUT 指定输出目录<br>【打包实例】<br>定制cron初始化rpm包    </p>\n<pre><code>$fpm -s dir -t rpm -a noarch -p /root/ -n cron-init-script -v 1.0 /var/spool/cron/  \nno value for epoch is set, defaulting to nil {:level=&gt;:warn}  \nno value for epoch is set, defaulting to nil {:level=&gt;:warn}  \nCreated package {:path=&gt;&quot;/root/cron-init-script-1.0-1.noarch.rpm&quot;}  \n$ll /root/cron-init-script-1.0-1.noarch.rpm   \n-rw-r--r-- 1 root root 1693 Nov  2 22:24 /root/cron-init-script-1.0-1.noarch.rpm  \n</code></pre><p>在客户端yum安装cron-init-script  </p>\n<pre><code>yum install cron-init-scipt\n</code></pre><p>【升级RPM包】<br>1.编辑cron任务  </p>\n<pre><code>$crontab -l  \n*/5 * * * * /usr/sbin/ntpdate pool.ntp.org &gt;/dev/null 2&gt;&amp;1  \n*/10 * * * * /usr/sbin/ntpdate 1.pool.ntp.org &gt;/dev/null 2&gt;&amp;1  \n</code></pre><p>2.重新生成包</p>\n<pre><code>fpm -s dir -t rpm -a noarch -p /tools/fpm/ -n cron-init-script -v 1.1 /var/spool/cron/\n</code></pre><p>yum仓库搭建之RPM包制作<br>3.传到yum仓库  </p>\n<pre><code>$cp cron-init-script-1.1-1.noarch.rpm /application/yum/centos6.6/x86_64/ \n</code></pre><p>4.更新yum仓库索引  </p>\n<pre><code>$createrepo --update /application/yum/centos6.6/x86_64/\nSpawning worker 0 with 1 pkgs  \nWorkers Finished  \nGathering worker results  \nSaving Primary metadata  \nSaving file lists metadata  \nSaving other metadata  \nGenerating sqlite DBs  \nSqlite DBs complete  \n</code></pre><p>5.客户端清空yum缓存    </p>\n<pre><code>###yum clean all  \nLoaded plugins: fastestmirror, security  \nCleaning repos: oldboy  \nCleaning up Everything   \nCleaning up list of fastest mirrors  \n</code></pre><p>6.查找cron包  </p>\n<pre><code># yum list |grep cron-init  \ncron-init-script.noarch 1.0-1  @oldboy#前面的@表示已经安装过，保留下来的信息   \ncron-init-script.noarch 1.1-1  oldboy   \n</code></pre><p>7.更新cron包  </p>\n<pre><code># crontab -l  \n*/5 * * * * /usr/sbin/ntpdate pool.ntp.org &gt;/dev/null 2&gt;&amp;1  \n# yum update cron-init-script  \nIs this ok [y/N]: y  \nRunning Transaction  \n  Updating  : cron-init-script-1.1-1.noarch1/2   \n  Cleanup: cron-init-script-1.0-1.noarch2/2   \n  Verifying  : cron-init-script-1.1-1.noarch1/2   \n  Verifying  : cron-init-script-1.0-1.noarch2/2  \nUpdated:  \n  cron-init-script.noarch 0:1.1-1 \nComplete!  \n# crontab -l  \n*/5 * * * * /usr/sbin/ntpdate pool.ntp.org &gt;/dev/null 2&gt;&amp;1  \n*/10 * * * * /usr/sbin/ntpdate 1.pool.ntp.org &gt;/dev/null 2&gt;&amp;1  \n</code></pre><p>cron任务已更新。  </p>\n<pre><code>fpm -f -s dir -t rpm -n easemob-sersync-ssy -v 2.5.4_64bit  --iteration 1.el6.centos -a native \\  \n-C /tmp/easemob-serync \\  \n--vendor &apos;sam@easemob.com&apos; \\  \n--description &apos;Ejabberd packager by easemob.com&apos; \\  \n--url &apos;https://github.com/easemob/serync/&apos; \\  \n--rpm-user easemob \\  \n--rpm-group easemob \\  \n--verbose \\  \n--epoch 20160616  \n\n\n\ncreaterepo /data/apps/data/nginx/yum/ssy/ssy201606/x86_64/6/easemob-ssy/packages/\n</code></pre>","excerpt":"<p> 常见的软件安装方式有以下几种<br>1.yum安装，可自动解决依赖，但不能自定义软件安装位置<br>2.编译安装，可指定安装路径，指定装模块，但编译参数冗长，且耗时较长，不能解决依赖问题。<br>","more":"<br>3.rpm安装，安装速度较速，但不能自动解决依赖，尤其是遇到需要的依赖包较多时，特别费时。<br>本文主要介绍利用fpm工具制作个性化的rpm包，后期可放到yum仓库中，直接用yum安装。<br>【fpm介绍】<br>项目地址：<a href=\"https://github.com/jordansissel/fpm\">https://github.com/jordansissel/fpm</a><br>作者把这个fpm称作Effing Package Management，翻译过来就是该死的包管理器，粗暴一点就是去他妈的包管理器。Ubuntu及CentOS的包管理及安装方式完全不同，要想同时掌握这两种平台下的软件包安装方法是很困难的，为了不再遭受这痛苦，fpm便应运而生了。fpm是由jordansissel于2011年开发的一套打包工具，可快速度地将你安装好的程序目录或包打包为rpm及deb等结尾软件包。与传统的打包工具(rpmbuild、dh_make)相比，制作起来更加简单、方便、快捷。<br>【fpm安装】<br>1.安装ruby及gcc    </p>\n<pre><code>yum install ruby-devel gcc  \n</code></pre><p>2.安装fpm    </p>\n<pre><code>gem install fpm  \n</code></pre><p>3.fpm打包<br>语法格式  </p>\n<pre><code>fpm -s &lt;source type&gt; -t &lt;target type&gt; [options]  \n</code></pre><p>其中源类型主要有：dir、gem、rpm、python等，目标类型主要有rpm,deb,puppet,solaris等。<br>-s指定输入的包类型<br>-t指定输出包的类型<br>-n, –name指定输出的包名<br>-v, –version指定版本号，默认为1.0<br>-d, –depends指定依赖包，可重复多次出现，通常以”-d ‘name’ or -d ‘name &gt; version’”的形式展现。<br>-f, –force强制输出，会覆盖掉旧包<br>-p, –package OUTPUT 指定输出目录<br>【打包实例】<br>定制cron初始化rpm包    </p>\n<pre><code>$fpm -s dir -t rpm -a noarch -p /root/ -n cron-init-script -v 1.0 /var/spool/cron/  \nno value for epoch is set, defaulting to nil {:level=&gt;:warn}  \nno value for epoch is set, defaulting to nil {:level=&gt;:warn}  \nCreated package {:path=&gt;&quot;/root/cron-init-script-1.0-1.noarch.rpm&quot;}  \n$ll /root/cron-init-script-1.0-1.noarch.rpm   \n-rw-r--r-- 1 root root 1693 Nov  2 22:24 /root/cron-init-script-1.0-1.noarch.rpm  \n</code></pre><p>在客户端yum安装cron-init-script  </p>\n<pre><code>yum install cron-init-scipt\n</code></pre><p>【升级RPM包】<br>1.编辑cron任务  </p>\n<pre><code>$crontab -l  \n*/5 * * * * /usr/sbin/ntpdate pool.ntp.org &gt;/dev/null 2&gt;&amp;1  \n*/10 * * * * /usr/sbin/ntpdate 1.pool.ntp.org &gt;/dev/null 2&gt;&amp;1  \n</code></pre><p>2.重新生成包</p>\n<pre><code>fpm -s dir -t rpm -a noarch -p /tools/fpm/ -n cron-init-script -v 1.1 /var/spool/cron/\n</code></pre><p>yum仓库搭建之RPM包制作<br>3.传到yum仓库  </p>\n<pre><code>$cp cron-init-script-1.1-1.noarch.rpm /application/yum/centos6.6/x86_64/ \n</code></pre><p>4.更新yum仓库索引  </p>\n<pre><code>$createrepo --update /application/yum/centos6.6/x86_64/\nSpawning worker 0 with 1 pkgs  \nWorkers Finished  \nGathering worker results  \nSaving Primary metadata  \nSaving file lists metadata  \nSaving other metadata  \nGenerating sqlite DBs  \nSqlite DBs complete  \n</code></pre><p>5.客户端清空yum缓存    </p>\n<pre><code>###yum clean all  \nLoaded plugins: fastestmirror, security  \nCleaning repos: oldboy  \nCleaning up Everything   \nCleaning up list of fastest mirrors  \n</code></pre><p>6.查找cron包  </p>\n<pre><code># yum list |grep cron-init  \ncron-init-script.noarch 1.0-1  @oldboy#前面的@表示已经安装过，保留下来的信息   \ncron-init-script.noarch 1.1-1  oldboy   \n</code></pre><p>7.更新cron包  </p>\n<pre><code># crontab -l  \n*/5 * * * * /usr/sbin/ntpdate pool.ntp.org &gt;/dev/null 2&gt;&amp;1  \n# yum update cron-init-script  \nIs this ok [y/N]: y  \nRunning Transaction  \n  Updating  : cron-init-script-1.1-1.noarch1/2   \n  Cleanup: cron-init-script-1.0-1.noarch2/2   \n  Verifying  : cron-init-script-1.1-1.noarch1/2   \n  Verifying  : cron-init-script-1.0-1.noarch2/2  \nUpdated:  \n  cron-init-script.noarch 0:1.1-1 \nComplete!  \n# crontab -l  \n*/5 * * * * /usr/sbin/ntpdate pool.ntp.org &gt;/dev/null 2&gt;&amp;1  \n*/10 * * * * /usr/sbin/ntpdate 1.pool.ntp.org &gt;/dev/null 2&gt;&amp;1  \n</code></pre><p>cron任务已更新。  </p>\n<pre><code>fpm -f -s dir -t rpm -n easemob-sersync-ssy -v 2.5.4_64bit  --iteration 1.el6.centos -a native \\  \n-C /tmp/easemob-serync \\  \n--vendor &apos;sam@easemob.com&apos; \\  \n--description &apos;Ejabberd packager by easemob.com&apos; \\  \n--url &apos;https://github.com/easemob/serync/&apos; \\  \n--rpm-user easemob \\  \n--rpm-group easemob \\  \n--verbose \\  \n--epoch 20160616  \n\n\n\ncreaterepo /data/apps/data/nginx/yum/ssy/ssy201606/x86_64/6/easemob-ssy/packages/\n</code></pre>"},{"title":"zabbix2.6安装","date":"2016-09-02T04:00:00.000Z","_content":"\n\n1. 安装lnmp架构\n `yum -y install gcc gcc-c++ autoconf httpd php mysql mysql-server php-mysql httpd-manual mod_ssl mod_perl mod_auth_mysql php-gd php-xml php-mbstring php-ldap php-pear php-xmlrpc php-bcmath mysql-connector-odbc mysql-devel libdbi-dbd-mysql net-snmp-devel curl-devel`\n2. 启动服务\n    service mysqld start\n    service httpd start\n<!--more-->\n\n3. 创建zabbix用户和组\n    groupadd zabbix\n    useradd zabbix -g zabbix\n4. 进入mysql创建数据库\n    create database zabbix character set utf8;\n    grant all on zabbix.* to zabbix@localhost identified by ‘jszj201501’;\n5. 解压zabbix.tar包\n    > tar zxf zabbix-2.4.tar.gz\n    > cd zabbix-2.4.5/database/mysql/\n6. 导入数据库\n    mysql -uzabbix -pjszj201501 zabbix <schema.sql\n    mysql -uzabbix -pjszj201501 zabbix <images.sql\n7. 进行编译安装\n    cd ../..\n    ./configure –prefix=/usr/local/zabbix –enable-server –enable-agent –with-mysql –with-net-snmp –with-libcurl\n    make&&make install\n8. 添加zabbix服务对应的端口\n    cat >>/etc/services<<EOF\n    zabbix-agent 10050/tcp Zabbix Agent\n    zabbix-agent 10050/udp Zabbix Agent\n    zabbix-trapper 10051/tcp Zabbix Trapper\n    zabbix-trapper 10051/udp Zabbix Trapper\n    EOF\n9. 修改zabbix server 配置文件\n    vim /usr/local/zabbix/etc/zabbix_server.conf\n    LogFile=/tmp/zabbix_server.log ##日志位置，根据需求修改；\n    PidFile=/tmp/zabbix_server.pid ##PID 所在位置\n    DBHost=localhost ##如果不是在本机，请修改\n    DBName=zabbix ##数据库名称\n    DBUser=zabbix ##数据库用户名\n    DBPassword=redhat ##数据库密码\n10. 安装启动脚本,添加可执行权限\n    cp misc/init.d/fedora/core/zabbix_server /etc/init.d\n    chmod +x /etc/init.d/zabbix_server\n11. 查找zabbix_server.conf位置复制\n\n    find / -name zabbix_server.conf\n12. 修改启动脚本，启动zabbix server\n    vim /etc/init.d/zabbix_server\n    BASEDIR=/usr/local/zabbix ##修改这个，zabbix 的安装目录\n    CONFILE=$BASEDIR/etc/zabbix_server.conf ##添加这一行，定义配置文件位置\n    #搜索start,修改启动选项，默认是去/etc 下去找配置文件的\n    action $”Starting $BINARY_NAME: ” $FULLPATH -c $CONFILE\n    service zabbix_server start\n13. 安装邮件服务\n    yum install mailx\n    vi /etc/mail.rc\n    set from=xxx@163.com smtp=smtp.163.com\n    set smtp-auth-user=xxx@163.com smtp-auth-password=123456\n    set smtp-auth=login\n    :wq! #保存退出\n    echo “zabbix test mail” |mail -s “zabbix” yyy@163.com\n    linux客户端\n    mkdir /usr/local/zabbix\n    tar zxf zabbix_agents_2.0.6.linux2_6.amd64.tar.gz -C /usr/local/zabbix\n14. 编辑配置文件\n    find / -name zabbix_agentd.conf\n    vim zabbix_agentd.conf\n    LogFile=/tmp/zabbix_agentd.log\n    Server=202.108.1.52 ##服务器IP\n    ServerActive=202.108.1.52 ##主动模式服务器IP\n    Hostname=202.108.1.51 ##设定主机名\n    #加入mysql配置\n15. 安装修改启动脚本\n    scp misc/init.d/fedora/core/zabbix_agentd 202.108.1.51:/etc/init.d\n    vim /etc/init.d/zabbix_agentd\n    BASEDIR=/usr/local/zabbix ##修改这个\n    CONFILE=$BASEDIR/etc/zabbix_agentd.conf ##添加这行，搜索start 添加-c $CONFILE\n    action $”Starting $BINARY_NAME: ” $FULLPATH -c $CONFILE\n    service zabbix_agentd start\n16. 创建用户和用户组\n    groupadd zabbix\n    useradd zabbix -g zabbix\n    windows客户端\n    cmd\n    d:\\zabbix_agentd.exe -i -c d:\\zabbix\\zabbix_agentd.conf\n    services.msc\n17. 禁用内部邮件服务\n    service sendmail stop #关闭\n    chkconfig sendmail off #禁止开机启动\n    service postfix stop\n    chkconfig postfix off\n18. 事件触发器配置：\n    名称：Action-Email\n    默认接收人：故障{TRIGGER.STATUS},服务器:{HOSTNAME1}发生: {TRIGGER.NAME}故障!\n    默认信息：\n    告警主机:{HOSTNAME1}\n    告警时间:{EVENT.DATE} {EVENT.TIME}\n    告警等级:{TRIGGER.SEVERITY}\n    告警信息: {TRIGGER.NAME}\n    告警项目:{TRIGGER.KEY1}\n    问题详情:{ITEM.NAME}:{ITEM.VALUE}\n    当前状态:{TRIGGER.STATUS}:{ITEM.VALUE1}\n    事件ID:{EVENT.ID}\n    恢复信息：打钩\n    恢复主旨：恢复{TRIGGER.STATUS}, 服务器:{HOSTNAME1}: {TRIGGER.NAME}已恢复!\n    恢复信息：\n    告警主机:{HOSTNAME1}\n    告警时间:{EVENT.DATE} {EVENT.TIME}\n    告警等级:{TRIGGER.SEVERITY}\n    告警信息: {TRIGGER.NAME}\n    告警项目:{TRIGGER.KEY1}\n    问题详情:{ITEM.NAME}:{ITEM.VALUE}\n    当前状态:{TRIGGER.STATUS}:{ITEM.VALUE1}\n    事件ID:{EVENT.ID}\n    已启用：打钩\n19. 解决乱码和附件问题\n    vim /usr/local/zabbix/share/zabbix/alertscripts/sendmail.sh\n    #!/bin/bash\n    #export.UTF-8 //解决发送的中文变成了乱码的问题\n    FILE=/tmp/mailtmp.txt\n    echo “$3” >$FILE\n    dos2unix -k $FILE  //解决了发送的邮件内容变成附件的问题。\n    /bin/mail -s “$2” $1 < $FILE\n    touch /tmp/mailtmp.txt\n    chown  zabbix.zabbix /tmp/mailtmp.txt\n20. zabbix  mysql客户端\n    find / -name userparameter_mysql.conf\n    vi /usr/local/zabbixvim/etc/zabbix_agent.conf\n    Include=/usr/local/zabbix/conf/zabbix_agentd/ #加入mysql配置(find查找的路径)\n    vi /usr/local/zabbix/etc/zabbix_agentd.conf\n    Include=/usr/local/zabbix/conf/zabbix_agentd/ #加入mysql配置\n    mkdir /etc/zabbix\n    touch /etc/zabbix/.my.cnf\n    vim /etc/zabbix/.my.cnf\n    [mysql]\n    host = localhost\n    user = mysqlcheck\n    password = mysqlcheck\n    socket = /var/lib/mysql/mysql.sock(mysql.sock的位置)\n    [mysqladmin]\n    host = localhost\n    user = mysqlcheck\n    password = mysqlchechk\n    socket = /var/lib/mysql/mysql.sock(mysql.sock的位置)\n    vim userparameter_mysql.conf\n    UserParameter=mysql.status[*],echo “show global status where Variable_name=’$1′;” | mysql -uzabbix -pjszj201501 -N | awk ‘{print $$2}’ #取mysql状态\n    UserParameter=mysql.size[*],echo “select sum($(case “$3″ in both|””) echo “data_length+index_length”;; data|index) echo “$3_length”;; free) echo “data_free”;; esac)) from information_schema.tables$([[ “$1” = “all” || ! “$1″ ]] || echo ” where table_schema=’$1′”)$([[ “$2” = “all” || ! “$2” ]] || echo “and table_name=’$2′”);” | mysql -uzabbix -pjszj201501 -N\n     #取mysql操作状态\n    UserParameter=mysql.ping,HOME=/etc/zabbix mysqladmin -uzabbix -ppassword | grep -c alive\n    UserParameter=mysql.version,mysql -V #取mysql版本\n    chmod 777 userparameter_mysql.conf\n    service zabbix_agentd restart\n21. Zabbix配置email报警\n一、              使用msmtp这个命令行MUA\n    (1)./configure –prefix=/usr/local/msmtp\n    (2)make\n    (3)make install\n    (4)mkdir /usr/local/msmtp/etc\n    (5)touch /usr/local/msmtp/etc/msmtprc\n    (6)在/usr/local/msmtp/etc/msmtprc中写入如下内容：\n    defaults\n    account michael_zhou\n    host mail.chinadba.com\n    domain chinadba.com\n    from michael_zhou@chinadba.com\n    auth login\n    user michael_zhou@chinadba.com\n        password your_password\n    account default:michael_zhou\n    logfile /var/log/maillog\n    (7)测试一下：/usr/local/msmtp/bin/msmtp i@chinadba.com，输入内容后按ctrl+D发出。\n二、    在实际测试中发现直接使用msmtp命令发出去的邮件会看不到发件人和主题，只能看到邮件内容，所以我使用mutt挂接在msmtp上，mutt默认会安装，如果没有安装请yum install mutt*\n    (1)修改mutt的配置文件/etc/Muttrc, 不是/etc/muttrc  ，M要大写\n    1．set sendmail=”/usr/local/msmtp/bin/msmtp”\n    2．set use_from=yes\n    3．set realname=michael_zhou@chinadba.com  #发件人邮箱地址\n    4．set editor=”vi”\n    5．保存退出\n    (2)测试一下：echo “邮件报警测试” | mutt -s “测试” i@chinadba.com  #收件人地址\n三、    创建 zabbix用于发送邮件的脚本,脚本放在什么位置随便，但是要保证zabbix能找到！\n(1)vim /usr/bin/baojing,并写入如下内容：\n#!/bin/bash\necho “$3” | mutt -s “$2” $1       # $3表示邮件内容、$2表示邮件标题、$1表示收件人\n(2)chmod a+x /usr/bin/baojing\n四、    zabbix配置\n(1)创建meida types\n1．登录到zabbix，进入“Administration” >> ”Media types”，点击右上角“Create Media Type”。 Description填”mediatype-baojing”或其它名称，Type选择”Script”，Script填”baojing”。\n2．点击save保存\n(2)创建actions\n1.登录到zabbix，进入”Configation” >> “Actions”，点击右上角”Create Actions”。输入Name “action-baojing” ，其它都默认点击右侧“Action Operations”下的”New”按钮，”Operation Type”选择”Send message”，”Send Message to”选择一个或多个要发送消息的用户组，”Send only to”选择我们之前新增的mediatype-baojing。\n2.点击save保存\n(3) zabbix用户配置\n登录到zabbix, 进入”Adimistration” >> “Users”，在之前选定要发送消息的组里的Members栏位里选择一个用户，例如选择Admin用户。\n在用户信息修改界面最下方的”Media”处点击”Add”按钮。\nType选择”mediatype-baojing”，Send to填入收件人地址，点击Add添加。\n点击”Save”保存配置。\n至此配置完成，测试！\n不光是zabbix,nagios等监控平台的邮件报警都可以这样配置。当然转到139邮箱的话可以收到短信的，会更加及时的收到报警。\nzabbix企业应用之服务器硬件信息监控\nhttp://dl528888.blog.51cto.com/2382721/1403893\nzabbix企业应用之Mysql主从监控\nhttp://dl528888.blog.51cto.com/2382721/1434263\nZabbix监控MySQL数据库状态\nhttp://www.linuxidc.com/Linux/2015-04/116304.htm\nZabbix使用微信接口实现微信报警功能\nhttp://lcbk.net/zabbix/2022.html\nhttp://www.cnyunwei.com/thread-29593-1-1.html","source":"_posts/zabbix2.6安装.md","raw":"---\ntitle: zabbix2.6安装\ndate: 2016-09-02\ntags:\n---\n\n\n1. 安装lnmp架构\n `yum -y install gcc gcc-c++ autoconf httpd php mysql mysql-server php-mysql httpd-manual mod_ssl mod_perl mod_auth_mysql php-gd php-xml php-mbstring php-ldap php-pear php-xmlrpc php-bcmath mysql-connector-odbc mysql-devel libdbi-dbd-mysql net-snmp-devel curl-devel`\n2. 启动服务\n    service mysqld start\n    service httpd start\n<!--more-->\n\n3. 创建zabbix用户和组\n    groupadd zabbix\n    useradd zabbix -g zabbix\n4. 进入mysql创建数据库\n    create database zabbix character set utf8;\n    grant all on zabbix.* to zabbix@localhost identified by ‘jszj201501’;\n5. 解压zabbix.tar包\n    > tar zxf zabbix-2.4.tar.gz\n    > cd zabbix-2.4.5/database/mysql/\n6. 导入数据库\n    mysql -uzabbix -pjszj201501 zabbix <schema.sql\n    mysql -uzabbix -pjszj201501 zabbix <images.sql\n7. 进行编译安装\n    cd ../..\n    ./configure –prefix=/usr/local/zabbix –enable-server –enable-agent –with-mysql –with-net-snmp –with-libcurl\n    make&&make install\n8. 添加zabbix服务对应的端口\n    cat >>/etc/services<<EOF\n    zabbix-agent 10050/tcp Zabbix Agent\n    zabbix-agent 10050/udp Zabbix Agent\n    zabbix-trapper 10051/tcp Zabbix Trapper\n    zabbix-trapper 10051/udp Zabbix Trapper\n    EOF\n9. 修改zabbix server 配置文件\n    vim /usr/local/zabbix/etc/zabbix_server.conf\n    LogFile=/tmp/zabbix_server.log ##日志位置，根据需求修改；\n    PidFile=/tmp/zabbix_server.pid ##PID 所在位置\n    DBHost=localhost ##如果不是在本机，请修改\n    DBName=zabbix ##数据库名称\n    DBUser=zabbix ##数据库用户名\n    DBPassword=redhat ##数据库密码\n10. 安装启动脚本,添加可执行权限\n    cp misc/init.d/fedora/core/zabbix_server /etc/init.d\n    chmod +x /etc/init.d/zabbix_server\n11. 查找zabbix_server.conf位置复制\n\n    find / -name zabbix_server.conf\n12. 修改启动脚本，启动zabbix server\n    vim /etc/init.d/zabbix_server\n    BASEDIR=/usr/local/zabbix ##修改这个，zabbix 的安装目录\n    CONFILE=$BASEDIR/etc/zabbix_server.conf ##添加这一行，定义配置文件位置\n    #搜索start,修改启动选项，默认是去/etc 下去找配置文件的\n    action $”Starting $BINARY_NAME: ” $FULLPATH -c $CONFILE\n    service zabbix_server start\n13. 安装邮件服务\n    yum install mailx\n    vi /etc/mail.rc\n    set from=xxx@163.com smtp=smtp.163.com\n    set smtp-auth-user=xxx@163.com smtp-auth-password=123456\n    set smtp-auth=login\n    :wq! #保存退出\n    echo “zabbix test mail” |mail -s “zabbix” yyy@163.com\n    linux客户端\n    mkdir /usr/local/zabbix\n    tar zxf zabbix_agents_2.0.6.linux2_6.amd64.tar.gz -C /usr/local/zabbix\n14. 编辑配置文件\n    find / -name zabbix_agentd.conf\n    vim zabbix_agentd.conf\n    LogFile=/tmp/zabbix_agentd.log\n    Server=202.108.1.52 ##服务器IP\n    ServerActive=202.108.1.52 ##主动模式服务器IP\n    Hostname=202.108.1.51 ##设定主机名\n    #加入mysql配置\n15. 安装修改启动脚本\n    scp misc/init.d/fedora/core/zabbix_agentd 202.108.1.51:/etc/init.d\n    vim /etc/init.d/zabbix_agentd\n    BASEDIR=/usr/local/zabbix ##修改这个\n    CONFILE=$BASEDIR/etc/zabbix_agentd.conf ##添加这行，搜索start 添加-c $CONFILE\n    action $”Starting $BINARY_NAME: ” $FULLPATH -c $CONFILE\n    service zabbix_agentd start\n16. 创建用户和用户组\n    groupadd zabbix\n    useradd zabbix -g zabbix\n    windows客户端\n    cmd\n    d:\\zabbix_agentd.exe -i -c d:\\zabbix\\zabbix_agentd.conf\n    services.msc\n17. 禁用内部邮件服务\n    service sendmail stop #关闭\n    chkconfig sendmail off #禁止开机启动\n    service postfix stop\n    chkconfig postfix off\n18. 事件触发器配置：\n    名称：Action-Email\n    默认接收人：故障{TRIGGER.STATUS},服务器:{HOSTNAME1}发生: {TRIGGER.NAME}故障!\n    默认信息：\n    告警主机:{HOSTNAME1}\n    告警时间:{EVENT.DATE} {EVENT.TIME}\n    告警等级:{TRIGGER.SEVERITY}\n    告警信息: {TRIGGER.NAME}\n    告警项目:{TRIGGER.KEY1}\n    问题详情:{ITEM.NAME}:{ITEM.VALUE}\n    当前状态:{TRIGGER.STATUS}:{ITEM.VALUE1}\n    事件ID:{EVENT.ID}\n    恢复信息：打钩\n    恢复主旨：恢复{TRIGGER.STATUS}, 服务器:{HOSTNAME1}: {TRIGGER.NAME}已恢复!\n    恢复信息：\n    告警主机:{HOSTNAME1}\n    告警时间:{EVENT.DATE} {EVENT.TIME}\n    告警等级:{TRIGGER.SEVERITY}\n    告警信息: {TRIGGER.NAME}\n    告警项目:{TRIGGER.KEY1}\n    问题详情:{ITEM.NAME}:{ITEM.VALUE}\n    当前状态:{TRIGGER.STATUS}:{ITEM.VALUE1}\n    事件ID:{EVENT.ID}\n    已启用：打钩\n19. 解决乱码和附件问题\n    vim /usr/local/zabbix/share/zabbix/alertscripts/sendmail.sh\n    #!/bin/bash\n    #export.UTF-8 //解决发送的中文变成了乱码的问题\n    FILE=/tmp/mailtmp.txt\n    echo “$3” >$FILE\n    dos2unix -k $FILE  //解决了发送的邮件内容变成附件的问题。\n    /bin/mail -s “$2” $1 < $FILE\n    touch /tmp/mailtmp.txt\n    chown  zabbix.zabbix /tmp/mailtmp.txt\n20. zabbix  mysql客户端\n    find / -name userparameter_mysql.conf\n    vi /usr/local/zabbixvim/etc/zabbix_agent.conf\n    Include=/usr/local/zabbix/conf/zabbix_agentd/ #加入mysql配置(find查找的路径)\n    vi /usr/local/zabbix/etc/zabbix_agentd.conf\n    Include=/usr/local/zabbix/conf/zabbix_agentd/ #加入mysql配置\n    mkdir /etc/zabbix\n    touch /etc/zabbix/.my.cnf\n    vim /etc/zabbix/.my.cnf\n    [mysql]\n    host = localhost\n    user = mysqlcheck\n    password = mysqlcheck\n    socket = /var/lib/mysql/mysql.sock(mysql.sock的位置)\n    [mysqladmin]\n    host = localhost\n    user = mysqlcheck\n    password = mysqlchechk\n    socket = /var/lib/mysql/mysql.sock(mysql.sock的位置)\n    vim userparameter_mysql.conf\n    UserParameter=mysql.status[*],echo “show global status where Variable_name=’$1′;” | mysql -uzabbix -pjszj201501 -N | awk ‘{print $$2}’ #取mysql状态\n    UserParameter=mysql.size[*],echo “select sum($(case “$3″ in both|””) echo “data_length+index_length”;; data|index) echo “$3_length”;; free) echo “data_free”;; esac)) from information_schema.tables$([[ “$1” = “all” || ! “$1″ ]] || echo ” where table_schema=’$1′”)$([[ “$2” = “all” || ! “$2” ]] || echo “and table_name=’$2′”);” | mysql -uzabbix -pjszj201501 -N\n     #取mysql操作状态\n    UserParameter=mysql.ping,HOME=/etc/zabbix mysqladmin -uzabbix -ppassword | grep -c alive\n    UserParameter=mysql.version,mysql -V #取mysql版本\n    chmod 777 userparameter_mysql.conf\n    service zabbix_agentd restart\n21. Zabbix配置email报警\n一、              使用msmtp这个命令行MUA\n    (1)./configure –prefix=/usr/local/msmtp\n    (2)make\n    (3)make install\n    (4)mkdir /usr/local/msmtp/etc\n    (5)touch /usr/local/msmtp/etc/msmtprc\n    (6)在/usr/local/msmtp/etc/msmtprc中写入如下内容：\n    defaults\n    account michael_zhou\n    host mail.chinadba.com\n    domain chinadba.com\n    from michael_zhou@chinadba.com\n    auth login\n    user michael_zhou@chinadba.com\n        password your_password\n    account default:michael_zhou\n    logfile /var/log/maillog\n    (7)测试一下：/usr/local/msmtp/bin/msmtp i@chinadba.com，输入内容后按ctrl+D发出。\n二、    在实际测试中发现直接使用msmtp命令发出去的邮件会看不到发件人和主题，只能看到邮件内容，所以我使用mutt挂接在msmtp上，mutt默认会安装，如果没有安装请yum install mutt*\n    (1)修改mutt的配置文件/etc/Muttrc, 不是/etc/muttrc  ，M要大写\n    1．set sendmail=”/usr/local/msmtp/bin/msmtp”\n    2．set use_from=yes\n    3．set realname=michael_zhou@chinadba.com  #发件人邮箱地址\n    4．set editor=”vi”\n    5．保存退出\n    (2)测试一下：echo “邮件报警测试” | mutt -s “测试” i@chinadba.com  #收件人地址\n三、    创建 zabbix用于发送邮件的脚本,脚本放在什么位置随便，但是要保证zabbix能找到！\n(1)vim /usr/bin/baojing,并写入如下内容：\n#!/bin/bash\necho “$3” | mutt -s “$2” $1       # $3表示邮件内容、$2表示邮件标题、$1表示收件人\n(2)chmod a+x /usr/bin/baojing\n四、    zabbix配置\n(1)创建meida types\n1．登录到zabbix，进入“Administration” >> ”Media types”，点击右上角“Create Media Type”。 Description填”mediatype-baojing”或其它名称，Type选择”Script”，Script填”baojing”。\n2．点击save保存\n(2)创建actions\n1.登录到zabbix，进入”Configation” >> “Actions”，点击右上角”Create Actions”。输入Name “action-baojing” ，其它都默认点击右侧“Action Operations”下的”New”按钮，”Operation Type”选择”Send message”，”Send Message to”选择一个或多个要发送消息的用户组，”Send only to”选择我们之前新增的mediatype-baojing。\n2.点击save保存\n(3) zabbix用户配置\n登录到zabbix, 进入”Adimistration” >> “Users”，在之前选定要发送消息的组里的Members栏位里选择一个用户，例如选择Admin用户。\n在用户信息修改界面最下方的”Media”处点击”Add”按钮。\nType选择”mediatype-baojing”，Send to填入收件人地址，点击Add添加。\n点击”Save”保存配置。\n至此配置完成，测试！\n不光是zabbix,nagios等监控平台的邮件报警都可以这样配置。当然转到139邮箱的话可以收到短信的，会更加及时的收到报警。\nzabbix企业应用之服务器硬件信息监控\nhttp://dl528888.blog.51cto.com/2382721/1403893\nzabbix企业应用之Mysql主从监控\nhttp://dl528888.blog.51cto.com/2382721/1434263\nZabbix监控MySQL数据库状态\nhttp://www.linuxidc.com/Linux/2015-04/116304.htm\nZabbix使用微信接口实现微信报警功能\nhttp://lcbk.net/zabbix/2022.html\nhttp://www.cnyunwei.com/thread-29593-1-1.html","slug":"zabbix2.6安装","published":1,"updated":"2017-03-01T05:59:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizqklz82000flbpv3sibudmy","content":"<ol>\n<li>安装lnmp架构<br><code>yum -y install gcc gcc-c++ autoconf httpd php mysql mysql-server php-mysql httpd-manual mod_ssl mod_perl mod_auth_mysql php-gd php-xml php-mbstring php-ldap php-pear php-xmlrpc php-bcmath mysql-connector-odbc mysql-devel libdbi-dbd-mysql net-snmp-devel curl-devel</code></li>\n<li><p>启动服务<br> service mysqld start<br> service httpd start</p>\n<a id=\"more\"></a>\n</li>\n<li><p>创建zabbix用户和组<br> groupadd zabbix<br> useradd zabbix -g zabbix</p>\n</li>\n<li>进入mysql创建数据库<br> create database zabbix character set utf8;<br> grant all on zabbix.* to zabbix@localhost identified by ‘jszj201501’;</li>\n<li>解压zabbix.tar包<blockquote>\n<p>tar zxf zabbix-2.4.tar.gz<br>cd zabbix-2.4.5/database/mysql/</p>\n</blockquote>\n</li>\n<li>导入数据库<br> mysql -uzabbix -pjszj201501 zabbix &lt;schema.sql<br> mysql -uzabbix -pjszj201501 zabbix &lt;images.sql</li>\n<li>进行编译安装<br> cd ../..<br> ./configure –prefix=/usr/local/zabbix –enable-server –enable-agent –with-mysql –with-net-snmp –with-libcurl<br> make&amp;&amp;make install</li>\n<li>添加zabbix服务对应的端口<br> cat &gt;&gt;/etc/services&lt;&lt;EOF<br> zabbix-agent 10050/tcp Zabbix Agent<br> zabbix-agent 10050/udp Zabbix Agent<br> zabbix-trapper 10051/tcp Zabbix Trapper<br> zabbix-trapper 10051/udp Zabbix Trapper<br> EOF</li>\n<li>修改zabbix server 配置文件<br> vim /usr/local/zabbix/etc/zabbix_server.conf<br> LogFile=/tmp/zabbix_server.log ##日志位置，根据需求修改；<br> PidFile=/tmp/zabbix_server.pid ##PID 所在位置<br> DBHost=localhost ##如果不是在本机，请修改<br> DBName=zabbix ##数据库名称<br> DBUser=zabbix ##数据库用户名<br> DBPassword=redhat ##数据库密码</li>\n<li>安装启动脚本,添加可执行权限<br>cp misc/init.d/fedora/core/zabbix_server /etc/init.d<br>chmod +x /etc/init.d/zabbix_server</li>\n<li><p>查找zabbix_server.conf位置复制</p>\n<p>find / -name zabbix_server.conf</p>\n</li>\n<li>修改启动脚本，启动zabbix server<br>vim /etc/init.d/zabbix_server<br>BASEDIR=/usr/local/zabbix ##修改这个，zabbix 的安装目录<br>CONFILE=$BASEDIR/etc/zabbix_server.conf ##添加这一行，定义配置文件位置<br>#搜索start,修改启动选项，默认是去/etc 下去找配置文件的<br>action $”Starting $BINARY_NAME: ” $FULLPATH -c $CONFILE<br>service zabbix_server start</li>\n<li>安装邮件服务<br>yum install mailx<br>vi /etc/mail.rc<br>set from=xxx@163.com smtp=smtp.163.com<br>set smtp-auth-user=xxx@163.com smtp-auth-password=123456<br>set smtp-auth=login<br>:wq! #保存退出<br>echo “zabbix test mail” |mail -s “zabbix” yyy@163.com<br>linux客户端<br>mkdir /usr/local/zabbix<br>tar zxf zabbix_agents_2.0.6.linux2_6.amd64.tar.gz -C /usr/local/zabbix</li>\n<li>编辑配置文件<br>find / -name zabbix_agentd.conf<br>vim zabbix_agentd.conf<br>LogFile=/tmp/zabbix_agentd.log<br>Server=202.108.1.52 ##服务器IP<br>ServerActive=202.108.1.52 ##主动模式服务器IP<br>Hostname=202.108.1.51 ##设定主机名<br>#加入mysql配置</li>\n<li>安装修改启动脚本<br>scp misc/init.d/fedora/core/zabbix_agentd 202.108.1.51:/etc/init.d<br>vim /etc/init.d/zabbix_agentd<br>BASEDIR=/usr/local/zabbix ##修改这个<br>CONFILE=$BASEDIR/etc/zabbix_agentd.conf ##添加这行，搜索start 添加-c $CONFILE<br>action $”Starting $BINARY_NAME: ” $FULLPATH -c $CONFILE<br>service zabbix_agentd start</li>\n<li>创建用户和用户组<br>groupadd zabbix<br>useradd zabbix -g zabbix<br>windows客户端<br>cmd<br>d:\\zabbix_agentd.exe -i -c d:\\zabbix\\zabbix_agentd.conf<br>services.msc</li>\n<li>禁用内部邮件服务<br>service sendmail stop #关闭<br>chkconfig sendmail off #禁止开机启动<br>service postfix stop<br>chkconfig postfix off</li>\n<li>事件触发器配置：<br>名称：Action-Email<br>默认接收人：故障{TRIGGER.STATUS},服务器:{HOSTNAME1}发生: {TRIGGER.NAME}故障!<br>默认信息：<br>告警主机:{HOSTNAME1}<br>告警时间:{EVENT.DATE} {EVENT.TIME}<br>告警等级:{TRIGGER.SEVERITY}<br>告警信息: {TRIGGER.NAME}<br>告警项目:{TRIGGER.KEY1}<br>问题详情:{ITEM.NAME}:{ITEM.VALUE}<br>当前状态:{TRIGGER.STATUS}:{ITEM.VALUE1}<br>事件ID:{EVENT.ID}<br>恢复信息：打钩<br>恢复主旨：恢复{TRIGGER.STATUS}, 服务器:{HOSTNAME1}: {TRIGGER.NAME}已恢复!<br>恢复信息：<br>告警主机:{HOSTNAME1}<br>告警时间:{EVENT.DATE} {EVENT.TIME}<br>告警等级:{TRIGGER.SEVERITY}<br>告警信息: {TRIGGER.NAME}<br>告警项目:{TRIGGER.KEY1}<br>问题详情:{ITEM.NAME}:{ITEM.VALUE}<br>当前状态:{TRIGGER.STATUS}:{ITEM.VALUE1}<br>事件ID:{EVENT.ID}<br>已启用：打钩</li>\n<li>解决乱码和附件问题<br>vim /usr/local/zabbix/share/zabbix/alertscripts/sendmail.sh<br>#!/bin/bash<br>#export.UTF-8 //解决发送的中文变成了乱码的问题<br>FILE=/tmp/mailtmp.txt<br>echo “$3” &gt;$FILE<br>dos2unix -k $FILE  //解决了发送的邮件内容变成附件的问题。<br>/bin/mail -s “$2” $1 &lt; $FILE<br>touch /tmp/mailtmp.txt<br>chown  zabbix.zabbix /tmp/mailtmp.txt</li>\n<li>zabbix  mysql客户端<br>find / -name userparameter_mysql.conf<br>vi /usr/local/zabbixvim/etc/zabbix_agent.conf<br>Include=/usr/local/zabbix/conf/zabbix_agentd/ #加入mysql配置(find查找的路径)<br>vi /usr/local/zabbix/etc/zabbix_agentd.conf<br>Include=/usr/local/zabbix/conf/zabbix_agentd/ #加入mysql配置<br>mkdir /etc/zabbix<br>touch /etc/zabbix/.my.cnf<br>vim /etc/zabbix/.my.cnf<br>[mysql]<br>host = localhost<br>user = mysqlcheck<br>password = mysqlcheck<br>socket = /var/lib/mysql/mysql.sock(mysql.sock的位置)<br>[mysqladmin]<br>host = localhost<br>user = mysqlcheck<br>password = mysqlchechk<br>socket = /var/lib/mysql/mysql.sock(mysql.sock的位置)<br>vim userparameter_mysql.conf<br>UserParameter=mysql.status[<em>],echo “show global status where Variable_name=’$1′;” | mysql -uzabbix -pjszj201501 -N | awk ‘{print $$2}’ #取mysql状态<br>UserParameter=mysql.size[</em>],echo “select sum($(case “$3″ in both|””) echo “data_length+index_length”;; data|index) echo “$3_length”;; free) echo “data_free”;; esac)) from information_schema.tables$([[ “$1” = “all” || ! “$1″ ]] || echo ” where table_schema=’$1′”)$([[ “$2” = “all” || ! “$2” ]] || echo “and table_name=’$2′”);” | mysql -uzabbix -pjszj201501 -N<br> #取mysql操作状态<br>UserParameter=mysql.ping,HOME=/etc/zabbix mysqladmin -uzabbix -ppassword | grep -c alive<br>UserParameter=mysql.version,mysql -V #取mysql版本<br>chmod 777 userparameter_mysql.conf<br>service zabbix_agentd restart</li>\n<li>Zabbix配置email报警<br>一、              使用msmtp这个命令行MUA<br>(1)./configure –prefix=/usr/local/msmtp<br>(2)make<br>(3)make install<br>(4)mkdir /usr/local/msmtp/etc<br>(5)touch /usr/local/msmtp/etc/msmtprc<br>(6)在/usr/local/msmtp/etc/msmtprc中写入如下内容：<br>defaults<br>account michael_zhou<br>host mail.chinadba.com<br>domain chinadba.com<br>from michael_zhou@chinadba.com<br>auth login<br>user michael_zhou@chinadba.com<pre><code>password your_password\n</code></pre>account default:michael_zhou<br>logfile /var/log/maillog<br>(7)测试一下：/usr/local/msmtp/bin/msmtp i@chinadba.com，输入内容后按ctrl+D发出。<br>二、    在实际测试中发现直接使用msmtp命令发出去的邮件会看不到发件人和主题，只能看到邮件内容，所以我使用mutt挂接在msmtp上，mutt默认会安装，如果没有安装请yum install mutt*<br>(1)修改mutt的配置文件/etc/Muttrc, 不是/etc/muttrc  ，M要大写<br>1．set sendmail=”/usr/local/msmtp/bin/msmtp”<br>2．set use_from=yes<br>3．set realname=michael_zhou@chinadba.com  #发件人邮箱地址<br>4．set editor=”vi”<br>5．保存退出<br>(2)测试一下：echo “邮件报警测试” | mutt -s “测试” i@chinadba.com  #收件人地址<br>三、    创建 zabbix用于发送邮件的脚本,脚本放在什么位置随便，但是要保证zabbix能找到！<br>(1)vim /usr/bin/baojing,并写入如下内容：<br>#!/bin/bash<br>echo “$3” | mutt -s “$2” $1       # $3表示邮件内容、$2表示邮件标题、$1表示收件人<br>(2)chmod a+x /usr/bin/baojing<br>四、    zabbix配置<br>(1)创建meida types<br>1．登录到zabbix，进入“Administration” &gt;&gt; ”Media types”，点击右上角“Create Media Type”。 Description填”mediatype-baojing”或其它名称，Type选择”Script”，Script填”baojing”。<br>2．点击save保存<br>(2)创建actions<br>1.登录到zabbix，进入”Configation” &gt;&gt; “Actions”，点击右上角”Create Actions”。输入Name “action-baojing” ，其它都默认点击右侧“Action Operations”下的”New”按钮，”Operation Type”选择”Send message”，”Send Message to”选择一个或多个要发送消息的用户组，”Send only to”选择我们之前新增的mediatype-baojing。<br>2.点击save保存<br>(3) zabbix用户配置<br>登录到zabbix, 进入”Adimistration” &gt;&gt; “Users”，在之前选定要发送消息的组里的Members栏位里选择一个用户，例如选择Admin用户。<br>在用户信息修改界面最下方的”Media”处点击”Add”按钮。<br>Type选择”mediatype-baojing”，Send to填入收件人地址，点击Add添加。<br>点击”Save”保存配置。<br>至此配置完成，测试！<br>不光是zabbix,nagios等监控平台的邮件报警都可以这样配置。当然转到139邮箱的话可以收到短信的，会更加及时的收到报警。<br>zabbix企业应用之服务器硬件信息监控<br><a href=\"http://dl528888.blog.51cto.com/2382721/1403893\" target=\"_blank\" rel=\"external\">http://dl528888.blog.51cto.com/2382721/1403893</a><br>zabbix企业应用之Mysql主从监控<br><a href=\"http://dl528888.blog.51cto.com/2382721/1434263\" target=\"_blank\" rel=\"external\">http://dl528888.blog.51cto.com/2382721/1434263</a><br>Zabbix监控MySQL数据库状态<br><a href=\"http://www.linuxidc.com/Linux/2015-04/116304.htm\" target=\"_blank\" rel=\"external\">http://www.linuxidc.com/Linux/2015-04/116304.htm</a><br>Zabbix使用微信接口实现微信报警功能<br><a href=\"http://lcbk.net/zabbix/2022.html\" target=\"_blank\" rel=\"external\">http://lcbk.net/zabbix/2022.html</a><br><a href=\"http://www.cnyunwei.com/thread-29593-1-1.html\" target=\"_blank\" rel=\"external\">http://www.cnyunwei.com/thread-29593-1-1.html</a></li>\n</ol>\n","excerpt":"<ol>\n<li>安装lnmp架构<br><code>yum -y install gcc gcc-c++ autoconf httpd php mysql mysql-server php-mysql httpd-manual mod_ssl mod_perl mod_auth_mysql php-gd php-xml php-mbstring php-ldap php-pear php-xmlrpc php-bcmath mysql-connector-odbc mysql-devel libdbi-dbd-mysql net-snmp-devel curl-devel</code></li>\n<li><p>启动服务<br> service mysqld start<br> service httpd start</p>","more":"</li>\n<li><p>创建zabbix用户和组<br> groupadd zabbix<br> useradd zabbix -g zabbix</p>\n</li>\n<li>进入mysql创建数据库<br> create database zabbix character set utf8;<br> grant all on zabbix.* to zabbix@localhost identified by ‘jszj201501’;</li>\n<li>解压zabbix.tar包<blockquote>\n<p>tar zxf zabbix-2.4.tar.gz<br>cd zabbix-2.4.5/database/mysql/</p>\n</blockquote>\n</li>\n<li>导入数据库<br> mysql -uzabbix -pjszj201501 zabbix &lt;schema.sql<br> mysql -uzabbix -pjszj201501 zabbix &lt;images.sql</li>\n<li>进行编译安装<br> cd ../..<br> ./configure –prefix=/usr/local/zabbix –enable-server –enable-agent –with-mysql –with-net-snmp –with-libcurl<br> make&amp;&amp;make install</li>\n<li>添加zabbix服务对应的端口<br> cat &gt;&gt;/etc/services&lt;&lt;EOF<br> zabbix-agent 10050/tcp Zabbix Agent<br> zabbix-agent 10050/udp Zabbix Agent<br> zabbix-trapper 10051/tcp Zabbix Trapper<br> zabbix-trapper 10051/udp Zabbix Trapper<br> EOF</li>\n<li>修改zabbix server 配置文件<br> vim /usr/local/zabbix/etc/zabbix_server.conf<br> LogFile=/tmp/zabbix_server.log ##日志位置，根据需求修改；<br> PidFile=/tmp/zabbix_server.pid ##PID 所在位置<br> DBHost=localhost ##如果不是在本机，请修改<br> DBName=zabbix ##数据库名称<br> DBUser=zabbix ##数据库用户名<br> DBPassword=redhat ##数据库密码</li>\n<li>安装启动脚本,添加可执行权限<br>cp misc/init.d/fedora/core/zabbix_server /etc/init.d<br>chmod +x /etc/init.d/zabbix_server</li>\n<li><p>查找zabbix_server.conf位置复制</p>\n<p>find / -name zabbix_server.conf</p>\n</li>\n<li>修改启动脚本，启动zabbix server<br>vim /etc/init.d/zabbix_server<br>BASEDIR=/usr/local/zabbix ##修改这个，zabbix 的安装目录<br>CONFILE=$BASEDIR/etc/zabbix_server.conf ##添加这一行，定义配置文件位置<br>#搜索start,修改启动选项，默认是去/etc 下去找配置文件的<br>action $”Starting $BINARY_NAME: ” $FULLPATH -c $CONFILE<br>service zabbix_server start</li>\n<li>安装邮件服务<br>yum install mailx<br>vi /etc/mail.rc<br>set from=xxx@163.com smtp=smtp.163.com<br>set smtp-auth-user=xxx@163.com smtp-auth-password=123456<br>set smtp-auth=login<br>:wq! #保存退出<br>echo “zabbix test mail” |mail -s “zabbix” yyy@163.com<br>linux客户端<br>mkdir /usr/local/zabbix<br>tar zxf zabbix_agents_2.0.6.linux2_6.amd64.tar.gz -C /usr/local/zabbix</li>\n<li>编辑配置文件<br>find / -name zabbix_agentd.conf<br>vim zabbix_agentd.conf<br>LogFile=/tmp/zabbix_agentd.log<br>Server=202.108.1.52 ##服务器IP<br>ServerActive=202.108.1.52 ##主动模式服务器IP<br>Hostname=202.108.1.51 ##设定主机名<br>#加入mysql配置</li>\n<li>安装修改启动脚本<br>scp misc/init.d/fedora/core/zabbix_agentd 202.108.1.51:/etc/init.d<br>vim /etc/init.d/zabbix_agentd<br>BASEDIR=/usr/local/zabbix ##修改这个<br>CONFILE=$BASEDIR/etc/zabbix_agentd.conf ##添加这行，搜索start 添加-c $CONFILE<br>action $”Starting $BINARY_NAME: ” $FULLPATH -c $CONFILE<br>service zabbix_agentd start</li>\n<li>创建用户和用户组<br>groupadd zabbix<br>useradd zabbix -g zabbix<br>windows客户端<br>cmd<br>d:\\zabbix_agentd.exe -i -c d:\\zabbix\\zabbix_agentd.conf<br>services.msc</li>\n<li>禁用内部邮件服务<br>service sendmail stop #关闭<br>chkconfig sendmail off #禁止开机启动<br>service postfix stop<br>chkconfig postfix off</li>\n<li>事件触发器配置：<br>名称：Action-Email<br>默认接收人：故障{TRIGGER.STATUS},服务器:{HOSTNAME1}发生: {TRIGGER.NAME}故障!<br>默认信息：<br>告警主机:{HOSTNAME1}<br>告警时间:{EVENT.DATE} {EVENT.TIME}<br>告警等级:{TRIGGER.SEVERITY}<br>告警信息: {TRIGGER.NAME}<br>告警项目:{TRIGGER.KEY1}<br>问题详情:{ITEM.NAME}:{ITEM.VALUE}<br>当前状态:{TRIGGER.STATUS}:{ITEM.VALUE1}<br>事件ID:{EVENT.ID}<br>恢复信息：打钩<br>恢复主旨：恢复{TRIGGER.STATUS}, 服务器:{HOSTNAME1}: {TRIGGER.NAME}已恢复!<br>恢复信息：<br>告警主机:{HOSTNAME1}<br>告警时间:{EVENT.DATE} {EVENT.TIME}<br>告警等级:{TRIGGER.SEVERITY}<br>告警信息: {TRIGGER.NAME}<br>告警项目:{TRIGGER.KEY1}<br>问题详情:{ITEM.NAME}:{ITEM.VALUE}<br>当前状态:{TRIGGER.STATUS}:{ITEM.VALUE1}<br>事件ID:{EVENT.ID}<br>已启用：打钩</li>\n<li>解决乱码和附件问题<br>vim /usr/local/zabbix/share/zabbix/alertscripts/sendmail.sh<br>#!/bin/bash<br>#export.UTF-8 //解决发送的中文变成了乱码的问题<br>FILE=/tmp/mailtmp.txt<br>echo “$3” &gt;$FILE<br>dos2unix -k $FILE  //解决了发送的邮件内容变成附件的问题。<br>/bin/mail -s “$2” $1 &lt; $FILE<br>touch /tmp/mailtmp.txt<br>chown  zabbix.zabbix /tmp/mailtmp.txt</li>\n<li>zabbix  mysql客户端<br>find / -name userparameter_mysql.conf<br>vi /usr/local/zabbixvim/etc/zabbix_agent.conf<br>Include=/usr/local/zabbix/conf/zabbix_agentd/ #加入mysql配置(find查找的路径)<br>vi /usr/local/zabbix/etc/zabbix_agentd.conf<br>Include=/usr/local/zabbix/conf/zabbix_agentd/ #加入mysql配置<br>mkdir /etc/zabbix<br>touch /etc/zabbix/.my.cnf<br>vim /etc/zabbix/.my.cnf<br>[mysql]<br>host = localhost<br>user = mysqlcheck<br>password = mysqlcheck<br>socket = /var/lib/mysql/mysql.sock(mysql.sock的位置)<br>[mysqladmin]<br>host = localhost<br>user = mysqlcheck<br>password = mysqlchechk<br>socket = /var/lib/mysql/mysql.sock(mysql.sock的位置)<br>vim userparameter_mysql.conf<br>UserParameter=mysql.status[<em>],echo “show global status where Variable_name=’$1′;” | mysql -uzabbix -pjszj201501 -N | awk ‘{print $$2}’ #取mysql状态<br>UserParameter=mysql.size[</em>],echo “select sum($(case “$3″ in both|””) echo “data_length+index_length”;; data|index) echo “$3_length”;; free) echo “data_free”;; esac)) from information_schema.tables$([[ “$1” = “all” || ! “$1″ ]] || echo ” where table_schema=’$1′”)$([[ “$2” = “all” || ! “$2” ]] || echo “and table_name=’$2′”);” | mysql -uzabbix -pjszj201501 -N<br> #取mysql操作状态<br>UserParameter=mysql.ping,HOME=/etc/zabbix mysqladmin -uzabbix -ppassword | grep -c alive<br>UserParameter=mysql.version,mysql -V #取mysql版本<br>chmod 777 userparameter_mysql.conf<br>service zabbix_agentd restart</li>\n<li>Zabbix配置email报警<br>一、              使用msmtp这个命令行MUA<br>(1)./configure –prefix=/usr/local/msmtp<br>(2)make<br>(3)make install<br>(4)mkdir /usr/local/msmtp/etc<br>(5)touch /usr/local/msmtp/etc/msmtprc<br>(6)在/usr/local/msmtp/etc/msmtprc中写入如下内容：<br>defaults<br>account michael_zhou<br>host mail.chinadba.com<br>domain chinadba.com<br>from michael_zhou@chinadba.com<br>auth login<br>user michael_zhou@chinadba.com<pre><code>password your_password\n</code></pre>account default:michael_zhou<br>logfile /var/log/maillog<br>(7)测试一下：/usr/local/msmtp/bin/msmtp i@chinadba.com，输入内容后按ctrl+D发出。<br>二、    在实际测试中发现直接使用msmtp命令发出去的邮件会看不到发件人和主题，只能看到邮件内容，所以我使用mutt挂接在msmtp上，mutt默认会安装，如果没有安装请yum install mutt*<br>(1)修改mutt的配置文件/etc/Muttrc, 不是/etc/muttrc  ，M要大写<br>1．set sendmail=”/usr/local/msmtp/bin/msmtp”<br>2．set use_from=yes<br>3．set realname=michael_zhou@chinadba.com  #发件人邮箱地址<br>4．set editor=”vi”<br>5．保存退出<br>(2)测试一下：echo “邮件报警测试” | mutt -s “测试” i@chinadba.com  #收件人地址<br>三、    创建 zabbix用于发送邮件的脚本,脚本放在什么位置随便，但是要保证zabbix能找到！<br>(1)vim /usr/bin/baojing,并写入如下内容：<br>#!/bin/bash<br>echo “$3” | mutt -s “$2” $1       # $3表示邮件内容、$2表示邮件标题、$1表示收件人<br>(2)chmod a+x /usr/bin/baojing<br>四、    zabbix配置<br>(1)创建meida types<br>1．登录到zabbix，进入“Administration” &gt;&gt; ”Media types”，点击右上角“Create Media Type”。 Description填”mediatype-baojing”或其它名称，Type选择”Script”，Script填”baojing”。<br>2．点击save保存<br>(2)创建actions<br>1.登录到zabbix，进入”Configation” &gt;&gt; “Actions”，点击右上角”Create Actions”。输入Name “action-baojing” ，其它都默认点击右侧“Action Operations”下的”New”按钮，”Operation Type”选择”Send message”，”Send Message to”选择一个或多个要发送消息的用户组，”Send only to”选择我们之前新增的mediatype-baojing。<br>2.点击save保存<br>(3) zabbix用户配置<br>登录到zabbix, 进入”Adimistration” &gt;&gt; “Users”，在之前选定要发送消息的组里的Members栏位里选择一个用户，例如选择Admin用户。<br>在用户信息修改界面最下方的”Media”处点击”Add”按钮。<br>Type选择”mediatype-baojing”，Send to填入收件人地址，点击Add添加。<br>点击”Save”保存配置。<br>至此配置完成，测试！<br>不光是zabbix,nagios等监控平台的邮件报警都可以这样配置。当然转到139邮箱的话可以收到短信的，会更加及时的收到报警。<br>zabbix企业应用之服务器硬件信息监控<br><a href=\"http://dl528888.blog.51cto.com/2382721/1403893\">http://dl528888.blog.51cto.com/2382721/1403893</a><br>zabbix企业应用之Mysql主从监控<br><a href=\"http://dl528888.blog.51cto.com/2382721/1434263\">http://dl528888.blog.51cto.com/2382721/1434263</a><br>Zabbix监控MySQL数据库状态<br><a href=\"http://www.linuxidc.com/Linux/2015-04/116304.htm\">http://www.linuxidc.com/Linux/2015-04/116304.htm</a><br>Zabbix使用微信接口实现微信报警功能<br><a href=\"http://lcbk.net/zabbix/2022.html\">http://lcbk.net/zabbix/2022.html</a><br><a href=\"http://www.cnyunwei.com/thread-29593-1-1.html\">http://www.cnyunwei.com/thread-29593-1-1.html</a></li>\n</ol>"},{"title":"搭建WordPress","date":"2016-09-02T04:00:00.000Z","_content":"\n1.搭建LAMP环境\n<!--more-->\n    service iptables stop\n    setenforce 0\n    yum install httpd mysql mysql-server php php-mysql php-gd php-xml\n    service httpd start\n    service mysqld start\n    chkconfig httpd on //开机启动\n    chkconfig –list |grep httpd\n    chkconfig mysqld on\n    chkconfig –list |grep mysql\n    mysqladmin -u root -p password ‘123’ //为mysql设置用户和密码\n    Enter password: //此处回车即可。\n    mysql -u root -p\n    create database wordpress; //创建wordpress数据库，为下面安装wordpress做准备。\n    show databases;\n\n2.安装WordPress\n\n    unzip wordpress-3.9-zh_CN.zip //解压缩\n    mv wordpress /var/www/html/\n    cd /var/www/html/wordpress/\n    vim wp-config.php","source":"_posts/搭建WordPress.md","raw":"---\ntitle: 搭建WordPress\ndate: 2016-09-02\ntags:\n---\n\n1.搭建LAMP环境\n<!--more-->\n    service iptables stop\n    setenforce 0\n    yum install httpd mysql mysql-server php php-mysql php-gd php-xml\n    service httpd start\n    service mysqld start\n    chkconfig httpd on //开机启动\n    chkconfig –list |grep httpd\n    chkconfig mysqld on\n    chkconfig –list |grep mysql\n    mysqladmin -u root -p password ‘123’ //为mysql设置用户和密码\n    Enter password: //此处回车即可。\n    mysql -u root -p\n    create database wordpress; //创建wordpress数据库，为下面安装wordpress做准备。\n    show databases;\n\n2.安装WordPress\n\n    unzip wordpress-3.9-zh_CN.zip //解压缩\n    mv wordpress /var/www/html/\n    cd /var/www/html/wordpress/\n    vim wp-config.php","slug":"搭建WordPress","published":1,"updated":"2017-03-01T05:59:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cizqklz83000glbpv62p0ka10","content":"<p>1.搭建LAMP环境<br><a id=\"more\"></a><br>    service iptables stop<br>    setenforce 0<br>    yum install httpd mysql mysql-server php php-mysql php-gd php-xml<br>    service httpd start<br>    service mysqld start<br>    chkconfig httpd on //开机启动<br>    chkconfig –list |grep httpd<br>    chkconfig mysqld on<br>    chkconfig –list |grep mysql<br>    mysqladmin -u root -p password ‘123’ //为mysql设置用户和密码<br>    Enter password: //此处回车即可。<br>    mysql -u root -p<br>    create database wordpress; //创建wordpress数据库，为下面安装wordpress做准备。<br>    show databases;</p>\n<p>2.安装WordPress</p>\n<pre><code>unzip wordpress-3.9-zh_CN.zip //解压缩\nmv wordpress /var/www/html/\ncd /var/www/html/wordpress/\nvim wp-config.php\n</code></pre>","excerpt":"<p>1.搭建LAMP环境<br>","more":"<br>    service iptables stop<br>    setenforce 0<br>    yum install httpd mysql mysql-server php php-mysql php-gd php-xml<br>    service httpd start<br>    service mysqld start<br>    chkconfig httpd on //开机启动<br>    chkconfig –list |grep httpd<br>    chkconfig mysqld on<br>    chkconfig –list |grep mysql<br>    mysqladmin -u root -p password ‘123’ //为mysql设置用户和密码<br>    Enter password: //此处回车即可。<br>    mysql -u root -p<br>    create database wordpress; //创建wordpress数据库，为下面安装wordpress做准备。<br>    show databases;</p>\n<p>2.安装WordPress</p>\n<pre><code>unzip wordpress-3.9-zh_CN.zip //解压缩\nmv wordpress /var/www/html/\ncd /var/www/html/wordpress/\nvim wp-config.php\n</code></pre>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}